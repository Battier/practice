From fd5be62b8ee19d981e2627b8c89d8b5a6bbf8e28 Mon Sep 17 00:00:00 2001
From: Fanqi Lu <fanqiustc@gmail.com>
Date: Tue, 19 Jan 2021 07:03:05 +0800
Subject: [PATCH] Speed up building

---
 build_docker.sh                               |    2 +-
 .../plugins/eeprom.py                         |   12 +-
 .../plugins/led_control.py                    |   11 +-
 .../plugins/psuutil.py                        |   11 +-
 .../plugins/sfputil.py                        |   11 +-
 .../plugins/eeprom.py                         |   12 +-
 .../plugins/led_control.py                    |   11 +-
 .../plugins/psuutil.py                        |   11 +-
 .../plugins/sfputil.py                        |   11 +-
 .../plugins/eeprom.py                         |   12 +-
 .../plugins/led_control.py                    |   11 +-
 .../plugins/psuutil.py                        |   11 +-
 .../plugins/sfputil.py                        |   11 +-
 .../plugins/eeprom.py                         |   12 +-
 .../plugins/led_control.py                    |   11 +-
 .../plugins/psuutil.py                        |   11 +-
 .../plugins/sfputil.py                        |   11 +-
 .../x86_64-mlnx_msn2010-r0/plugins/eeprom.py  |   76 +-
 .../x86_64-mlnx_msn2010-r0/plugins/fanutil.py |  203 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../x86_64-mlnx_msn2010-r0/plugins/sfputil.py |  689 ++++++-
 .../plugins/thermalutil.py                    |  457 ++++-
 .../x86_64-mlnx_msn2100-r0/plugins/eeprom.py  |   76 +-
 .../x86_64-mlnx_msn2100-r0/plugins/fanutil.py |  203 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../x86_64-mlnx_msn2100-r0/plugins/sfputil.py |  689 ++++++-
 .../plugins/thermalutil.py                    |  457 ++++-
 .../x86_64-mlnx_msn2410-r0/plugins/eeprom.py  |   76 +-
 .../x86_64-mlnx_msn2410-r0/plugins/fanutil.py |  203 +-
 .../x86_64-mlnx_msn2410-r0/plugins/psuutil.py |  185 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../x86_64-mlnx_msn2410-r0/plugins/sfputil.py |  689 ++++++-
 .../plugins/thermalutil.py                    |  457 ++++-
 .../x86_64-mlnx_msn2740-r0/plugins/eeprom.py  |   76 +-
 .../x86_64-mlnx_msn2740-r0/plugins/fanutil.py |  203 +-
 .../x86_64-mlnx_msn2740-r0/plugins/psuutil.py |  185 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../x86_64-mlnx_msn2740-r0/plugins/sfputil.py |  689 ++++++-
 .../plugins/thermalutil.py                    |  457 ++++-
 .../x86_64-mlnx_msn3420-r0/plugins/eeprom.py  |   76 +-
 .../x86_64-mlnx_msn3420-r0/plugins/psuutil.py |  185 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../x86_64-mlnx_msn3420-r0/plugins/sfputil.py |  689 ++++++-
 .../x86_64-mlnx_msn3700-r0/plugins/eeprom.py  |   76 +-
 .../x86_64-mlnx_msn3700-r0/plugins/fanutil.py |  203 +-
 .../x86_64-mlnx_msn3700-r0/plugins/psuutil.py |  185 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../x86_64-mlnx_msn3700-r0/plugins/sfputil.py |  689 ++++++-
 .../x86_64-mlnx_msn3700c-r0/plugins/eeprom.py |   76 +-
 .../plugins/fanutil.py                        |  203 +-
 .../plugins/psuutil.py                        |  185 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../plugins/sfputil.py                        |  689 ++++++-
 .../plugins/thermalutil.py                    |  457 ++++-
 .../x86_64-mlnx_msn3800-r0/plugins/eeprom.py  |   76 +-
 .../x86_64-mlnx_msn3800-r0/plugins/fanutil.py |  203 +-
 .../x86_64-mlnx_msn3800-r0/plugins/psuutil.py |  185 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../x86_64-mlnx_msn3800-r0/plugins/sfputil.py |  689 ++++++-
 .../plugins/thermalutil.py                    |  457 ++++-
 .../x86_64-mlnx_msn4410-r0/plugins/eeprom.py  |   76 +-
 .../x86_64-mlnx_msn4410-r0/plugins/psuutil.py |  185 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../x86_64-mlnx_msn4600c-r0/plugins/eeprom.py |   76 +-
 .../plugins/psuutil.py                        |  185 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../plugins/sfputil.py                        |  689 ++++++-
 .../x86_64-mlnx_msn4700-r0/plugins/eeprom.py  |   76 +-
 .../x86_64-mlnx_msn4700-r0/plugins/psuutil.py |  185 +-
 .../plugins/sfplpmget.py                      |   55 +-
 .../plugins/sfplpmset.py                      |  170 +-
 .../plugins/sfpreset.py                       |   30 +-
 .../x86_64-mlnx_msn4700-r0/plugins/sfputil.py |  689 ++++++-
 device/virtual/x86_64-kvm_x86_64-r0/asic.conf |    2 +-
 dockers/docker-base-buster/sources.list       |   12 +-
 dockers/docker-base-stretch/sources.list      |   12 +-
 dockers/docker-base/sources.list              |   10 +-
 .../docker-config-engine-buster/Dockerfile.j2 |    2 +-
 dockers/docker-ptf/Dockerfile.j2              |    8 +-
 dockers/docker-sonic-mgmt/Dockerfile.j2       |    6 +-
 files/apt/sources.list.amd64                  |   12 +-
 ...ian_archive_trafficmanager_net_debian.list |    6 +-
 platform/barefoot/bfn-platform-ingrasys.mk    |    2 +-
 platform/barefoot/bfn-platform-wnc.mk         |    2 +-
 platform/barefoot/bfn-platform.mk             |    2 +-
 platform/barefoot/bfn-sai.mk                  |    2 +-
 .../docker-syncd-bfn-rpc/Dockerfile.j2        |    2 +-
 .../setup.py                                  |    2 +-
 .../setup.py                                  |   32 +-
 .../sonic-platform-modules-bfn/setup.py       |   32 +-
 .../docker-syncd-brcm-rpc/Dockerfile.j2       |    2 +-
 .../sonic-platform-modules-cel/dx010/setup.py |    2 +-
 .../haliburton/setup.py                       |    2 +-
 .../services/platform_api/setup.py            |    2 +-
 .../silverstone/setup.py                      |    2 +-
 .../s5232f/setup.py                           |   32 +-
 .../s5232f/sonic_platform/hwaccess.py         |   25 +-
 .../s6000/setup.py                            |   32 +-
 .../s6100/setup.py                            |    2 +-
 .../tools/flashrom.sh                         |    2 +-
 .../z9100/setup.py                            |   32 +-
 .../z9264f/setup.py                           |   32 +-
 .../z9332f/setup.py                           |   32 +-
 .../z9332f/sonic_platform/hwaccess.py         |   25 +-
 platform/cavium/cavm-sai.mk                   |    2 +-
 platform/cavium/cavm-xpnet.mk                 |    2 +-
 .../cavium/cavm_platform_modules/Makefile     |    2 +-
 .../docker-syncd-cavm-rpc/Dockerfile.j2       |    2 +-
 .../docker-syncd-centec-rpc/Dockerfile.j2     |    2 +-
 platform/centec-arm64/sai.mk                  |    2 +-
 .../docker-syncd-centec-rpc/Dockerfile.j2     |    2 +-
 platform/centec/sdk.mk                        |    2 +-
 .../docker-syncd-invm-rpc/Dockerfile.j2       |    2 +-
 platform/innovium/invm-sai.mk                 |    2 +-
 .../docker-syncd-mrvl-rpc/Dockerfile.j2       |    2 +-
 platform/marvell-arm64/linux-kernel-arm64.mk  |    2 +-
 platform/marvell-arm64/linux/Makefile         |    2 +-
 platform/marvell-arm64/sai/Makefile           |    2 +-
 .../docker-syncd-mrvl-rpc/Dockerfile.j2       |    2 +-
 platform/marvell-armhf/linux-kernel-armhf.mk  |    2 +-
 platform/marvell-armhf/linux/Makefile         |    2 +-
 platform/marvell-armhf/sai/Makefile           |    2 +-
 .../docker-syncd-mrvl-rpc/Dockerfile.j2       |    2 +-
 platform/marvell/sai/Makefile                 |    2 +-
 .../docker-syncd-mlnx-rpc/Dockerfile.j2       |    2 +-
 platform/mellanox/mlnx-platform-api/setup.py  |    2 +-
 .../docker-syncd-nephos-rpc/Dockerfile.j2     |    2 +-
 platform/nephos/rules.mk                      |    4 +-
 platform/nephos/sai.mk                        |    4 +-
 .../as7116-54x/setup.py                       |    2 +-
 platform/pddf/platform-api-pddf-base/setup.py |    2 +-
 platform/vs/docker-sonic-vs/Dockerfile.j2     |    2 +-
 platform/vs/tests/conftest.py                 | 1631 ++++++++++++++++-
 rules/phy-credo.mk                            |    2 +-
 scripts/build_debian_base_system.sh           |    2 +-
 slave.mk                                      |    2 +-
 sonic-slave-buster/Dockerfile.j2              |   11 +-
 sonic-slave-jessie/Dockerfile.j2              |   10 +-
 sonic-slave-stretch/Dockerfile.j2             |    8 +-
 src/gobgp/Makefile                            |    4 +-
 src/ifupdown2/Makefile                        |    2 +-
 src/iptables/Makefile                         |    2 +-
 src/kdump-tools/Makefile                      |    4 +-
 src/libnl3/Makefile                           |    2 +-
 src/libteam/Makefile                          |    2 +-
 src/libyang/Makefile                          |    2 +-
 src/lm-sensors/Makefile                       |    2 +-
 src/ntp/Makefile                              |    4 +-
 src/sflow/hsflowd/Makefile                    |    2 +-
 src/sflow/psample/Makefile                    |    2 +-
 src/sflow/sflowtool/Makefile                  |    2 +-
 src/sonic-bgpcfgd/setup.py                    |    2 +-
 src/sonic-config-engine/openconfig_acl.py     |    8 +-
 src/sonic-config-engine/setup.py              |    2 +-
 src/sonic-ctrmgrd/setup.py                    |    2 +-
 src/sonic-host-services/setup.py              |    2 +-
 src/sonic-py-common/setup.py                  |    2 +-
 src/sonic-yang-mgmt/sonic_yang_ext.py         |    2 +-
 .../tests/test_sonic_yang_mgmt.py             |    2 +-
 .../tests/test_sonic_yang_models.py           |    2 +-
 src/system-health/setup.py                    |    2 +-
 src/tacacs/nss/Makefile                       |    2 +-
 src/tacacs/pam/Makefile                       |    2 +-
 183 files changed, 18469 insertions(+), 228 deletions(-)
 mode change 120000 => 100644 device/arista/x86_64-arista_7050_qx32s/plugins/eeprom.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7050_qx32s/plugins/led_control.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7050_qx32s/plugins/psuutil.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7050_qx32s/plugins/sfputil.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7050cx3_32s/plugins/eeprom.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7050cx3_32s/plugins/led_control.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7050cx3_32s/plugins/psuutil.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7050cx3_32s/plugins/sfputil.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7060_cx32s/plugins/eeprom.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7060_cx32s/plugins/led_control.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7060_cx32s/plugins/psuutil.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7060_cx32s/plugins/sfputil.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7260cx3_64/plugins/eeprom.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7260cx3_64/plugins/led_control.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7260cx3_64/plugins/psuutil.py
 mode change 120000 => 100644 device/arista/x86_64-arista_7260cx3_64/plugins/sfputil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2010-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2010-r0/plugins/fanutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfputil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2010-r0/plugins/thermalutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2100-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2100-r0/plugins/fanutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfputil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2100-r0/plugins/thermalutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2410-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2410-r0/plugins/fanutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2410-r0/plugins/psuutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfputil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2410-r0/plugins/thermalutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2740-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2740-r0/plugins/fanutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2740-r0/plugins/psuutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfputil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn2740-r0/plugins/thermalutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3420-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3420-r0/plugins/psuutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfputil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700-r0/plugins/fanutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700-r0/plugins/psuutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfputil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/fanutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/psuutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfputil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/thermalutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3800-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3800-r0/plugins/fanutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3800-r0/plugins/psuutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfputil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn3800-r0/plugins/thermalutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4410-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4410-r0/plugins/psuutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/psuutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfputil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4700-r0/plugins/eeprom.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4700-r0/plugins/psuutil.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmget.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfpreset.py
 mode change 120000 => 100644 device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfputil.py
 mode change 120000 => 100755 platform/barefoot/sonic-platform-modules-bfn-newport/setup.py
 mode change 120000 => 100755 platform/barefoot/sonic-platform-modules-bfn/setup.py
 mode change 120000 => 100755 platform/broadcom/sonic-platform-modules-dell/s5232f/setup.py
 mode change 120000 => 100644 platform/broadcom/sonic-platform-modules-dell/s5232f/sonic_platform/hwaccess.py
 mode change 120000 => 100755 platform/broadcom/sonic-platform-modules-dell/s6000/setup.py
 mode change 120000 => 100755 platform/broadcom/sonic-platform-modules-dell/z9100/setup.py
 mode change 120000 => 100755 platform/broadcom/sonic-platform-modules-dell/z9264f/setup.py
 mode change 120000 => 100755 platform/broadcom/sonic-platform-modules-dell/z9332f/setup.py
 mode change 120000 => 100644 platform/broadcom/sonic-platform-modules-dell/z9332f/sonic_platform/hwaccess.py
 mode change 120000 => 100644 platform/vs/tests/conftest.py

diff --git a/build_docker.sh b/build_docker.sh
index ec07698d..f05d6b80 100755
--- a/build_docker.sh
+++ b/build_docker.sh
@@ -87,7 +87,7 @@ image_id=$(docker inspect --format="{{json .Id}}" $docker_image_name | sed -e 's
 ## Note: it will squash the image with only one layer and lost all metadata such as ENTRYPOINT,
 ##       so apply only to the base image
 ## TODO: wait docker-squash supporting Docker 1.10+
-## ref: https://github.com/jwilder/docker-squash/issues/45
+## ref: https://hub.fastgit.org/jwilder/docker-squash/issues/45
 if [ "$docker_image_name" = "docker-base" ]; then
     ## Run old image in a container
     tmp_container=$(docker run -d ${docker_image_name} /bin/bash)
diff --git a/device/arista/x86_64-arista_7050_qx32s/plugins/eeprom.py b/device/arista/x86_64-arista_7050_qx32s/plugins/eeprom.py
deleted file mode 120000
index 35cfaff3..00000000
--- a/device/arista/x86_64-arista_7050_qx32s/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7050_qx32s/plugins/eeprom.py b/device/arista/x86_64-arista_7050_qx32s/plugins/eeprom.py
new file mode 100644
index 00000000..3cc5a6b1
--- /dev/null
+++ b/device/arista/x86_64-arista_7050_qx32s/plugins/eeprom.py
@@ -0,0 +1,11 @@
+#
+# Arista eeprom processing for SONiC
+# Uses the arista driver library to obtain the TlvInfoDecoder
+#
+
+try:
+    import arista.utils.sonic_eeprom as arista_eeprom
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+board = arista_eeprom.getTlvInfoDecoder()
diff --git a/device/arista/x86_64-arista_7050_qx32s/plugins/led_control.py b/device/arista/x86_64-arista_7050_qx32s/plugins/led_control.py
deleted file mode 120000
index 8d733780..00000000
--- a/device/arista/x86_64-arista_7050_qx32s/plugins/led_control.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/led_control.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7050_qx32s/plugins/led_control.py b/device/arista/x86_64-arista_7050_qx32s/plugins/led_control.py
new file mode 100644
index 00000000..8ea9f70a
--- /dev/null
+++ b/device/arista/x86_64-arista_7050_qx32s/plugins/led_control.py
@@ -0,0 +1,10 @@
+#
+# Arista LED controls for SONiC
+#
+
+try:
+    import arista.utils.sonic_leds as arista_leds
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+LedControl = arista_leds.getLedControl()
diff --git a/device/arista/x86_64-arista_7050_qx32s/plugins/psuutil.py b/device/arista/x86_64-arista_7050_qx32s/plugins/psuutil.py
deleted file mode 120000
index 2b0024ad..00000000
--- a/device/arista/x86_64-arista_7050_qx32s/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7050_qx32s/plugins/psuutil.py b/device/arista/x86_64-arista_7050_qx32s/plugins/psuutil.py
new file mode 100644
index 00000000..14755365
--- /dev/null
+++ b/device/arista/x86_64-arista_7050_qx32s/plugins/psuutil.py
@@ -0,0 +1,10 @@
+#
+# Arista PSU interface for SONiC
+#
+
+try:
+    import arista.utils.sonic_psu as arista_psuutil
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+PsuUtil = arista_psuutil.getPsuUtil()
diff --git a/device/arista/x86_64-arista_7050_qx32s/plugins/sfputil.py b/device/arista/x86_64-arista_7050_qx32s/plugins/sfputil.py
deleted file mode 120000
index c333e237..00000000
--- a/device/arista/x86_64-arista_7050_qx32s/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7050_qx32s/plugins/sfputil.py b/device/arista/x86_64-arista_7050_qx32s/plugins/sfputil.py
new file mode 100644
index 00000000..4c99ad53
--- /dev/null
+++ b/device/arista/x86_64-arista_7050_qx32s/plugins/sfputil.py
@@ -0,0 +1,10 @@
+#
+# Arista SFP transceiver interface for SONiC
+#
+
+try:
+    import arista.utils.sonic_sfputil as arista_sfputil
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+SfpUtil = arista_sfputil.getSfpUtil()
diff --git a/device/arista/x86_64-arista_7050cx3_32s/plugins/eeprom.py b/device/arista/x86_64-arista_7050cx3_32s/plugins/eeprom.py
deleted file mode 120000
index 35cfaff3..00000000
--- a/device/arista/x86_64-arista_7050cx3_32s/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7050cx3_32s/plugins/eeprom.py b/device/arista/x86_64-arista_7050cx3_32s/plugins/eeprom.py
new file mode 100644
index 00000000..3cc5a6b1
--- /dev/null
+++ b/device/arista/x86_64-arista_7050cx3_32s/plugins/eeprom.py
@@ -0,0 +1,11 @@
+#
+# Arista eeprom processing for SONiC
+# Uses the arista driver library to obtain the TlvInfoDecoder
+#
+
+try:
+    import arista.utils.sonic_eeprom as arista_eeprom
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+board = arista_eeprom.getTlvInfoDecoder()
diff --git a/device/arista/x86_64-arista_7050cx3_32s/plugins/led_control.py b/device/arista/x86_64-arista_7050cx3_32s/plugins/led_control.py
deleted file mode 120000
index 8d733780..00000000
--- a/device/arista/x86_64-arista_7050cx3_32s/plugins/led_control.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/led_control.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7050cx3_32s/plugins/led_control.py b/device/arista/x86_64-arista_7050cx3_32s/plugins/led_control.py
new file mode 100644
index 00000000..8ea9f70a
--- /dev/null
+++ b/device/arista/x86_64-arista_7050cx3_32s/plugins/led_control.py
@@ -0,0 +1,10 @@
+#
+# Arista LED controls for SONiC
+#
+
+try:
+    import arista.utils.sonic_leds as arista_leds
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+LedControl = arista_leds.getLedControl()
diff --git a/device/arista/x86_64-arista_7050cx3_32s/plugins/psuutil.py b/device/arista/x86_64-arista_7050cx3_32s/plugins/psuutil.py
deleted file mode 120000
index 2b0024ad..00000000
--- a/device/arista/x86_64-arista_7050cx3_32s/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7050cx3_32s/plugins/psuutil.py b/device/arista/x86_64-arista_7050cx3_32s/plugins/psuutil.py
new file mode 100644
index 00000000..14755365
--- /dev/null
+++ b/device/arista/x86_64-arista_7050cx3_32s/plugins/psuutil.py
@@ -0,0 +1,10 @@
+#
+# Arista PSU interface for SONiC
+#
+
+try:
+    import arista.utils.sonic_psu as arista_psuutil
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+PsuUtil = arista_psuutil.getPsuUtil()
diff --git a/device/arista/x86_64-arista_7050cx3_32s/plugins/sfputil.py b/device/arista/x86_64-arista_7050cx3_32s/plugins/sfputil.py
deleted file mode 120000
index c333e237..00000000
--- a/device/arista/x86_64-arista_7050cx3_32s/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7050cx3_32s/plugins/sfputil.py b/device/arista/x86_64-arista_7050cx3_32s/plugins/sfputil.py
new file mode 100644
index 00000000..4c99ad53
--- /dev/null
+++ b/device/arista/x86_64-arista_7050cx3_32s/plugins/sfputil.py
@@ -0,0 +1,10 @@
+#
+# Arista SFP transceiver interface for SONiC
+#
+
+try:
+    import arista.utils.sonic_sfputil as arista_sfputil
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+SfpUtil = arista_sfputil.getSfpUtil()
diff --git a/device/arista/x86_64-arista_7060_cx32s/plugins/eeprom.py b/device/arista/x86_64-arista_7060_cx32s/plugins/eeprom.py
deleted file mode 120000
index 35cfaff3..00000000
--- a/device/arista/x86_64-arista_7060_cx32s/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7060_cx32s/plugins/eeprom.py b/device/arista/x86_64-arista_7060_cx32s/plugins/eeprom.py
new file mode 100644
index 00000000..3cc5a6b1
--- /dev/null
+++ b/device/arista/x86_64-arista_7060_cx32s/plugins/eeprom.py
@@ -0,0 +1,11 @@
+#
+# Arista eeprom processing for SONiC
+# Uses the arista driver library to obtain the TlvInfoDecoder
+#
+
+try:
+    import arista.utils.sonic_eeprom as arista_eeprom
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+board = arista_eeprom.getTlvInfoDecoder()
diff --git a/device/arista/x86_64-arista_7060_cx32s/plugins/led_control.py b/device/arista/x86_64-arista_7060_cx32s/plugins/led_control.py
deleted file mode 120000
index 8d733780..00000000
--- a/device/arista/x86_64-arista_7060_cx32s/plugins/led_control.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/led_control.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7060_cx32s/plugins/led_control.py b/device/arista/x86_64-arista_7060_cx32s/plugins/led_control.py
new file mode 100644
index 00000000..8ea9f70a
--- /dev/null
+++ b/device/arista/x86_64-arista_7060_cx32s/plugins/led_control.py
@@ -0,0 +1,10 @@
+#
+# Arista LED controls for SONiC
+#
+
+try:
+    import arista.utils.sonic_leds as arista_leds
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+LedControl = arista_leds.getLedControl()
diff --git a/device/arista/x86_64-arista_7060_cx32s/plugins/psuutil.py b/device/arista/x86_64-arista_7060_cx32s/plugins/psuutil.py
deleted file mode 120000
index 2b0024ad..00000000
--- a/device/arista/x86_64-arista_7060_cx32s/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7060_cx32s/plugins/psuutil.py b/device/arista/x86_64-arista_7060_cx32s/plugins/psuutil.py
new file mode 100644
index 00000000..14755365
--- /dev/null
+++ b/device/arista/x86_64-arista_7060_cx32s/plugins/psuutil.py
@@ -0,0 +1,10 @@
+#
+# Arista PSU interface for SONiC
+#
+
+try:
+    import arista.utils.sonic_psu as arista_psuutil
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+PsuUtil = arista_psuutil.getPsuUtil()
diff --git a/device/arista/x86_64-arista_7060_cx32s/plugins/sfputil.py b/device/arista/x86_64-arista_7060_cx32s/plugins/sfputil.py
deleted file mode 120000
index c333e237..00000000
--- a/device/arista/x86_64-arista_7060_cx32s/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7060_cx32s/plugins/sfputil.py b/device/arista/x86_64-arista_7060_cx32s/plugins/sfputil.py
new file mode 100644
index 00000000..4c99ad53
--- /dev/null
+++ b/device/arista/x86_64-arista_7060_cx32s/plugins/sfputil.py
@@ -0,0 +1,10 @@
+#
+# Arista SFP transceiver interface for SONiC
+#
+
+try:
+    import arista.utils.sonic_sfputil as arista_sfputil
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+SfpUtil = arista_sfputil.getSfpUtil()
diff --git a/device/arista/x86_64-arista_7260cx3_64/plugins/eeprom.py b/device/arista/x86_64-arista_7260cx3_64/plugins/eeprom.py
deleted file mode 120000
index 35cfaff3..00000000
--- a/device/arista/x86_64-arista_7260cx3_64/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7260cx3_64/plugins/eeprom.py b/device/arista/x86_64-arista_7260cx3_64/plugins/eeprom.py
new file mode 100644
index 00000000..3cc5a6b1
--- /dev/null
+++ b/device/arista/x86_64-arista_7260cx3_64/plugins/eeprom.py
@@ -0,0 +1,11 @@
+#
+# Arista eeprom processing for SONiC
+# Uses the arista driver library to obtain the TlvInfoDecoder
+#
+
+try:
+    import arista.utils.sonic_eeprom as arista_eeprom
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+board = arista_eeprom.getTlvInfoDecoder()
diff --git a/device/arista/x86_64-arista_7260cx3_64/plugins/led_control.py b/device/arista/x86_64-arista_7260cx3_64/plugins/led_control.py
deleted file mode 120000
index 8d733780..00000000
--- a/device/arista/x86_64-arista_7260cx3_64/plugins/led_control.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/led_control.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7260cx3_64/plugins/led_control.py b/device/arista/x86_64-arista_7260cx3_64/plugins/led_control.py
new file mode 100644
index 00000000..8ea9f70a
--- /dev/null
+++ b/device/arista/x86_64-arista_7260cx3_64/plugins/led_control.py
@@ -0,0 +1,10 @@
+#
+# Arista LED controls for SONiC
+#
+
+try:
+    import arista.utils.sonic_leds as arista_leds
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+LedControl = arista_leds.getLedControl()
diff --git a/device/arista/x86_64-arista_7260cx3_64/plugins/psuutil.py b/device/arista/x86_64-arista_7260cx3_64/plugins/psuutil.py
deleted file mode 120000
index 2b0024ad..00000000
--- a/device/arista/x86_64-arista_7260cx3_64/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7260cx3_64/plugins/psuutil.py b/device/arista/x86_64-arista_7260cx3_64/plugins/psuutil.py
new file mode 100644
index 00000000..14755365
--- /dev/null
+++ b/device/arista/x86_64-arista_7260cx3_64/plugins/psuutil.py
@@ -0,0 +1,10 @@
+#
+# Arista PSU interface for SONiC
+#
+
+try:
+    import arista.utils.sonic_psu as arista_psuutil
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+PsuUtil = arista_psuutil.getPsuUtil()
diff --git a/device/arista/x86_64-arista_7260cx3_64/plugins/sfputil.py b/device/arista/x86_64-arista_7260cx3_64/plugins/sfputil.py
deleted file mode 120000
index c333e237..00000000
--- a/device/arista/x86_64-arista_7260cx3_64/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-arista_common/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/arista/x86_64-arista_7260cx3_64/plugins/sfputil.py b/device/arista/x86_64-arista_7260cx3_64/plugins/sfputil.py
new file mode 100644
index 00000000..4c99ad53
--- /dev/null
+++ b/device/arista/x86_64-arista_7260cx3_64/plugins/sfputil.py
@@ -0,0 +1,10 @@
+#
+# Arista SFP transceiver interface for SONiC
+#
+
+try:
+    import arista.utils.sonic_sfputil as arista_sfputil
+except ImportError as e:
+    raise ImportError("%s - required module not found" % e)
+
+SfpUtil = arista_sfputil.getSfpUtil()
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/fanutil.py
deleted file mode 120000
index 82ea06ef..00000000
--- a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/fanutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/fanutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/fanutil.py
new file mode 100644
index 00000000..ee6446e7
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/fanutil.py
@@ -0,0 +1,202 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from glob import glob
+    from sonic_fan.fan_base import FanBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("fanutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class FanUtil(FanBase):
+    """Platform-specific FanUtil class"""
+
+    PWM_MAX = 255
+    MAX_FAN_PER_DRAWER = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    sku_without_fan_direction = ['ACS-MSN2010', 'ACS-MSN2100', 'ACS-MSN2410',
+                                 'ACS-MSN2700', 'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+    sku_with_unpluggable_fan = ['ACS-MSN2010', 'ACS-MSN2100']
+
+    def __init__(self):
+        FanBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.fan_path = "/var/run/hw-management/"
+        if self.sku_name in self.sku_with_unpluggable_fan:
+            self.fan_status = None
+            self.unpluggable_fan = True
+        else:
+            self.fan_status = "thermal/fan{}_status"
+            self.unpluggable_fan = False
+        self.fan_get_speed = "thermal/fan{}_speed_get"
+        self.fan_set_speed = "thermal/fan{}_speed_set"
+        if self.sku_name in self.sku_without_fan_direction:
+            self.fan_direction = None
+        else:
+            self.fan_direction = "system/fan_dir"
+
+        self.fan_led_green = "led/led_fan*_green"
+        self.num_of_fan, self.num_of_drawer = self._extract_num_of_fans_and_fan_drawers()
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def _extract_num_of_fans_and_fan_drawers(self):
+        # So far we don't have files representing the number of fans and drawers
+        # The only way to retrieve the number is to count files.
+        # for number of fans, we get it via couting the speed files.
+        # for number of draws, we get it via couting the green led files.
+        list_of_fan_speed = glob(self.fan_path + self.fan_get_speed.format("*"))
+        num_of_fan = len(list_of_fan_speed)
+        list_of_fan_leds = glob(self.fan_path + self.fan_led_green)
+        num_of_drawer = len(list_of_fan_leds)
+
+        return num_of_fan, num_of_drawer
+
+    def _convert_fan_index_to_drawer_index(self, index):
+        return (index + self.MAX_FAN_PER_DRAWER - 1) / self.MAX_FAN_PER_DRAWER
+
+    def _read_file(self, file_pattern, index=0):
+        """
+        Reads the file of the fan
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the fan of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(os.path.join(self.fan_path, file_pattern.format(index)), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.fan_path + file_pattern.format(index)))
+            return return_value
+
+        return return_value
+
+    def get_num_fans(self):
+        """
+        Retrieves the number of FANs supported on the device
+
+        :return: An integer, the number of FANs supported on the device
+        """
+        return self.num_of_fan
+
+    def get_status(self, index):
+        """
+        Retrieves the operational status of FAN defined
+                by index 1-based <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean,
+            - True if FAN is running with some speed 
+            - False if FAN has stopped running
+        """
+        if not self.get_presence(index):
+            return False
+
+        return self.get_speed(index) != 0
+
+    def get_presence(self, index):
+        """
+        Retrieves the presence status of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: Boolean, True if FAN is plugged, False if not
+        """
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        if self.unpluggable_fan:
+            return True
+
+        draw_index = self._convert_fan_index_to_drawer_index(index)
+        presence = self._read_file(self.fan_status, draw_index)
+
+        return presence != 0
+
+    def get_direction(self, index):
+        """
+        Retrieves the airflow direction of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: string, denoting FAN airflow direction
+        Note:
+            What Mellanox calls forward: 
+            Air flows from fans side to QSFP side, for example: MSN2700-CS2F
+            which means intake in community
+            What Mellanox calls reverse:
+            Air flow from QSFP side to fans side, for example: MSN2700-CS2R
+            which means exhaust in community
+            According to hw-mgmt:
+                1 stands for forward, in other words intake
+                0 stands for reverse, in other words exhaust
+        """
+        if not self.fan_direction:
+            return self.FAN_DIRECTION_NOT_APPLICABLE
+
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        drawer_index = self._convert_fan_index_to_drawer_index(index)
+
+        fan_dir_bits = self._read_file(self.fan_direction)
+        fan_mask = 1 << drawer_index - 1
+        if fan_dir_bits & fan_mask:
+            return self.FAN_DIRECTION_INTAKE
+        else:
+            return self.FAN_DIRECTION_EXHAUST
+
+    def get_speed(self, index):
+        """
+        Retrieves the speed of a Front FAN in the tray in revolutions per minute defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query speed
+        :return: integer, denoting front FAN speed
+        """
+        speed = self._read_file(self.fan_get_speed, index)
+
+        return speed
+
+    def set_speed(self, val):
+        """
+        Sets the speed of all the FANs to a value denoted by the duty-cycle percentage val
+
+        :param val: An integer, <0-100> denoting FAN duty cycle percentage 
+        :return: Boolean, True if operation is successful, False if not
+        """
+        status = True
+        pwm = int(round(self.PWM_MAX*val/100.0))
+
+        try:
+            with open(os.path.join(self.fan_path, self.fan_set_speed.format(1)), 'w') as fan_pwm:
+                fan_pwm.write(str(pwm))
+        except (ValueError, IOError):
+            log_err("Read file {} failed".format(self.fan_path + self.fan_set_speed.format(1)))
+            status = False
+
+        return status
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfputil.py
deleted file mode 120000
index 45909b88..00000000
--- a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfputil.py
new file mode 100644
index 00000000..954ed23d
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/sfputil.py
@@ -0,0 +1,688 @@
+# sfputil.py
+#
+# Platform-specific SFP transceiver interface for SONiC
+#
+
+try:
+    import time
+    import subprocess
+    from sonic_sfp.sfputilbase import *
+    import syslog
+except ImportError as e:
+    raise ImportError("%s - required module not found" % str(e))
+
+# sfp supports dom
+XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT = 0x40
+
+# sfp module threshold offset and width
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+
+# I2C page size for sfp
+SFP_I2C_PAGE_SIZE = 256
+
+# parameters for DB connection
+REDIS_TIMEOUT_USECS = 0
+
+# parameters for SFP presence
+SFP_STATUS_INSERTED = '1'
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+GET_PLATFORM_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.platform"
+
+# Ethernet<n> <=> sfp<n+SFP_PORT_NAME_OFFSET>
+SFP_PORT_NAME_OFFSET = 0
+SFP_PORT_NAME_CONVENTION = "sfp{}"
+
+# magic code defnition for port number, qsfp port position of each platform
+# port_position_tuple = (PORT_START, QSFP_PORT_START, PORT_END, PORT_IN_BLOCK, EEPROM_OFFSET)
+platform_dict = {'x86_64-mlnx_msn2700-r0': 0, 'x86_64-mlnx_msn2740-r0': 0, 'x86_64-mlnx_msn2100-r0': 1, 'x86_64-mlnx_msn2410-r0': 2, 'x86_64-mlnx_msn2010-r0': 3,
+                 'x86_64-mlnx_msn3420-r0': 5, 'x86_64-mlnx_msn3700-r0': 0, 'x86_64-mlnx_msn3700c-r0': 0, 'x86_64-mlnx_msn3800-r0': 4, 'x86_64-mlnx_msn4600c': 4, 'x86_64-mlnx_msn4700-r0': 0}
+port_position_tuple_list = [(0, 0, 31, 32, 1), (0, 0, 15, 16, 1), (0, 48, 55, 56, 1),
+                            (0, 18, 21, 22, 1), (0, 0, 63, 64, 1), (0, 48, 59, 60, 1)]
+
+
+def log_info(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+def log_err(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class SfpUtil(SfpUtilBase):
+    """Platform-specific SfpUtil class"""
+    PORT_START = 0
+    QSFP_PORT_START = 0
+    PORT_END = 0
+    PORTS_IN_BLOCK = 0
+    EEPROM_OFFSET = 0
+
+    db_sel = None
+    db_sel_timeout = None
+    db_sel_object = None
+    db_sel_tbl = None
+    state_db = None
+    sfpd_status_tbl = None
+
+    @property
+    def port_start(self):
+        return self.PORT_START
+
+    @property
+    def port_end(self):
+        return self.PORT_END
+
+    @property
+    def qsfp_ports(self):
+        return list(range(self.QSFP_PORT_START, self.PORTS_IN_BLOCK + 1))
+
+    @property
+    def port_to_eeprom_mapping(self):
+        print("dependency on sysfs has been removed")
+        raise Exception()
+
+    def get_port_position_tuple_by_platform_name(self):
+        p = subprocess.Popen(GET_PLATFORM_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        position_tuple = port_position_tuple_list[platform_dict[out.rstrip('\n')]]
+        return position_tuple
+
+    def __init__(self):
+        port_position_tuple = self.get_port_position_tuple_by_platform_name()
+        self.PORT_START = port_position_tuple[0] + 1
+        self.QSFP_PORT_START = port_position_tuple[1] + 1
+        self.PORT_END = port_position_tuple[2] + 1
+        self.PORTS_IN_BLOCK = port_position_tuple[3]
+        self.EEPROM_OFFSET = port_position_tuple[4]
+        self.mlnx_sfpd_started = False
+
+        SfpUtilBase.__init__(self)
+
+    def get_presence(self, port_num):
+        presence = False
+
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return presence
+
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        ethtool_cmd = "ethtool -m {} 2>/dev/null".format(sfpname)
+        try:
+            proc = subprocess.Popen(ethtool_cmd, stdout=subprocess.PIPE, shell=True, universal_newlines=True, stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+            if result != '':
+                presence = True
+
+        except OSError as e:
+            return presence
+
+        return presence
+
+    def get_low_power_mode(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmget.py {}".format(port_num)
+
+        try:
+            output = subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            if 'LPM ON' in output:
+                return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to get LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def set_low_power_mode(self, port_num, lpmode):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        curr_lpmode = self.get_low_power_mode(port_num)
+        if curr_lpmode == lpmode:
+            return True
+
+        # Compose LPM command
+        lpm = 'on' if lpmode else 'off'
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmset.py {} {}".format(port_num, lpm)
+
+        # Set LPM
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return True
+
+    def reset(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfpreset.py {}".format(port_num)
+
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def get_transceiver_change_event(self, timeout=0):
+        phy_port_dict = {}
+        status = True
+
+        if self.db_sel is None:
+            from swsscommon import swsscommon
+            self.state_db = swsscommon.DBConnector("STATE_DB",
+                                                   REDIS_TIMEOUT_USECS,
+                                                   True)
+
+            # Subscribe to state table for SFP change notifications
+            self.db_sel = swsscommon.Select()
+            self.db_sel_tbl = swsscommon.NotificationConsumer(self.state_db, 'TRANSCEIVER_NOTIFY')
+            self.db_sel.addSelectable(self.db_sel_tbl)
+            self.db_sel_timeout = swsscommon.Select.TIMEOUT
+            self.db_sel_object = swsscommon.Select.OBJECT
+            self.sfpd_status_tbl = swsscommon.Table(self.state_db, 'MLNX_SFPD_TASK')
+
+        # Check the liveness of mlnx-sfpd, if it failed, return system_fail event
+        # If mlnx-sfpd not started, return system_not_ready event
+        keys = self.sfpd_status_tbl.getKeys()
+        if 'LIVENESS' not in keys:
+            if self.mlnx_sfpd_started:
+                log_err("mlnx-sfpd exited, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_FAIL
+                return False, phy_port_dict
+            else:
+                log_info("mlnx-sfpd not ready, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_NOT_READY
+                return False, phy_port_dict
+        else:
+            if not self.mlnx_sfpd_started:
+                self.mlnx_sfpd_started = True
+                log_info("mlnx-sfpd is running")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_READY
+                return False, phy_port_dict
+
+        if timeout:
+            (state, c) = self.db_sel.select(timeout)
+        else:
+            (state, c) = self.db_sel.select()
+
+        if state == self.db_sel_timeout:
+            status = True
+        elif state != self.db_sel_object:
+            status = False
+        else:
+            (key, op, fvp) = self.db_sel_tbl.pop()
+            phy_port_dict[key] = op
+
+        return status, phy_port_dict
+
+    def _read_eeprom_specific_bytes(self, sysfsfile_eeprom, offset, num_bytes):
+        print("_read_eeprom_specific_bytes should not be called since the sysfs it dependents on will no longer exist.")
+        print("_read_eeprom_specific_bytes_via_ethtool should be called instead")
+        raise Exception()
+
+    # Read out any bytes from any offset
+    def _read_eeprom_specific_bytes_via_ethtool(self, port_num, offset, num_bytes):
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        eeprom_raw = []
+        ethtool_cmd = "ethtool -m {} hex on offset {} length {}".format(sfpname, offset, num_bytes)
+        try:
+            output = subprocess.check_output(ethtool_cmd, shell=True, universal_newlines=True)
+            output_lines = output.splitlines()
+            first_line_raw = output_lines[0]
+            if "Offset" in first_line_raw:
+                for line in output_lines[2:]:
+                    line_split = line.split()
+                    eeprom_raw = eeprom_raw + line_split[1:]
+        except subprocess.CalledProcessError as e:
+            return None
+
+        return eeprom_raw
+
+    # Read eeprom
+    def _read_eeprom_devid(self, port_num, devid, offset, num_bytes=512):
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            pass
+        elif (self.DOM_EEPROM_ADDR == devid):
+            offset += 256
+
+        eeprom_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, num_bytes)
+
+        return eeprom_raw
+
+    # Read out SFP type, vendor name, PN, REV, SN from eeprom.
+    def get_transceiver_info_dict(self, port_num):
+        transceiver_info_dict = {}
+        compliance_code_dict = {}
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if port_num in self.osfp_ports:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_type_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            # Below part is added to avoid fail the xcvrd, shall be implemented later
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if port_num in self.qsfp_ports:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+                sfp_type = 'QSFP'
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+                sfp_type = 'SFP'
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_INTFACE_BULK_OFFSET), interface_info_bulk_width)
+            if sfp_interface_bulk_raw is not None:
+                sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(sfp_interface_bulk_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_oui_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_OUI_OFFSET), XCVR_VENDOR_OUI_WIDTH)
+            if sfp_vendor_oui_raw is not None:
+                sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(sfp_vendor_oui_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_date_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_DATE_OFFSET), XCVR_VENDOR_DATE_WIDTH)
+            if sfp_vendor_date_raw is not None:
+                sfp_vendor_date_data = sfpi_obj.parse_vendor_date(sfp_vendor_date_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            if sfp_type == 'QSFP':
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_dom_info_dict(self, port_num):
+        transceiver_dom_info_dict = {}
+
+        # Below part is added to avoid failing xcvrd
+        # Currently, the way in which dom data is read has been changed from
+        # using sysfs to using ethtool.
+        # The ethtool returns None for ports without dom support, resulting in
+        # None being returned. However, this fails xcvrd to add the
+        # TRANSCEIVER_DOM_SENSOR table entry of associated port to CONFIG_DB
+        # and then causes SNMP fail.
+        # To address this issue a default dict is initialized with all data set to
+        # 'N/A' and is returned is the above case.
+        # BTW, in the original implementation which sysfs is used to read dom data,
+        # even though non-None data is returned for ports without dom support,
+        # it does not contain valid data. This can result in wrong data in
+        # TRANSCEIVER_DOM_SENSOR table.
+        transceiver_dom_info_dict['temperature'] = 'N/A'
+        transceiver_dom_info_dict['voltage'] = 'N/A'
+        transceiver_dom_info_dict['rx1power'] = 'N/A'
+        transceiver_dom_info_dict['rx2power'] = 'N/A'
+        transceiver_dom_info_dict['rx3power'] = 'N/A'
+        transceiver_dom_info_dict['rx4power'] = 'N/A'
+        transceiver_dom_info_dict['tx1bias'] = 'N/A'
+        transceiver_dom_info_dict['tx2bias'] = 'N/A'
+        transceiver_dom_info_dict['tx3bias'] = 'N/A'
+        transceiver_dom_info_dict['tx4bias'] = 'N/A'
+        transceiver_dom_info_dict['tx1power'] = 'N/A'
+        transceiver_dom_info_dict['tx2power'] = 'N/A'
+        transceiver_dom_info_dict['tx3power'] = 'N/A'
+        transceiver_dom_info_dict['tx4power'] = 'N/A'
+
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            offset = 0
+            offset_xcvr = 128
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset_xcvr + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qspf_dom_capability_data = sfpi_obj.parse_qsfp_dom_capability(qsfp_dom_capability_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_temperature_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_TEMPE_OFFSET), QSFP_TEMPE_WIDTH)
+            if dom_temperature_raw is not None:
+                dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_voltage_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_VOLT_OFFSET), QSFP_VOLT_WIDTH)
+            if dom_voltage_raw is not None:
+                dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            qsfp_dom_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_DOM_REV_OFFSET), QSFP_DOM_REV_WIDTH)
+            if qsfp_dom_rev_raw is not None:
+                qsfp_dom_rev_data = sfpd_obj.parse_sfp_dom_rev(qsfp_dom_rev_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+
+            # The tx_power monitoring is only available on QSFP which compliant with SFF-8636
+            # and claimed that it support tx_power with one indicator bit.
+            dom_channel_monitor_data = {}
+            qsfp_dom_rev = qsfp_dom_rev_data['data']['dom_rev']['value']
+            qsfp_tx_power_support = qspf_dom_capability_data['data']['Tx_power_support']['value']
+            if (qsfp_dom_rev[0:8] != 'SFF-8636' or (qsfp_dom_rev[0:8] == 'SFF-8636' and qsfp_tx_power_support != 'on')):
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+            else:
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+
+                transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TX1Power']['value']
+                transceiver_dom_info_dict['tx2power'] = dom_channel_monitor_data['data']['TX2Power']['value']
+                transceiver_dom_info_dict['tx3power'] = dom_channel_monitor_data['data']['TX3Power']['value']
+                transceiver_dom_info_dict['tx4power'] = dom_channel_monitor_data['data']['TX4Power']['value']
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RX1Power']['value']
+            transceiver_dom_info_dict['rx2power'] = dom_channel_monitor_data['data']['RX2Power']['value']
+            transceiver_dom_info_dict['rx3power'] = dom_channel_monitor_data['data']['RX3Power']['value']
+            transceiver_dom_info_dict['rx4power'] = dom_channel_monitor_data['data']['RX4Power']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_info_dict
+
+            eeprom_domraw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, SFP_I2C_PAGE_SIZE)
+            if eeprom_domraw is None:
+                return transceiver_dom_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                print("no sff8472Dom")
+                return None
+
+            dom_temperature_raw = eeprom_domraw[SFP_TEMPE_OFFSET:SFP_TEMPE_OFFSET+SFP_TEMPE_WIDTH]
+            dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+
+            dom_voltage_raw = eeprom_domraw[SFP_VOLT_OFFSET:SFP_VOLT_OFFSET+SFP_VOLT_WIDTH]
+            dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+
+            dom_channel_monitor_raw = eeprom_domraw[SFP_CHANNL_MON_OFFSET:SFP_CHANNL_MON_OFFSET+SFP_CHANNL_MON_WIDTH]
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RXPower']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TXBias']['value']
+            transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TXPower']['value']
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_dom_threshold_info_dict(self, port_num):
+        transceiver_dom_threshold_info_dict = {}
+
+        dom_info_dict_keys = ['temphighalarm',    'temphighwarning',
+                              'templowalarm',     'templowwarning',
+                              'vcchighalarm',     'vcchighwarning',
+                              'vcclowalarm',      'vcclowwarning',
+                              'rxpowerhighalarm', 'rxpowerhighwarning',
+                              'rxpowerlowalarm',  'rxpowerlowwarning',
+                              'txpowerhighalarm', 'txpowerhighwarning',
+                              'txpowerlowalarm',  'txpowerlowwarning',
+                              'txbiashighalarm',  'txbiashighwarning',
+                              'txbiaslowalarm',   'txbiaslowwarning'
+                              ]
+        transceiver_dom_threshold_info_dict = dict.fromkeys(dom_info_dict_keys, 'N/A')
+
+        if port_num in self.qsfp_ports:
+            # current we don't support qsfp since threshold data is on page 3 and the way to read this page is under discussion.
+            return transceiver_dom_threshold_info_dict
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num,
+                                                                                    (offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                                    SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/thermalutil.py
deleted file mode 120000
index cef21ffa..00000000
--- a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/thermalutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/thermalutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/thermalutil.py
new file mode 100644
index 00000000..980ef8a9
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2010-r0/plugins/thermalutil.py
@@ -0,0 +1,456 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC Thermal Base API and
+# provides the thermal sensor status which are available in the platform
+#
+#############################################################################
+
+try:
+    from os.path import join
+    import syslog
+    import subprocess
+    from sonic_thermal.thermal_base import ThermalBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_info(msg):
+    syslog.openlog("thermalutil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+THERMAL_DEV_CATEGORY_CPU_CORE = "cpu_core"
+THERMAL_DEV_CATEGORY_CPU_PACK = "cpu_pack"
+THERMAL_DEV_CATEGORY_MODULE = "module"
+THERMAL_DEV_CATEGORY_PSU = "psu"
+THERMAL_DEV_CATEGORY_GEARBOX = "gearbox"
+THERMAL_DEV_CATEGORY_AMBIENT = "ambient"
+
+THERMAL_DEV_ASIC_AMBIENT = "asic_amb"
+THERMAL_DEV_FAN_AMBIENT = "fan_amb"
+THERMAL_DEV_PORT_AMBIENT = "port_amb"
+THERMAL_DEV_COMEX_AMBIENT = "comex_amb"
+THERMAL_DEV_BOARD_AMBIENT = "board_amb"
+
+THERMAL_API_GET_TEMPERATURE = "get_temperature"
+THERMAL_API_GET_HIGH_THRESHOLD = "get_high_threshold"
+THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD = "get_high_critical_threshold"
+
+THERMAL_API_INVALID_HIGH_THRESHOLD = 0.0
+
+HW_MGMT_THERMAL_ROOT = "/var/run/hw-management/thermal/"
+
+thermal_api_handler_cpu_core = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_core{}",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_core{}_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_core{}_crit"
+}
+thermal_api_handler_cpu_pack = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_pack",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_pack_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_pack_crit"
+}
+thermal_api_handler_module = {
+    THERMAL_API_GET_TEMPERATURE: "module{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: "module{}_temp_crit",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "module{}_temp_emergency"
+}
+thermal_api_handler_psu = {
+    THERMAL_API_GET_TEMPERATURE: "psu{}_temp",
+    THERMAL_API_GET_HIGH_THRESHOLD: "psu{}_temp_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_api_handler_gearbox = {
+    THERMAL_API_GET_TEMPERATURE: "gearbox{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: None,
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_ambient_apis = {
+    THERMAL_DEV_ASIC_AMBIENT: "asic",
+    THERMAL_DEV_PORT_AMBIENT: "port_amb",
+    THERMAL_DEV_FAN_AMBIENT: "fan_amb",
+    THERMAL_DEV_COMEX_AMBIENT: "comex_amb",
+    THERMAL_DEV_BOARD_AMBIENT: "board_amb"
+}
+thermal_ambient_name = {
+    THERMAL_DEV_ASIC_AMBIENT: "Ambient ASIC Temp",
+    THERMAL_DEV_PORT_AMBIENT: "Ambient Port Side Temp",
+    THERMAL_DEV_FAN_AMBIENT: "Ambient Fan Side Temp",
+    THERMAL_DEV_COMEX_AMBIENT: "Ambient COMEX Temp",
+    THERMAL_DEV_BOARD_AMBIENT: "Ambient Board Temp"
+}
+thermal_api_handlers = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: thermal_api_handler_cpu_core,
+    THERMAL_DEV_CATEGORY_CPU_PACK: thermal_api_handler_cpu_pack,
+    THERMAL_DEV_CATEGORY_MODULE: thermal_api_handler_module,
+    THERMAL_DEV_CATEGORY_PSU: thermal_api_handler_psu,
+    THERMAL_DEV_CATEGORY_GEARBOX: thermal_api_handler_gearbox
+}
+thermal_name = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: "CPU Core {} Temp",
+    THERMAL_DEV_CATEGORY_CPU_PACK: "CPU Pack Temp",
+    THERMAL_DEV_CATEGORY_MODULE: "xSFP module {} Temp",
+    THERMAL_DEV_CATEGORY_PSU: "PSU-{} Temp",
+    THERMAL_DEV_CATEGORY_GEARBOX: "Gearbox {} Temp"
+}
+
+thermal_device_categories_all = [
+    THERMAL_DEV_CATEGORY_CPU_CORE,
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_MODULE,
+    THERMAL_DEV_CATEGORY_PSU,
+    THERMAL_DEV_CATEGORY_AMBIENT,
+    THERMAL_DEV_CATEGORY_GEARBOX
+]
+
+thermal_device_categories_singleton = [
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_AMBIENT
+]
+thermal_api_names = [
+    THERMAL_API_GET_TEMPERATURE,
+    THERMAL_API_GET_HIGH_THRESHOLD
+]
+
+hwsku_dict_thermal = {'ACS-MSN2700': 0, 'LS-SN2700': 0, 'ACS-MSN2740': 3, 'ACS-MSN2100': 1, 'ACS-MSN2410': 2, 'ACS-MSN2010': 4,
+                      'ACS-MSN3700': 5, 'ACS-MSN3700C': 6, 'Mellanox-SN2700': 0, 'Mellanox-SN2700-D48C8': 0, 'ACS-MSN3800': 7, 'Mellanox-SN3800-D112C8': 7}
+thermal_profile_list = [
+    # 2700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 2100
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 16),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2410
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 56),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2740
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2010
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 22),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 3700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3700c
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3800
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 64),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (1, 32),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+]
+
+
+class Thermal(object):
+    def __init__(self, category, index, has_index):
+        """
+        index should be a string for category ambient and int for other categories
+        """
+        if category == THERMAL_DEV_CATEGORY_AMBIENT:
+            self.name = thermal_ambient_name[index]
+            self.index = index
+        elif has_index:
+            self.name = thermal_name[category].format(index)
+            self.index = index
+        else:
+            self.name = thermal_name[category]
+            self.index = 0
+
+        self.category = category
+        self.temperature = self._get_file_from_api(THERMAL_API_GET_TEMPERATURE)
+        self.high_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_THRESHOLD)
+        self.high_critical_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD)
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+
+        Returns:
+            string: The name of the device
+        """
+        return self.name
+
+    def _read_generic_file(self, filename, len):
+        """
+        Read a generic file, returns the contents of the file
+        """
+        result = None
+        try:
+            with open(filename, 'r') as fileobj:
+                result = fileobj.read()
+        except Exception as e:
+            log_info("Fail to read file {} due to {}".format(filename, repr(e)))
+        return result
+
+    def _get_file_from_api(self, api_name):
+        if self.category == THERMAL_DEV_CATEGORY_AMBIENT:
+            if api_name == THERMAL_API_GET_TEMPERATURE:
+                filename = thermal_ambient_apis[self.index]
+            else:
+                return None
+        else:
+            handler = thermal_api_handlers[self.category][api_name]
+            if self.category in thermal_device_categories_singleton:
+                filename = handler
+            else:
+                if handler:
+                    filename = handler.format(self.index)
+                else:
+                    return None
+        return join(HW_MGMT_THERMAL_ROOT, filename)
+
+    def get_temperature(self):
+        """
+        Retrieves current temperature reading from thermal
+
+        Returns:
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        value_str = self._read_generic_file(self.temperature, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_threshold(self):
+        """
+        Retrieves the high threshold temperature of thermal
+
+        Returns:
+            A float number, the high threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_critical_threshold(self):
+        """
+        Retrieves the high critical threshold temperature of thermal
+
+        Returns:
+            A float number, the high critical threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_critical_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_critical_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+
+class ThermalUtil(ThermalBase):
+    """Platform-specific Thermalutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    number_of_thermals = 0
+    thermal_list = []
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def __init__(self):
+        sku = self._get_sku_name()
+        # create thermal objects for all categories of sensors
+        tp_index = hwsku_dict_thermal[sku]
+        thermal_profile = thermal_profile_list[tp_index]
+        for category in thermal_device_categories_all:
+            if category == THERMAL_DEV_CATEGORY_AMBIENT:
+                count, ambient_list = thermal_profile[category]
+                for ambient in ambient_list:
+                    thermal = Thermal(category, ambient, True)
+                    self.thermal_list.append(thermal)
+            else:
+                start, count = 0, 0
+                if category in thermal_profile:
+                    start, count = thermal_profile[category]
+                    if count == 0:
+                        continue
+                if count == 1:
+                    thermal = Thermal(category, 0, False)
+                    self.thermal_list.append(thermal)
+                else:
+                    for index in range(count):
+                        thermal = Thermal(category, start + index, True)
+                        self.thermal_list.append(thermal)
+        self.number_of_thermals = len(self.thermal_list)
+
+    def get_num_thermals(self):
+        """
+        Retrieves the number of thermal sensors supported on the device
+
+        :return: An integer, the number of thermal sensors supported on the device
+        """
+        return self.number_of_thermals
+
+    def get_name(self, index):
+        """
+        Retrieves the human-readable name of a thermal sensor by 1-based index
+
+        Returns:
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: String,
+            A string representing the name of the thermal sensor. 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_name()
+
+    def get_temperature(self, index):
+        """
+        Retrieves current temperature reading from thermal sensor by 1-based index
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: Float,
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_temperature()
+
+    def get_high_threshold(self, index):
+        """
+        Retrieves the high threshold temperature of thermal by 1-based index
+        Actions should be taken if the temperature becomes higher than the threshold.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_threshold()
+
+    def get_high_critical_threshold(self, index):
+        """
+        Retrieves the high critical threshold temperature of thermal by 1-based index
+        Actions should be taken immediately if the temperature becomes higher than the high critical
+        threshold otherwise the device will be damaged.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high critical threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_critical_threshold()
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/fanutil.py
deleted file mode 120000
index 82ea06ef..00000000
--- a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/fanutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/fanutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/fanutil.py
new file mode 100644
index 00000000..ee6446e7
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/fanutil.py
@@ -0,0 +1,202 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from glob import glob
+    from sonic_fan.fan_base import FanBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("fanutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class FanUtil(FanBase):
+    """Platform-specific FanUtil class"""
+
+    PWM_MAX = 255
+    MAX_FAN_PER_DRAWER = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    sku_without_fan_direction = ['ACS-MSN2010', 'ACS-MSN2100', 'ACS-MSN2410',
+                                 'ACS-MSN2700', 'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+    sku_with_unpluggable_fan = ['ACS-MSN2010', 'ACS-MSN2100']
+
+    def __init__(self):
+        FanBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.fan_path = "/var/run/hw-management/"
+        if self.sku_name in self.sku_with_unpluggable_fan:
+            self.fan_status = None
+            self.unpluggable_fan = True
+        else:
+            self.fan_status = "thermal/fan{}_status"
+            self.unpluggable_fan = False
+        self.fan_get_speed = "thermal/fan{}_speed_get"
+        self.fan_set_speed = "thermal/fan{}_speed_set"
+        if self.sku_name in self.sku_without_fan_direction:
+            self.fan_direction = None
+        else:
+            self.fan_direction = "system/fan_dir"
+
+        self.fan_led_green = "led/led_fan*_green"
+        self.num_of_fan, self.num_of_drawer = self._extract_num_of_fans_and_fan_drawers()
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def _extract_num_of_fans_and_fan_drawers(self):
+        # So far we don't have files representing the number of fans and drawers
+        # The only way to retrieve the number is to count files.
+        # for number of fans, we get it via couting the speed files.
+        # for number of draws, we get it via couting the green led files.
+        list_of_fan_speed = glob(self.fan_path + self.fan_get_speed.format("*"))
+        num_of_fan = len(list_of_fan_speed)
+        list_of_fan_leds = glob(self.fan_path + self.fan_led_green)
+        num_of_drawer = len(list_of_fan_leds)
+
+        return num_of_fan, num_of_drawer
+
+    def _convert_fan_index_to_drawer_index(self, index):
+        return (index + self.MAX_FAN_PER_DRAWER - 1) / self.MAX_FAN_PER_DRAWER
+
+    def _read_file(self, file_pattern, index=0):
+        """
+        Reads the file of the fan
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the fan of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(os.path.join(self.fan_path, file_pattern.format(index)), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.fan_path + file_pattern.format(index)))
+            return return_value
+
+        return return_value
+
+    def get_num_fans(self):
+        """
+        Retrieves the number of FANs supported on the device
+
+        :return: An integer, the number of FANs supported on the device
+        """
+        return self.num_of_fan
+
+    def get_status(self, index):
+        """
+        Retrieves the operational status of FAN defined
+                by index 1-based <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean,
+            - True if FAN is running with some speed 
+            - False if FAN has stopped running
+        """
+        if not self.get_presence(index):
+            return False
+
+        return self.get_speed(index) != 0
+
+    def get_presence(self, index):
+        """
+        Retrieves the presence status of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: Boolean, True if FAN is plugged, False if not
+        """
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        if self.unpluggable_fan:
+            return True
+
+        draw_index = self._convert_fan_index_to_drawer_index(index)
+        presence = self._read_file(self.fan_status, draw_index)
+
+        return presence != 0
+
+    def get_direction(self, index):
+        """
+        Retrieves the airflow direction of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: string, denoting FAN airflow direction
+        Note:
+            What Mellanox calls forward: 
+            Air flows from fans side to QSFP side, for example: MSN2700-CS2F
+            which means intake in community
+            What Mellanox calls reverse:
+            Air flow from QSFP side to fans side, for example: MSN2700-CS2R
+            which means exhaust in community
+            According to hw-mgmt:
+                1 stands for forward, in other words intake
+                0 stands for reverse, in other words exhaust
+        """
+        if not self.fan_direction:
+            return self.FAN_DIRECTION_NOT_APPLICABLE
+
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        drawer_index = self._convert_fan_index_to_drawer_index(index)
+
+        fan_dir_bits = self._read_file(self.fan_direction)
+        fan_mask = 1 << drawer_index - 1
+        if fan_dir_bits & fan_mask:
+            return self.FAN_DIRECTION_INTAKE
+        else:
+            return self.FAN_DIRECTION_EXHAUST
+
+    def get_speed(self, index):
+        """
+        Retrieves the speed of a Front FAN in the tray in revolutions per minute defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query speed
+        :return: integer, denoting front FAN speed
+        """
+        speed = self._read_file(self.fan_get_speed, index)
+
+        return speed
+
+    def set_speed(self, val):
+        """
+        Sets the speed of all the FANs to a value denoted by the duty-cycle percentage val
+
+        :param val: An integer, <0-100> denoting FAN duty cycle percentage 
+        :return: Boolean, True if operation is successful, False if not
+        """
+        status = True
+        pwm = int(round(self.PWM_MAX*val/100.0))
+
+        try:
+            with open(os.path.join(self.fan_path, self.fan_set_speed.format(1)), 'w') as fan_pwm:
+                fan_pwm.write(str(pwm))
+        except (ValueError, IOError):
+            log_err("Read file {} failed".format(self.fan_path + self.fan_set_speed.format(1)))
+            status = False
+
+        return status
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfputil.py
deleted file mode 120000
index 45909b88..00000000
--- a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfputil.py
new file mode 100644
index 00000000..954ed23d
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/sfputil.py
@@ -0,0 +1,688 @@
+# sfputil.py
+#
+# Platform-specific SFP transceiver interface for SONiC
+#
+
+try:
+    import time
+    import subprocess
+    from sonic_sfp.sfputilbase import *
+    import syslog
+except ImportError as e:
+    raise ImportError("%s - required module not found" % str(e))
+
+# sfp supports dom
+XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT = 0x40
+
+# sfp module threshold offset and width
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+
+# I2C page size for sfp
+SFP_I2C_PAGE_SIZE = 256
+
+# parameters for DB connection
+REDIS_TIMEOUT_USECS = 0
+
+# parameters for SFP presence
+SFP_STATUS_INSERTED = '1'
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+GET_PLATFORM_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.platform"
+
+# Ethernet<n> <=> sfp<n+SFP_PORT_NAME_OFFSET>
+SFP_PORT_NAME_OFFSET = 0
+SFP_PORT_NAME_CONVENTION = "sfp{}"
+
+# magic code defnition for port number, qsfp port position of each platform
+# port_position_tuple = (PORT_START, QSFP_PORT_START, PORT_END, PORT_IN_BLOCK, EEPROM_OFFSET)
+platform_dict = {'x86_64-mlnx_msn2700-r0': 0, 'x86_64-mlnx_msn2740-r0': 0, 'x86_64-mlnx_msn2100-r0': 1, 'x86_64-mlnx_msn2410-r0': 2, 'x86_64-mlnx_msn2010-r0': 3,
+                 'x86_64-mlnx_msn3420-r0': 5, 'x86_64-mlnx_msn3700-r0': 0, 'x86_64-mlnx_msn3700c-r0': 0, 'x86_64-mlnx_msn3800-r0': 4, 'x86_64-mlnx_msn4600c': 4, 'x86_64-mlnx_msn4700-r0': 0}
+port_position_tuple_list = [(0, 0, 31, 32, 1), (0, 0, 15, 16, 1), (0, 48, 55, 56, 1),
+                            (0, 18, 21, 22, 1), (0, 0, 63, 64, 1), (0, 48, 59, 60, 1)]
+
+
+def log_info(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+def log_err(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class SfpUtil(SfpUtilBase):
+    """Platform-specific SfpUtil class"""
+    PORT_START = 0
+    QSFP_PORT_START = 0
+    PORT_END = 0
+    PORTS_IN_BLOCK = 0
+    EEPROM_OFFSET = 0
+
+    db_sel = None
+    db_sel_timeout = None
+    db_sel_object = None
+    db_sel_tbl = None
+    state_db = None
+    sfpd_status_tbl = None
+
+    @property
+    def port_start(self):
+        return self.PORT_START
+
+    @property
+    def port_end(self):
+        return self.PORT_END
+
+    @property
+    def qsfp_ports(self):
+        return list(range(self.QSFP_PORT_START, self.PORTS_IN_BLOCK + 1))
+
+    @property
+    def port_to_eeprom_mapping(self):
+        print("dependency on sysfs has been removed")
+        raise Exception()
+
+    def get_port_position_tuple_by_platform_name(self):
+        p = subprocess.Popen(GET_PLATFORM_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        position_tuple = port_position_tuple_list[platform_dict[out.rstrip('\n')]]
+        return position_tuple
+
+    def __init__(self):
+        port_position_tuple = self.get_port_position_tuple_by_platform_name()
+        self.PORT_START = port_position_tuple[0] + 1
+        self.QSFP_PORT_START = port_position_tuple[1] + 1
+        self.PORT_END = port_position_tuple[2] + 1
+        self.PORTS_IN_BLOCK = port_position_tuple[3]
+        self.EEPROM_OFFSET = port_position_tuple[4]
+        self.mlnx_sfpd_started = False
+
+        SfpUtilBase.__init__(self)
+
+    def get_presence(self, port_num):
+        presence = False
+
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return presence
+
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        ethtool_cmd = "ethtool -m {} 2>/dev/null".format(sfpname)
+        try:
+            proc = subprocess.Popen(ethtool_cmd, stdout=subprocess.PIPE, shell=True, universal_newlines=True, stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+            if result != '':
+                presence = True
+
+        except OSError as e:
+            return presence
+
+        return presence
+
+    def get_low_power_mode(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmget.py {}".format(port_num)
+
+        try:
+            output = subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            if 'LPM ON' in output:
+                return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to get LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def set_low_power_mode(self, port_num, lpmode):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        curr_lpmode = self.get_low_power_mode(port_num)
+        if curr_lpmode == lpmode:
+            return True
+
+        # Compose LPM command
+        lpm = 'on' if lpmode else 'off'
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmset.py {} {}".format(port_num, lpm)
+
+        # Set LPM
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return True
+
+    def reset(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfpreset.py {}".format(port_num)
+
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def get_transceiver_change_event(self, timeout=0):
+        phy_port_dict = {}
+        status = True
+
+        if self.db_sel is None:
+            from swsscommon import swsscommon
+            self.state_db = swsscommon.DBConnector("STATE_DB",
+                                                   REDIS_TIMEOUT_USECS,
+                                                   True)
+
+            # Subscribe to state table for SFP change notifications
+            self.db_sel = swsscommon.Select()
+            self.db_sel_tbl = swsscommon.NotificationConsumer(self.state_db, 'TRANSCEIVER_NOTIFY')
+            self.db_sel.addSelectable(self.db_sel_tbl)
+            self.db_sel_timeout = swsscommon.Select.TIMEOUT
+            self.db_sel_object = swsscommon.Select.OBJECT
+            self.sfpd_status_tbl = swsscommon.Table(self.state_db, 'MLNX_SFPD_TASK')
+
+        # Check the liveness of mlnx-sfpd, if it failed, return system_fail event
+        # If mlnx-sfpd not started, return system_not_ready event
+        keys = self.sfpd_status_tbl.getKeys()
+        if 'LIVENESS' not in keys:
+            if self.mlnx_sfpd_started:
+                log_err("mlnx-sfpd exited, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_FAIL
+                return False, phy_port_dict
+            else:
+                log_info("mlnx-sfpd not ready, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_NOT_READY
+                return False, phy_port_dict
+        else:
+            if not self.mlnx_sfpd_started:
+                self.mlnx_sfpd_started = True
+                log_info("mlnx-sfpd is running")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_READY
+                return False, phy_port_dict
+
+        if timeout:
+            (state, c) = self.db_sel.select(timeout)
+        else:
+            (state, c) = self.db_sel.select()
+
+        if state == self.db_sel_timeout:
+            status = True
+        elif state != self.db_sel_object:
+            status = False
+        else:
+            (key, op, fvp) = self.db_sel_tbl.pop()
+            phy_port_dict[key] = op
+
+        return status, phy_port_dict
+
+    def _read_eeprom_specific_bytes(self, sysfsfile_eeprom, offset, num_bytes):
+        print("_read_eeprom_specific_bytes should not be called since the sysfs it dependents on will no longer exist.")
+        print("_read_eeprom_specific_bytes_via_ethtool should be called instead")
+        raise Exception()
+
+    # Read out any bytes from any offset
+    def _read_eeprom_specific_bytes_via_ethtool(self, port_num, offset, num_bytes):
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        eeprom_raw = []
+        ethtool_cmd = "ethtool -m {} hex on offset {} length {}".format(sfpname, offset, num_bytes)
+        try:
+            output = subprocess.check_output(ethtool_cmd, shell=True, universal_newlines=True)
+            output_lines = output.splitlines()
+            first_line_raw = output_lines[0]
+            if "Offset" in first_line_raw:
+                for line in output_lines[2:]:
+                    line_split = line.split()
+                    eeprom_raw = eeprom_raw + line_split[1:]
+        except subprocess.CalledProcessError as e:
+            return None
+
+        return eeprom_raw
+
+    # Read eeprom
+    def _read_eeprom_devid(self, port_num, devid, offset, num_bytes=512):
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            pass
+        elif (self.DOM_EEPROM_ADDR == devid):
+            offset += 256
+
+        eeprom_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, num_bytes)
+
+        return eeprom_raw
+
+    # Read out SFP type, vendor name, PN, REV, SN from eeprom.
+    def get_transceiver_info_dict(self, port_num):
+        transceiver_info_dict = {}
+        compliance_code_dict = {}
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if port_num in self.osfp_ports:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_type_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            # Below part is added to avoid fail the xcvrd, shall be implemented later
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if port_num in self.qsfp_ports:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+                sfp_type = 'QSFP'
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+                sfp_type = 'SFP'
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_INTFACE_BULK_OFFSET), interface_info_bulk_width)
+            if sfp_interface_bulk_raw is not None:
+                sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(sfp_interface_bulk_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_oui_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_OUI_OFFSET), XCVR_VENDOR_OUI_WIDTH)
+            if sfp_vendor_oui_raw is not None:
+                sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(sfp_vendor_oui_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_date_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_DATE_OFFSET), XCVR_VENDOR_DATE_WIDTH)
+            if sfp_vendor_date_raw is not None:
+                sfp_vendor_date_data = sfpi_obj.parse_vendor_date(sfp_vendor_date_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            if sfp_type == 'QSFP':
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_dom_info_dict(self, port_num):
+        transceiver_dom_info_dict = {}
+
+        # Below part is added to avoid failing xcvrd
+        # Currently, the way in which dom data is read has been changed from
+        # using sysfs to using ethtool.
+        # The ethtool returns None for ports without dom support, resulting in
+        # None being returned. However, this fails xcvrd to add the
+        # TRANSCEIVER_DOM_SENSOR table entry of associated port to CONFIG_DB
+        # and then causes SNMP fail.
+        # To address this issue a default dict is initialized with all data set to
+        # 'N/A' and is returned is the above case.
+        # BTW, in the original implementation which sysfs is used to read dom data,
+        # even though non-None data is returned for ports without dom support,
+        # it does not contain valid data. This can result in wrong data in
+        # TRANSCEIVER_DOM_SENSOR table.
+        transceiver_dom_info_dict['temperature'] = 'N/A'
+        transceiver_dom_info_dict['voltage'] = 'N/A'
+        transceiver_dom_info_dict['rx1power'] = 'N/A'
+        transceiver_dom_info_dict['rx2power'] = 'N/A'
+        transceiver_dom_info_dict['rx3power'] = 'N/A'
+        transceiver_dom_info_dict['rx4power'] = 'N/A'
+        transceiver_dom_info_dict['tx1bias'] = 'N/A'
+        transceiver_dom_info_dict['tx2bias'] = 'N/A'
+        transceiver_dom_info_dict['tx3bias'] = 'N/A'
+        transceiver_dom_info_dict['tx4bias'] = 'N/A'
+        transceiver_dom_info_dict['tx1power'] = 'N/A'
+        transceiver_dom_info_dict['tx2power'] = 'N/A'
+        transceiver_dom_info_dict['tx3power'] = 'N/A'
+        transceiver_dom_info_dict['tx4power'] = 'N/A'
+
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            offset = 0
+            offset_xcvr = 128
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset_xcvr + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qspf_dom_capability_data = sfpi_obj.parse_qsfp_dom_capability(qsfp_dom_capability_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_temperature_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_TEMPE_OFFSET), QSFP_TEMPE_WIDTH)
+            if dom_temperature_raw is not None:
+                dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_voltage_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_VOLT_OFFSET), QSFP_VOLT_WIDTH)
+            if dom_voltage_raw is not None:
+                dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            qsfp_dom_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_DOM_REV_OFFSET), QSFP_DOM_REV_WIDTH)
+            if qsfp_dom_rev_raw is not None:
+                qsfp_dom_rev_data = sfpd_obj.parse_sfp_dom_rev(qsfp_dom_rev_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+
+            # The tx_power monitoring is only available on QSFP which compliant with SFF-8636
+            # and claimed that it support tx_power with one indicator bit.
+            dom_channel_monitor_data = {}
+            qsfp_dom_rev = qsfp_dom_rev_data['data']['dom_rev']['value']
+            qsfp_tx_power_support = qspf_dom_capability_data['data']['Tx_power_support']['value']
+            if (qsfp_dom_rev[0:8] != 'SFF-8636' or (qsfp_dom_rev[0:8] == 'SFF-8636' and qsfp_tx_power_support != 'on')):
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+            else:
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+
+                transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TX1Power']['value']
+                transceiver_dom_info_dict['tx2power'] = dom_channel_monitor_data['data']['TX2Power']['value']
+                transceiver_dom_info_dict['tx3power'] = dom_channel_monitor_data['data']['TX3Power']['value']
+                transceiver_dom_info_dict['tx4power'] = dom_channel_monitor_data['data']['TX4Power']['value']
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RX1Power']['value']
+            transceiver_dom_info_dict['rx2power'] = dom_channel_monitor_data['data']['RX2Power']['value']
+            transceiver_dom_info_dict['rx3power'] = dom_channel_monitor_data['data']['RX3Power']['value']
+            transceiver_dom_info_dict['rx4power'] = dom_channel_monitor_data['data']['RX4Power']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_info_dict
+
+            eeprom_domraw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, SFP_I2C_PAGE_SIZE)
+            if eeprom_domraw is None:
+                return transceiver_dom_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                print("no sff8472Dom")
+                return None
+
+            dom_temperature_raw = eeprom_domraw[SFP_TEMPE_OFFSET:SFP_TEMPE_OFFSET+SFP_TEMPE_WIDTH]
+            dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+
+            dom_voltage_raw = eeprom_domraw[SFP_VOLT_OFFSET:SFP_VOLT_OFFSET+SFP_VOLT_WIDTH]
+            dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+
+            dom_channel_monitor_raw = eeprom_domraw[SFP_CHANNL_MON_OFFSET:SFP_CHANNL_MON_OFFSET+SFP_CHANNL_MON_WIDTH]
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RXPower']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TXBias']['value']
+            transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TXPower']['value']
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_dom_threshold_info_dict(self, port_num):
+        transceiver_dom_threshold_info_dict = {}
+
+        dom_info_dict_keys = ['temphighalarm',    'temphighwarning',
+                              'templowalarm',     'templowwarning',
+                              'vcchighalarm',     'vcchighwarning',
+                              'vcclowalarm',      'vcclowwarning',
+                              'rxpowerhighalarm', 'rxpowerhighwarning',
+                              'rxpowerlowalarm',  'rxpowerlowwarning',
+                              'txpowerhighalarm', 'txpowerhighwarning',
+                              'txpowerlowalarm',  'txpowerlowwarning',
+                              'txbiashighalarm',  'txbiashighwarning',
+                              'txbiaslowalarm',   'txbiaslowwarning'
+                              ]
+        transceiver_dom_threshold_info_dict = dict.fromkeys(dom_info_dict_keys, 'N/A')
+
+        if port_num in self.qsfp_ports:
+            # current we don't support qsfp since threshold data is on page 3 and the way to read this page is under discussion.
+            return transceiver_dom_threshold_info_dict
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num,
+                                                                                    (offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                                    SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/thermalutil.py
deleted file mode 120000
index cef21ffa..00000000
--- a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/thermalutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/thermalutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/thermalutil.py
new file mode 100644
index 00000000..980ef8a9
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2100-r0/plugins/thermalutil.py
@@ -0,0 +1,456 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC Thermal Base API and
+# provides the thermal sensor status which are available in the platform
+#
+#############################################################################
+
+try:
+    from os.path import join
+    import syslog
+    import subprocess
+    from sonic_thermal.thermal_base import ThermalBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_info(msg):
+    syslog.openlog("thermalutil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+THERMAL_DEV_CATEGORY_CPU_CORE = "cpu_core"
+THERMAL_DEV_CATEGORY_CPU_PACK = "cpu_pack"
+THERMAL_DEV_CATEGORY_MODULE = "module"
+THERMAL_DEV_CATEGORY_PSU = "psu"
+THERMAL_DEV_CATEGORY_GEARBOX = "gearbox"
+THERMAL_DEV_CATEGORY_AMBIENT = "ambient"
+
+THERMAL_DEV_ASIC_AMBIENT = "asic_amb"
+THERMAL_DEV_FAN_AMBIENT = "fan_amb"
+THERMAL_DEV_PORT_AMBIENT = "port_amb"
+THERMAL_DEV_COMEX_AMBIENT = "comex_amb"
+THERMAL_DEV_BOARD_AMBIENT = "board_amb"
+
+THERMAL_API_GET_TEMPERATURE = "get_temperature"
+THERMAL_API_GET_HIGH_THRESHOLD = "get_high_threshold"
+THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD = "get_high_critical_threshold"
+
+THERMAL_API_INVALID_HIGH_THRESHOLD = 0.0
+
+HW_MGMT_THERMAL_ROOT = "/var/run/hw-management/thermal/"
+
+thermal_api_handler_cpu_core = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_core{}",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_core{}_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_core{}_crit"
+}
+thermal_api_handler_cpu_pack = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_pack",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_pack_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_pack_crit"
+}
+thermal_api_handler_module = {
+    THERMAL_API_GET_TEMPERATURE: "module{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: "module{}_temp_crit",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "module{}_temp_emergency"
+}
+thermal_api_handler_psu = {
+    THERMAL_API_GET_TEMPERATURE: "psu{}_temp",
+    THERMAL_API_GET_HIGH_THRESHOLD: "psu{}_temp_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_api_handler_gearbox = {
+    THERMAL_API_GET_TEMPERATURE: "gearbox{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: None,
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_ambient_apis = {
+    THERMAL_DEV_ASIC_AMBIENT: "asic",
+    THERMAL_DEV_PORT_AMBIENT: "port_amb",
+    THERMAL_DEV_FAN_AMBIENT: "fan_amb",
+    THERMAL_DEV_COMEX_AMBIENT: "comex_amb",
+    THERMAL_DEV_BOARD_AMBIENT: "board_amb"
+}
+thermal_ambient_name = {
+    THERMAL_DEV_ASIC_AMBIENT: "Ambient ASIC Temp",
+    THERMAL_DEV_PORT_AMBIENT: "Ambient Port Side Temp",
+    THERMAL_DEV_FAN_AMBIENT: "Ambient Fan Side Temp",
+    THERMAL_DEV_COMEX_AMBIENT: "Ambient COMEX Temp",
+    THERMAL_DEV_BOARD_AMBIENT: "Ambient Board Temp"
+}
+thermal_api_handlers = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: thermal_api_handler_cpu_core,
+    THERMAL_DEV_CATEGORY_CPU_PACK: thermal_api_handler_cpu_pack,
+    THERMAL_DEV_CATEGORY_MODULE: thermal_api_handler_module,
+    THERMAL_DEV_CATEGORY_PSU: thermal_api_handler_psu,
+    THERMAL_DEV_CATEGORY_GEARBOX: thermal_api_handler_gearbox
+}
+thermal_name = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: "CPU Core {} Temp",
+    THERMAL_DEV_CATEGORY_CPU_PACK: "CPU Pack Temp",
+    THERMAL_DEV_CATEGORY_MODULE: "xSFP module {} Temp",
+    THERMAL_DEV_CATEGORY_PSU: "PSU-{} Temp",
+    THERMAL_DEV_CATEGORY_GEARBOX: "Gearbox {} Temp"
+}
+
+thermal_device_categories_all = [
+    THERMAL_DEV_CATEGORY_CPU_CORE,
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_MODULE,
+    THERMAL_DEV_CATEGORY_PSU,
+    THERMAL_DEV_CATEGORY_AMBIENT,
+    THERMAL_DEV_CATEGORY_GEARBOX
+]
+
+thermal_device_categories_singleton = [
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_AMBIENT
+]
+thermal_api_names = [
+    THERMAL_API_GET_TEMPERATURE,
+    THERMAL_API_GET_HIGH_THRESHOLD
+]
+
+hwsku_dict_thermal = {'ACS-MSN2700': 0, 'LS-SN2700': 0, 'ACS-MSN2740': 3, 'ACS-MSN2100': 1, 'ACS-MSN2410': 2, 'ACS-MSN2010': 4,
+                      'ACS-MSN3700': 5, 'ACS-MSN3700C': 6, 'Mellanox-SN2700': 0, 'Mellanox-SN2700-D48C8': 0, 'ACS-MSN3800': 7, 'Mellanox-SN3800-D112C8': 7}
+thermal_profile_list = [
+    # 2700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 2100
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 16),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2410
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 56),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2740
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2010
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 22),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 3700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3700c
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3800
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 64),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (1, 32),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+]
+
+
+class Thermal(object):
+    def __init__(self, category, index, has_index):
+        """
+        index should be a string for category ambient and int for other categories
+        """
+        if category == THERMAL_DEV_CATEGORY_AMBIENT:
+            self.name = thermal_ambient_name[index]
+            self.index = index
+        elif has_index:
+            self.name = thermal_name[category].format(index)
+            self.index = index
+        else:
+            self.name = thermal_name[category]
+            self.index = 0
+
+        self.category = category
+        self.temperature = self._get_file_from_api(THERMAL_API_GET_TEMPERATURE)
+        self.high_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_THRESHOLD)
+        self.high_critical_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD)
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+
+        Returns:
+            string: The name of the device
+        """
+        return self.name
+
+    def _read_generic_file(self, filename, len):
+        """
+        Read a generic file, returns the contents of the file
+        """
+        result = None
+        try:
+            with open(filename, 'r') as fileobj:
+                result = fileobj.read()
+        except Exception as e:
+            log_info("Fail to read file {} due to {}".format(filename, repr(e)))
+        return result
+
+    def _get_file_from_api(self, api_name):
+        if self.category == THERMAL_DEV_CATEGORY_AMBIENT:
+            if api_name == THERMAL_API_GET_TEMPERATURE:
+                filename = thermal_ambient_apis[self.index]
+            else:
+                return None
+        else:
+            handler = thermal_api_handlers[self.category][api_name]
+            if self.category in thermal_device_categories_singleton:
+                filename = handler
+            else:
+                if handler:
+                    filename = handler.format(self.index)
+                else:
+                    return None
+        return join(HW_MGMT_THERMAL_ROOT, filename)
+
+    def get_temperature(self):
+        """
+        Retrieves current temperature reading from thermal
+
+        Returns:
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        value_str = self._read_generic_file(self.temperature, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_threshold(self):
+        """
+        Retrieves the high threshold temperature of thermal
+
+        Returns:
+            A float number, the high threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_critical_threshold(self):
+        """
+        Retrieves the high critical threshold temperature of thermal
+
+        Returns:
+            A float number, the high critical threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_critical_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_critical_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+
+class ThermalUtil(ThermalBase):
+    """Platform-specific Thermalutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    number_of_thermals = 0
+    thermal_list = []
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def __init__(self):
+        sku = self._get_sku_name()
+        # create thermal objects for all categories of sensors
+        tp_index = hwsku_dict_thermal[sku]
+        thermal_profile = thermal_profile_list[tp_index]
+        for category in thermal_device_categories_all:
+            if category == THERMAL_DEV_CATEGORY_AMBIENT:
+                count, ambient_list = thermal_profile[category]
+                for ambient in ambient_list:
+                    thermal = Thermal(category, ambient, True)
+                    self.thermal_list.append(thermal)
+            else:
+                start, count = 0, 0
+                if category in thermal_profile:
+                    start, count = thermal_profile[category]
+                    if count == 0:
+                        continue
+                if count == 1:
+                    thermal = Thermal(category, 0, False)
+                    self.thermal_list.append(thermal)
+                else:
+                    for index in range(count):
+                        thermal = Thermal(category, start + index, True)
+                        self.thermal_list.append(thermal)
+        self.number_of_thermals = len(self.thermal_list)
+
+    def get_num_thermals(self):
+        """
+        Retrieves the number of thermal sensors supported on the device
+
+        :return: An integer, the number of thermal sensors supported on the device
+        """
+        return self.number_of_thermals
+
+    def get_name(self, index):
+        """
+        Retrieves the human-readable name of a thermal sensor by 1-based index
+
+        Returns:
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: String,
+            A string representing the name of the thermal sensor. 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_name()
+
+    def get_temperature(self, index):
+        """
+        Retrieves current temperature reading from thermal sensor by 1-based index
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: Float,
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_temperature()
+
+    def get_high_threshold(self, index):
+        """
+        Retrieves the high threshold temperature of thermal by 1-based index
+        Actions should be taken if the temperature becomes higher than the threshold.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_threshold()
+
+    def get_high_critical_threshold(self, index):
+        """
+        Retrieves the high critical threshold temperature of thermal by 1-based index
+        Actions should be taken immediately if the temperature becomes higher than the high critical
+        threshold otherwise the device will be damaged.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high critical threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_critical_threshold()
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/fanutil.py
deleted file mode 120000
index 82ea06ef..00000000
--- a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/fanutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/fanutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/fanutil.py
new file mode 100644
index 00000000..ee6446e7
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/fanutil.py
@@ -0,0 +1,202 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from glob import glob
+    from sonic_fan.fan_base import FanBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("fanutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class FanUtil(FanBase):
+    """Platform-specific FanUtil class"""
+
+    PWM_MAX = 255
+    MAX_FAN_PER_DRAWER = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    sku_without_fan_direction = ['ACS-MSN2010', 'ACS-MSN2100', 'ACS-MSN2410',
+                                 'ACS-MSN2700', 'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+    sku_with_unpluggable_fan = ['ACS-MSN2010', 'ACS-MSN2100']
+
+    def __init__(self):
+        FanBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.fan_path = "/var/run/hw-management/"
+        if self.sku_name in self.sku_with_unpluggable_fan:
+            self.fan_status = None
+            self.unpluggable_fan = True
+        else:
+            self.fan_status = "thermal/fan{}_status"
+            self.unpluggable_fan = False
+        self.fan_get_speed = "thermal/fan{}_speed_get"
+        self.fan_set_speed = "thermal/fan{}_speed_set"
+        if self.sku_name in self.sku_without_fan_direction:
+            self.fan_direction = None
+        else:
+            self.fan_direction = "system/fan_dir"
+
+        self.fan_led_green = "led/led_fan*_green"
+        self.num_of_fan, self.num_of_drawer = self._extract_num_of_fans_and_fan_drawers()
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def _extract_num_of_fans_and_fan_drawers(self):
+        # So far we don't have files representing the number of fans and drawers
+        # The only way to retrieve the number is to count files.
+        # for number of fans, we get it via couting the speed files.
+        # for number of draws, we get it via couting the green led files.
+        list_of_fan_speed = glob(self.fan_path + self.fan_get_speed.format("*"))
+        num_of_fan = len(list_of_fan_speed)
+        list_of_fan_leds = glob(self.fan_path + self.fan_led_green)
+        num_of_drawer = len(list_of_fan_leds)
+
+        return num_of_fan, num_of_drawer
+
+    def _convert_fan_index_to_drawer_index(self, index):
+        return (index + self.MAX_FAN_PER_DRAWER - 1) / self.MAX_FAN_PER_DRAWER
+
+    def _read_file(self, file_pattern, index=0):
+        """
+        Reads the file of the fan
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the fan of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(os.path.join(self.fan_path, file_pattern.format(index)), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.fan_path + file_pattern.format(index)))
+            return return_value
+
+        return return_value
+
+    def get_num_fans(self):
+        """
+        Retrieves the number of FANs supported on the device
+
+        :return: An integer, the number of FANs supported on the device
+        """
+        return self.num_of_fan
+
+    def get_status(self, index):
+        """
+        Retrieves the operational status of FAN defined
+                by index 1-based <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean,
+            - True if FAN is running with some speed 
+            - False if FAN has stopped running
+        """
+        if not self.get_presence(index):
+            return False
+
+        return self.get_speed(index) != 0
+
+    def get_presence(self, index):
+        """
+        Retrieves the presence status of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: Boolean, True if FAN is plugged, False if not
+        """
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        if self.unpluggable_fan:
+            return True
+
+        draw_index = self._convert_fan_index_to_drawer_index(index)
+        presence = self._read_file(self.fan_status, draw_index)
+
+        return presence != 0
+
+    def get_direction(self, index):
+        """
+        Retrieves the airflow direction of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: string, denoting FAN airflow direction
+        Note:
+            What Mellanox calls forward: 
+            Air flows from fans side to QSFP side, for example: MSN2700-CS2F
+            which means intake in community
+            What Mellanox calls reverse:
+            Air flow from QSFP side to fans side, for example: MSN2700-CS2R
+            which means exhaust in community
+            According to hw-mgmt:
+                1 stands for forward, in other words intake
+                0 stands for reverse, in other words exhaust
+        """
+        if not self.fan_direction:
+            return self.FAN_DIRECTION_NOT_APPLICABLE
+
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        drawer_index = self._convert_fan_index_to_drawer_index(index)
+
+        fan_dir_bits = self._read_file(self.fan_direction)
+        fan_mask = 1 << drawer_index - 1
+        if fan_dir_bits & fan_mask:
+            return self.FAN_DIRECTION_INTAKE
+        else:
+            return self.FAN_DIRECTION_EXHAUST
+
+    def get_speed(self, index):
+        """
+        Retrieves the speed of a Front FAN in the tray in revolutions per minute defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query speed
+        :return: integer, denoting front FAN speed
+        """
+        speed = self._read_file(self.fan_get_speed, index)
+
+        return speed
+
+    def set_speed(self, val):
+        """
+        Sets the speed of all the FANs to a value denoted by the duty-cycle percentage val
+
+        :param val: An integer, <0-100> denoting FAN duty cycle percentage 
+        :return: Boolean, True if operation is successful, False if not
+        """
+        status = True
+        pwm = int(round(self.PWM_MAX*val/100.0))
+
+        try:
+            with open(os.path.join(self.fan_path, self.fan_set_speed.format(1)), 'w') as fan_pwm:
+                fan_pwm.write(str(pwm))
+        except (ValueError, IOError):
+            log_err("Read file {} failed".format(self.fan_path + self.fan_set_speed.format(1)))
+            status = False
+
+        return status
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/psuutil.py
deleted file mode 120000
index 9f724238..00000000
--- a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/psuutil.py
new file mode 100644
index 00000000..6da5770c
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/psuutil.py
@@ -0,0 +1,184 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from sonic_psu.psu_base import PsuBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("psuutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class PsuUtil(PsuBase):
+    """Platform-specific PSUutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    # for spectrum1 switches with plugable PSUs, the output voltage file is psuX_volt
+    # for spectrum2 switches the output voltage file is psuX_volt_out2
+    sku_spectrum1_with_plugable_psu = ['ACS-MSN2410', 'ACS-MSN2700',
+                                       'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+
+    def __init__(self):
+        PsuBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.psu_path = "/var/run/hw-management/"
+        self.psu_presence = "thermal/psu{}_status"
+        self.psu_oper_status = "thermal/psu{}_pwr_status"
+        self.psu_current = "power/psu{}_curr"
+        self.psu_power = "power/psu{}_power"
+        if self.sku_name in self.sku_spectrum1_with_plugable_psu:
+            self.psu_voltage = "power/psu{}_volt"
+        else:
+            self.psu_voltage = "power/psu{}_volt_out2"
+        self.fan_speed = "thermal/psu{}_fan1_speed_get"
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def get_num_psus(self):
+        """
+        Retrieves the number of PSUs available on the device
+
+        :return: An integer, the number of PSUs available on the device
+        """
+        return self.MAX_NUM_PSU
+
+    def _read_file(self, file_pattern, index):
+        """
+        Reads the file of the PSU
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(self.psu_path + file_pattern.format(index), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.psu_path + file_pattern.format(index)))
+            return 0
+
+        return return_value
+
+    def get_psu_status(self, index):
+        """
+        Retrieves the oprational status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is operating properly, False if PSU is faulty
+        """
+        if index is None:
+            return False
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_oper_status, index)
+
+        return status == 1
+
+    def get_psu_presence(self, index):
+        """
+        Retrieves the presence status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is plugged, False if not
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_presence, index)
+
+        return status == 1
+
+    def get_output_voltage(self, index):
+        """
+        Retrieves the ouput volatage in milli volts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p volatge
+        :return: An integer, value of o/p voltage in mV if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        voltage = self._read_file(self.psu_voltage, index)
+
+        return voltage
+
+    def get_output_current(self, index):
+        """
+        Retrieves the output current in milli amperes of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p current
+        :return: An integer, value of o/p current in mA if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        current = self._read_file(self.psu_current, index)
+
+        return current
+
+    def get_output_power(self, index):
+        """
+        Retrieves the output power in micro watts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p power
+        :return: An integer, value of o/p power in micro Watts if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        power = self._read_file(self.psu_power, index)
+
+        return power
+
+    def get_fan_speed(self, index, fan_index):
+        """
+        Retrieves the speed of fan, in rpm, denoted by 1-based <fan_index> of a power 
+                supply unit (PSU) defined by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query fan speed
+        :param fan_index: An integer, 1-based index of the PSU-fan of which to query speed
+        :return: An integer, value of PSU-fan speed in rpm if PSU-fan is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if fan_index > self.MAX_PSU_FAN:
+            raise RuntimeError("fan_index ({}) shouldn't be greater than {}".format(fan_index, self.MAX_PSU_FAN))
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        fan_speed = self._read_file(self.fan_speed, index)
+
+        return fan_speed
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfputil.py
deleted file mode 120000
index 45909b88..00000000
--- a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfputil.py
new file mode 100644
index 00000000..954ed23d
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/sfputil.py
@@ -0,0 +1,688 @@
+# sfputil.py
+#
+# Platform-specific SFP transceiver interface for SONiC
+#
+
+try:
+    import time
+    import subprocess
+    from sonic_sfp.sfputilbase import *
+    import syslog
+except ImportError as e:
+    raise ImportError("%s - required module not found" % str(e))
+
+# sfp supports dom
+XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT = 0x40
+
+# sfp module threshold offset and width
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+
+# I2C page size for sfp
+SFP_I2C_PAGE_SIZE = 256
+
+# parameters for DB connection
+REDIS_TIMEOUT_USECS = 0
+
+# parameters for SFP presence
+SFP_STATUS_INSERTED = '1'
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+GET_PLATFORM_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.platform"
+
+# Ethernet<n> <=> sfp<n+SFP_PORT_NAME_OFFSET>
+SFP_PORT_NAME_OFFSET = 0
+SFP_PORT_NAME_CONVENTION = "sfp{}"
+
+# magic code defnition for port number, qsfp port position of each platform
+# port_position_tuple = (PORT_START, QSFP_PORT_START, PORT_END, PORT_IN_BLOCK, EEPROM_OFFSET)
+platform_dict = {'x86_64-mlnx_msn2700-r0': 0, 'x86_64-mlnx_msn2740-r0': 0, 'x86_64-mlnx_msn2100-r0': 1, 'x86_64-mlnx_msn2410-r0': 2, 'x86_64-mlnx_msn2010-r0': 3,
+                 'x86_64-mlnx_msn3420-r0': 5, 'x86_64-mlnx_msn3700-r0': 0, 'x86_64-mlnx_msn3700c-r0': 0, 'x86_64-mlnx_msn3800-r0': 4, 'x86_64-mlnx_msn4600c': 4, 'x86_64-mlnx_msn4700-r0': 0}
+port_position_tuple_list = [(0, 0, 31, 32, 1), (0, 0, 15, 16, 1), (0, 48, 55, 56, 1),
+                            (0, 18, 21, 22, 1), (0, 0, 63, 64, 1), (0, 48, 59, 60, 1)]
+
+
+def log_info(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+def log_err(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class SfpUtil(SfpUtilBase):
+    """Platform-specific SfpUtil class"""
+    PORT_START = 0
+    QSFP_PORT_START = 0
+    PORT_END = 0
+    PORTS_IN_BLOCK = 0
+    EEPROM_OFFSET = 0
+
+    db_sel = None
+    db_sel_timeout = None
+    db_sel_object = None
+    db_sel_tbl = None
+    state_db = None
+    sfpd_status_tbl = None
+
+    @property
+    def port_start(self):
+        return self.PORT_START
+
+    @property
+    def port_end(self):
+        return self.PORT_END
+
+    @property
+    def qsfp_ports(self):
+        return list(range(self.QSFP_PORT_START, self.PORTS_IN_BLOCK + 1))
+
+    @property
+    def port_to_eeprom_mapping(self):
+        print("dependency on sysfs has been removed")
+        raise Exception()
+
+    def get_port_position_tuple_by_platform_name(self):
+        p = subprocess.Popen(GET_PLATFORM_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        position_tuple = port_position_tuple_list[platform_dict[out.rstrip('\n')]]
+        return position_tuple
+
+    def __init__(self):
+        port_position_tuple = self.get_port_position_tuple_by_platform_name()
+        self.PORT_START = port_position_tuple[0] + 1
+        self.QSFP_PORT_START = port_position_tuple[1] + 1
+        self.PORT_END = port_position_tuple[2] + 1
+        self.PORTS_IN_BLOCK = port_position_tuple[3]
+        self.EEPROM_OFFSET = port_position_tuple[4]
+        self.mlnx_sfpd_started = False
+
+        SfpUtilBase.__init__(self)
+
+    def get_presence(self, port_num):
+        presence = False
+
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return presence
+
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        ethtool_cmd = "ethtool -m {} 2>/dev/null".format(sfpname)
+        try:
+            proc = subprocess.Popen(ethtool_cmd, stdout=subprocess.PIPE, shell=True, universal_newlines=True, stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+            if result != '':
+                presence = True
+
+        except OSError as e:
+            return presence
+
+        return presence
+
+    def get_low_power_mode(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmget.py {}".format(port_num)
+
+        try:
+            output = subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            if 'LPM ON' in output:
+                return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to get LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def set_low_power_mode(self, port_num, lpmode):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        curr_lpmode = self.get_low_power_mode(port_num)
+        if curr_lpmode == lpmode:
+            return True
+
+        # Compose LPM command
+        lpm = 'on' if lpmode else 'off'
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmset.py {} {}".format(port_num, lpm)
+
+        # Set LPM
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return True
+
+    def reset(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfpreset.py {}".format(port_num)
+
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def get_transceiver_change_event(self, timeout=0):
+        phy_port_dict = {}
+        status = True
+
+        if self.db_sel is None:
+            from swsscommon import swsscommon
+            self.state_db = swsscommon.DBConnector("STATE_DB",
+                                                   REDIS_TIMEOUT_USECS,
+                                                   True)
+
+            # Subscribe to state table for SFP change notifications
+            self.db_sel = swsscommon.Select()
+            self.db_sel_tbl = swsscommon.NotificationConsumer(self.state_db, 'TRANSCEIVER_NOTIFY')
+            self.db_sel.addSelectable(self.db_sel_tbl)
+            self.db_sel_timeout = swsscommon.Select.TIMEOUT
+            self.db_sel_object = swsscommon.Select.OBJECT
+            self.sfpd_status_tbl = swsscommon.Table(self.state_db, 'MLNX_SFPD_TASK')
+
+        # Check the liveness of mlnx-sfpd, if it failed, return system_fail event
+        # If mlnx-sfpd not started, return system_not_ready event
+        keys = self.sfpd_status_tbl.getKeys()
+        if 'LIVENESS' not in keys:
+            if self.mlnx_sfpd_started:
+                log_err("mlnx-sfpd exited, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_FAIL
+                return False, phy_port_dict
+            else:
+                log_info("mlnx-sfpd not ready, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_NOT_READY
+                return False, phy_port_dict
+        else:
+            if not self.mlnx_sfpd_started:
+                self.mlnx_sfpd_started = True
+                log_info("mlnx-sfpd is running")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_READY
+                return False, phy_port_dict
+
+        if timeout:
+            (state, c) = self.db_sel.select(timeout)
+        else:
+            (state, c) = self.db_sel.select()
+
+        if state == self.db_sel_timeout:
+            status = True
+        elif state != self.db_sel_object:
+            status = False
+        else:
+            (key, op, fvp) = self.db_sel_tbl.pop()
+            phy_port_dict[key] = op
+
+        return status, phy_port_dict
+
+    def _read_eeprom_specific_bytes(self, sysfsfile_eeprom, offset, num_bytes):
+        print("_read_eeprom_specific_bytes should not be called since the sysfs it dependents on will no longer exist.")
+        print("_read_eeprom_specific_bytes_via_ethtool should be called instead")
+        raise Exception()
+
+    # Read out any bytes from any offset
+    def _read_eeprom_specific_bytes_via_ethtool(self, port_num, offset, num_bytes):
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        eeprom_raw = []
+        ethtool_cmd = "ethtool -m {} hex on offset {} length {}".format(sfpname, offset, num_bytes)
+        try:
+            output = subprocess.check_output(ethtool_cmd, shell=True, universal_newlines=True)
+            output_lines = output.splitlines()
+            first_line_raw = output_lines[0]
+            if "Offset" in first_line_raw:
+                for line in output_lines[2:]:
+                    line_split = line.split()
+                    eeprom_raw = eeprom_raw + line_split[1:]
+        except subprocess.CalledProcessError as e:
+            return None
+
+        return eeprom_raw
+
+    # Read eeprom
+    def _read_eeprom_devid(self, port_num, devid, offset, num_bytes=512):
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            pass
+        elif (self.DOM_EEPROM_ADDR == devid):
+            offset += 256
+
+        eeprom_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, num_bytes)
+
+        return eeprom_raw
+
+    # Read out SFP type, vendor name, PN, REV, SN from eeprom.
+    def get_transceiver_info_dict(self, port_num):
+        transceiver_info_dict = {}
+        compliance_code_dict = {}
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if port_num in self.osfp_ports:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_type_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            # Below part is added to avoid fail the xcvrd, shall be implemented later
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if port_num in self.qsfp_ports:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+                sfp_type = 'QSFP'
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+                sfp_type = 'SFP'
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_INTFACE_BULK_OFFSET), interface_info_bulk_width)
+            if sfp_interface_bulk_raw is not None:
+                sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(sfp_interface_bulk_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_oui_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_OUI_OFFSET), XCVR_VENDOR_OUI_WIDTH)
+            if sfp_vendor_oui_raw is not None:
+                sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(sfp_vendor_oui_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_date_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_DATE_OFFSET), XCVR_VENDOR_DATE_WIDTH)
+            if sfp_vendor_date_raw is not None:
+                sfp_vendor_date_data = sfpi_obj.parse_vendor_date(sfp_vendor_date_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            if sfp_type == 'QSFP':
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_dom_info_dict(self, port_num):
+        transceiver_dom_info_dict = {}
+
+        # Below part is added to avoid failing xcvrd
+        # Currently, the way in which dom data is read has been changed from
+        # using sysfs to using ethtool.
+        # The ethtool returns None for ports without dom support, resulting in
+        # None being returned. However, this fails xcvrd to add the
+        # TRANSCEIVER_DOM_SENSOR table entry of associated port to CONFIG_DB
+        # and then causes SNMP fail.
+        # To address this issue a default dict is initialized with all data set to
+        # 'N/A' and is returned is the above case.
+        # BTW, in the original implementation which sysfs is used to read dom data,
+        # even though non-None data is returned for ports without dom support,
+        # it does not contain valid data. This can result in wrong data in
+        # TRANSCEIVER_DOM_SENSOR table.
+        transceiver_dom_info_dict['temperature'] = 'N/A'
+        transceiver_dom_info_dict['voltage'] = 'N/A'
+        transceiver_dom_info_dict['rx1power'] = 'N/A'
+        transceiver_dom_info_dict['rx2power'] = 'N/A'
+        transceiver_dom_info_dict['rx3power'] = 'N/A'
+        transceiver_dom_info_dict['rx4power'] = 'N/A'
+        transceiver_dom_info_dict['tx1bias'] = 'N/A'
+        transceiver_dom_info_dict['tx2bias'] = 'N/A'
+        transceiver_dom_info_dict['tx3bias'] = 'N/A'
+        transceiver_dom_info_dict['tx4bias'] = 'N/A'
+        transceiver_dom_info_dict['tx1power'] = 'N/A'
+        transceiver_dom_info_dict['tx2power'] = 'N/A'
+        transceiver_dom_info_dict['tx3power'] = 'N/A'
+        transceiver_dom_info_dict['tx4power'] = 'N/A'
+
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            offset = 0
+            offset_xcvr = 128
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset_xcvr + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qspf_dom_capability_data = sfpi_obj.parse_qsfp_dom_capability(qsfp_dom_capability_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_temperature_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_TEMPE_OFFSET), QSFP_TEMPE_WIDTH)
+            if dom_temperature_raw is not None:
+                dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_voltage_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_VOLT_OFFSET), QSFP_VOLT_WIDTH)
+            if dom_voltage_raw is not None:
+                dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            qsfp_dom_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_DOM_REV_OFFSET), QSFP_DOM_REV_WIDTH)
+            if qsfp_dom_rev_raw is not None:
+                qsfp_dom_rev_data = sfpd_obj.parse_sfp_dom_rev(qsfp_dom_rev_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+
+            # The tx_power monitoring is only available on QSFP which compliant with SFF-8636
+            # and claimed that it support tx_power with one indicator bit.
+            dom_channel_monitor_data = {}
+            qsfp_dom_rev = qsfp_dom_rev_data['data']['dom_rev']['value']
+            qsfp_tx_power_support = qspf_dom_capability_data['data']['Tx_power_support']['value']
+            if (qsfp_dom_rev[0:8] != 'SFF-8636' or (qsfp_dom_rev[0:8] == 'SFF-8636' and qsfp_tx_power_support != 'on')):
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+            else:
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+
+                transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TX1Power']['value']
+                transceiver_dom_info_dict['tx2power'] = dom_channel_monitor_data['data']['TX2Power']['value']
+                transceiver_dom_info_dict['tx3power'] = dom_channel_monitor_data['data']['TX3Power']['value']
+                transceiver_dom_info_dict['tx4power'] = dom_channel_monitor_data['data']['TX4Power']['value']
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RX1Power']['value']
+            transceiver_dom_info_dict['rx2power'] = dom_channel_monitor_data['data']['RX2Power']['value']
+            transceiver_dom_info_dict['rx3power'] = dom_channel_monitor_data['data']['RX3Power']['value']
+            transceiver_dom_info_dict['rx4power'] = dom_channel_monitor_data['data']['RX4Power']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_info_dict
+
+            eeprom_domraw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, SFP_I2C_PAGE_SIZE)
+            if eeprom_domraw is None:
+                return transceiver_dom_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                print("no sff8472Dom")
+                return None
+
+            dom_temperature_raw = eeprom_domraw[SFP_TEMPE_OFFSET:SFP_TEMPE_OFFSET+SFP_TEMPE_WIDTH]
+            dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+
+            dom_voltage_raw = eeprom_domraw[SFP_VOLT_OFFSET:SFP_VOLT_OFFSET+SFP_VOLT_WIDTH]
+            dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+
+            dom_channel_monitor_raw = eeprom_domraw[SFP_CHANNL_MON_OFFSET:SFP_CHANNL_MON_OFFSET+SFP_CHANNL_MON_WIDTH]
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RXPower']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TXBias']['value']
+            transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TXPower']['value']
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_dom_threshold_info_dict(self, port_num):
+        transceiver_dom_threshold_info_dict = {}
+
+        dom_info_dict_keys = ['temphighalarm',    'temphighwarning',
+                              'templowalarm',     'templowwarning',
+                              'vcchighalarm',     'vcchighwarning',
+                              'vcclowalarm',      'vcclowwarning',
+                              'rxpowerhighalarm', 'rxpowerhighwarning',
+                              'rxpowerlowalarm',  'rxpowerlowwarning',
+                              'txpowerhighalarm', 'txpowerhighwarning',
+                              'txpowerlowalarm',  'txpowerlowwarning',
+                              'txbiashighalarm',  'txbiashighwarning',
+                              'txbiaslowalarm',   'txbiaslowwarning'
+                              ]
+        transceiver_dom_threshold_info_dict = dict.fromkeys(dom_info_dict_keys, 'N/A')
+
+        if port_num in self.qsfp_ports:
+            # current we don't support qsfp since threshold data is on page 3 and the way to read this page is under discussion.
+            return transceiver_dom_threshold_info_dict
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num,
+                                                                                    (offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                                    SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/thermalutil.py
deleted file mode 120000
index cef21ffa..00000000
--- a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/thermalutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/thermalutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/thermalutil.py
new file mode 100644
index 00000000..980ef8a9
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2410-r0/plugins/thermalutil.py
@@ -0,0 +1,456 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC Thermal Base API and
+# provides the thermal sensor status which are available in the platform
+#
+#############################################################################
+
+try:
+    from os.path import join
+    import syslog
+    import subprocess
+    from sonic_thermal.thermal_base import ThermalBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_info(msg):
+    syslog.openlog("thermalutil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+THERMAL_DEV_CATEGORY_CPU_CORE = "cpu_core"
+THERMAL_DEV_CATEGORY_CPU_PACK = "cpu_pack"
+THERMAL_DEV_CATEGORY_MODULE = "module"
+THERMAL_DEV_CATEGORY_PSU = "psu"
+THERMAL_DEV_CATEGORY_GEARBOX = "gearbox"
+THERMAL_DEV_CATEGORY_AMBIENT = "ambient"
+
+THERMAL_DEV_ASIC_AMBIENT = "asic_amb"
+THERMAL_DEV_FAN_AMBIENT = "fan_amb"
+THERMAL_DEV_PORT_AMBIENT = "port_amb"
+THERMAL_DEV_COMEX_AMBIENT = "comex_amb"
+THERMAL_DEV_BOARD_AMBIENT = "board_amb"
+
+THERMAL_API_GET_TEMPERATURE = "get_temperature"
+THERMAL_API_GET_HIGH_THRESHOLD = "get_high_threshold"
+THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD = "get_high_critical_threshold"
+
+THERMAL_API_INVALID_HIGH_THRESHOLD = 0.0
+
+HW_MGMT_THERMAL_ROOT = "/var/run/hw-management/thermal/"
+
+thermal_api_handler_cpu_core = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_core{}",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_core{}_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_core{}_crit"
+}
+thermal_api_handler_cpu_pack = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_pack",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_pack_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_pack_crit"
+}
+thermal_api_handler_module = {
+    THERMAL_API_GET_TEMPERATURE: "module{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: "module{}_temp_crit",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "module{}_temp_emergency"
+}
+thermal_api_handler_psu = {
+    THERMAL_API_GET_TEMPERATURE: "psu{}_temp",
+    THERMAL_API_GET_HIGH_THRESHOLD: "psu{}_temp_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_api_handler_gearbox = {
+    THERMAL_API_GET_TEMPERATURE: "gearbox{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: None,
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_ambient_apis = {
+    THERMAL_DEV_ASIC_AMBIENT: "asic",
+    THERMAL_DEV_PORT_AMBIENT: "port_amb",
+    THERMAL_DEV_FAN_AMBIENT: "fan_amb",
+    THERMAL_DEV_COMEX_AMBIENT: "comex_amb",
+    THERMAL_DEV_BOARD_AMBIENT: "board_amb"
+}
+thermal_ambient_name = {
+    THERMAL_DEV_ASIC_AMBIENT: "Ambient ASIC Temp",
+    THERMAL_DEV_PORT_AMBIENT: "Ambient Port Side Temp",
+    THERMAL_DEV_FAN_AMBIENT: "Ambient Fan Side Temp",
+    THERMAL_DEV_COMEX_AMBIENT: "Ambient COMEX Temp",
+    THERMAL_DEV_BOARD_AMBIENT: "Ambient Board Temp"
+}
+thermal_api_handlers = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: thermal_api_handler_cpu_core,
+    THERMAL_DEV_CATEGORY_CPU_PACK: thermal_api_handler_cpu_pack,
+    THERMAL_DEV_CATEGORY_MODULE: thermal_api_handler_module,
+    THERMAL_DEV_CATEGORY_PSU: thermal_api_handler_psu,
+    THERMAL_DEV_CATEGORY_GEARBOX: thermal_api_handler_gearbox
+}
+thermal_name = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: "CPU Core {} Temp",
+    THERMAL_DEV_CATEGORY_CPU_PACK: "CPU Pack Temp",
+    THERMAL_DEV_CATEGORY_MODULE: "xSFP module {} Temp",
+    THERMAL_DEV_CATEGORY_PSU: "PSU-{} Temp",
+    THERMAL_DEV_CATEGORY_GEARBOX: "Gearbox {} Temp"
+}
+
+thermal_device_categories_all = [
+    THERMAL_DEV_CATEGORY_CPU_CORE,
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_MODULE,
+    THERMAL_DEV_CATEGORY_PSU,
+    THERMAL_DEV_CATEGORY_AMBIENT,
+    THERMAL_DEV_CATEGORY_GEARBOX
+]
+
+thermal_device_categories_singleton = [
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_AMBIENT
+]
+thermal_api_names = [
+    THERMAL_API_GET_TEMPERATURE,
+    THERMAL_API_GET_HIGH_THRESHOLD
+]
+
+hwsku_dict_thermal = {'ACS-MSN2700': 0, 'LS-SN2700': 0, 'ACS-MSN2740': 3, 'ACS-MSN2100': 1, 'ACS-MSN2410': 2, 'ACS-MSN2010': 4,
+                      'ACS-MSN3700': 5, 'ACS-MSN3700C': 6, 'Mellanox-SN2700': 0, 'Mellanox-SN2700-D48C8': 0, 'ACS-MSN3800': 7, 'Mellanox-SN3800-D112C8': 7}
+thermal_profile_list = [
+    # 2700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 2100
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 16),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2410
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 56),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2740
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2010
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 22),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 3700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3700c
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3800
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 64),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (1, 32),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+]
+
+
+class Thermal(object):
+    def __init__(self, category, index, has_index):
+        """
+        index should be a string for category ambient and int for other categories
+        """
+        if category == THERMAL_DEV_CATEGORY_AMBIENT:
+            self.name = thermal_ambient_name[index]
+            self.index = index
+        elif has_index:
+            self.name = thermal_name[category].format(index)
+            self.index = index
+        else:
+            self.name = thermal_name[category]
+            self.index = 0
+
+        self.category = category
+        self.temperature = self._get_file_from_api(THERMAL_API_GET_TEMPERATURE)
+        self.high_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_THRESHOLD)
+        self.high_critical_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD)
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+
+        Returns:
+            string: The name of the device
+        """
+        return self.name
+
+    def _read_generic_file(self, filename, len):
+        """
+        Read a generic file, returns the contents of the file
+        """
+        result = None
+        try:
+            with open(filename, 'r') as fileobj:
+                result = fileobj.read()
+        except Exception as e:
+            log_info("Fail to read file {} due to {}".format(filename, repr(e)))
+        return result
+
+    def _get_file_from_api(self, api_name):
+        if self.category == THERMAL_DEV_CATEGORY_AMBIENT:
+            if api_name == THERMAL_API_GET_TEMPERATURE:
+                filename = thermal_ambient_apis[self.index]
+            else:
+                return None
+        else:
+            handler = thermal_api_handlers[self.category][api_name]
+            if self.category in thermal_device_categories_singleton:
+                filename = handler
+            else:
+                if handler:
+                    filename = handler.format(self.index)
+                else:
+                    return None
+        return join(HW_MGMT_THERMAL_ROOT, filename)
+
+    def get_temperature(self):
+        """
+        Retrieves current temperature reading from thermal
+
+        Returns:
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        value_str = self._read_generic_file(self.temperature, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_threshold(self):
+        """
+        Retrieves the high threshold temperature of thermal
+
+        Returns:
+            A float number, the high threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_critical_threshold(self):
+        """
+        Retrieves the high critical threshold temperature of thermal
+
+        Returns:
+            A float number, the high critical threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_critical_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_critical_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+
+class ThermalUtil(ThermalBase):
+    """Platform-specific Thermalutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    number_of_thermals = 0
+    thermal_list = []
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def __init__(self):
+        sku = self._get_sku_name()
+        # create thermal objects for all categories of sensors
+        tp_index = hwsku_dict_thermal[sku]
+        thermal_profile = thermal_profile_list[tp_index]
+        for category in thermal_device_categories_all:
+            if category == THERMAL_DEV_CATEGORY_AMBIENT:
+                count, ambient_list = thermal_profile[category]
+                for ambient in ambient_list:
+                    thermal = Thermal(category, ambient, True)
+                    self.thermal_list.append(thermal)
+            else:
+                start, count = 0, 0
+                if category in thermal_profile:
+                    start, count = thermal_profile[category]
+                    if count == 0:
+                        continue
+                if count == 1:
+                    thermal = Thermal(category, 0, False)
+                    self.thermal_list.append(thermal)
+                else:
+                    for index in range(count):
+                        thermal = Thermal(category, start + index, True)
+                        self.thermal_list.append(thermal)
+        self.number_of_thermals = len(self.thermal_list)
+
+    def get_num_thermals(self):
+        """
+        Retrieves the number of thermal sensors supported on the device
+
+        :return: An integer, the number of thermal sensors supported on the device
+        """
+        return self.number_of_thermals
+
+    def get_name(self, index):
+        """
+        Retrieves the human-readable name of a thermal sensor by 1-based index
+
+        Returns:
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: String,
+            A string representing the name of the thermal sensor. 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_name()
+
+    def get_temperature(self, index):
+        """
+        Retrieves current temperature reading from thermal sensor by 1-based index
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: Float,
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_temperature()
+
+    def get_high_threshold(self, index):
+        """
+        Retrieves the high threshold temperature of thermal by 1-based index
+        Actions should be taken if the temperature becomes higher than the threshold.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_threshold()
+
+    def get_high_critical_threshold(self, index):
+        """
+        Retrieves the high critical threshold temperature of thermal by 1-based index
+        Actions should be taken immediately if the temperature becomes higher than the high critical
+        threshold otherwise the device will be damaged.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high critical threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_critical_threshold()
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/fanutil.py
deleted file mode 120000
index 82ea06ef..00000000
--- a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/fanutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/fanutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/fanutil.py
new file mode 100644
index 00000000..ee6446e7
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/fanutil.py
@@ -0,0 +1,202 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from glob import glob
+    from sonic_fan.fan_base import FanBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("fanutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class FanUtil(FanBase):
+    """Platform-specific FanUtil class"""
+
+    PWM_MAX = 255
+    MAX_FAN_PER_DRAWER = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    sku_without_fan_direction = ['ACS-MSN2010', 'ACS-MSN2100', 'ACS-MSN2410',
+                                 'ACS-MSN2700', 'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+    sku_with_unpluggable_fan = ['ACS-MSN2010', 'ACS-MSN2100']
+
+    def __init__(self):
+        FanBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.fan_path = "/var/run/hw-management/"
+        if self.sku_name in self.sku_with_unpluggable_fan:
+            self.fan_status = None
+            self.unpluggable_fan = True
+        else:
+            self.fan_status = "thermal/fan{}_status"
+            self.unpluggable_fan = False
+        self.fan_get_speed = "thermal/fan{}_speed_get"
+        self.fan_set_speed = "thermal/fan{}_speed_set"
+        if self.sku_name in self.sku_without_fan_direction:
+            self.fan_direction = None
+        else:
+            self.fan_direction = "system/fan_dir"
+
+        self.fan_led_green = "led/led_fan*_green"
+        self.num_of_fan, self.num_of_drawer = self._extract_num_of_fans_and_fan_drawers()
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def _extract_num_of_fans_and_fan_drawers(self):
+        # So far we don't have files representing the number of fans and drawers
+        # The only way to retrieve the number is to count files.
+        # for number of fans, we get it via couting the speed files.
+        # for number of draws, we get it via couting the green led files.
+        list_of_fan_speed = glob(self.fan_path + self.fan_get_speed.format("*"))
+        num_of_fan = len(list_of_fan_speed)
+        list_of_fan_leds = glob(self.fan_path + self.fan_led_green)
+        num_of_drawer = len(list_of_fan_leds)
+
+        return num_of_fan, num_of_drawer
+
+    def _convert_fan_index_to_drawer_index(self, index):
+        return (index + self.MAX_FAN_PER_DRAWER - 1) / self.MAX_FAN_PER_DRAWER
+
+    def _read_file(self, file_pattern, index=0):
+        """
+        Reads the file of the fan
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the fan of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(os.path.join(self.fan_path, file_pattern.format(index)), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.fan_path + file_pattern.format(index)))
+            return return_value
+
+        return return_value
+
+    def get_num_fans(self):
+        """
+        Retrieves the number of FANs supported on the device
+
+        :return: An integer, the number of FANs supported on the device
+        """
+        return self.num_of_fan
+
+    def get_status(self, index):
+        """
+        Retrieves the operational status of FAN defined
+                by index 1-based <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean,
+            - True if FAN is running with some speed 
+            - False if FAN has stopped running
+        """
+        if not self.get_presence(index):
+            return False
+
+        return self.get_speed(index) != 0
+
+    def get_presence(self, index):
+        """
+        Retrieves the presence status of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: Boolean, True if FAN is plugged, False if not
+        """
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        if self.unpluggable_fan:
+            return True
+
+        draw_index = self._convert_fan_index_to_drawer_index(index)
+        presence = self._read_file(self.fan_status, draw_index)
+
+        return presence != 0
+
+    def get_direction(self, index):
+        """
+        Retrieves the airflow direction of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: string, denoting FAN airflow direction
+        Note:
+            What Mellanox calls forward: 
+            Air flows from fans side to QSFP side, for example: MSN2700-CS2F
+            which means intake in community
+            What Mellanox calls reverse:
+            Air flow from QSFP side to fans side, for example: MSN2700-CS2R
+            which means exhaust in community
+            According to hw-mgmt:
+                1 stands for forward, in other words intake
+                0 stands for reverse, in other words exhaust
+        """
+        if not self.fan_direction:
+            return self.FAN_DIRECTION_NOT_APPLICABLE
+
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        drawer_index = self._convert_fan_index_to_drawer_index(index)
+
+        fan_dir_bits = self._read_file(self.fan_direction)
+        fan_mask = 1 << drawer_index - 1
+        if fan_dir_bits & fan_mask:
+            return self.FAN_DIRECTION_INTAKE
+        else:
+            return self.FAN_DIRECTION_EXHAUST
+
+    def get_speed(self, index):
+        """
+        Retrieves the speed of a Front FAN in the tray in revolutions per minute defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query speed
+        :return: integer, denoting front FAN speed
+        """
+        speed = self._read_file(self.fan_get_speed, index)
+
+        return speed
+
+    def set_speed(self, val):
+        """
+        Sets the speed of all the FANs to a value denoted by the duty-cycle percentage val
+
+        :param val: An integer, <0-100> denoting FAN duty cycle percentage 
+        :return: Boolean, True if operation is successful, False if not
+        """
+        status = True
+        pwm = int(round(self.PWM_MAX*val/100.0))
+
+        try:
+            with open(os.path.join(self.fan_path, self.fan_set_speed.format(1)), 'w') as fan_pwm:
+                fan_pwm.write(str(pwm))
+        except (ValueError, IOError):
+            log_err("Read file {} failed".format(self.fan_path + self.fan_set_speed.format(1)))
+            status = False
+
+        return status
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/psuutil.py
deleted file mode 120000
index 9f724238..00000000
--- a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/psuutil.py
new file mode 100644
index 00000000..6da5770c
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/psuutil.py
@@ -0,0 +1,184 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from sonic_psu.psu_base import PsuBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("psuutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class PsuUtil(PsuBase):
+    """Platform-specific PSUutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    # for spectrum1 switches with plugable PSUs, the output voltage file is psuX_volt
+    # for spectrum2 switches the output voltage file is psuX_volt_out2
+    sku_spectrum1_with_plugable_psu = ['ACS-MSN2410', 'ACS-MSN2700',
+                                       'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+
+    def __init__(self):
+        PsuBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.psu_path = "/var/run/hw-management/"
+        self.psu_presence = "thermal/psu{}_status"
+        self.psu_oper_status = "thermal/psu{}_pwr_status"
+        self.psu_current = "power/psu{}_curr"
+        self.psu_power = "power/psu{}_power"
+        if self.sku_name in self.sku_spectrum1_with_plugable_psu:
+            self.psu_voltage = "power/psu{}_volt"
+        else:
+            self.psu_voltage = "power/psu{}_volt_out2"
+        self.fan_speed = "thermal/psu{}_fan1_speed_get"
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def get_num_psus(self):
+        """
+        Retrieves the number of PSUs available on the device
+
+        :return: An integer, the number of PSUs available on the device
+        """
+        return self.MAX_NUM_PSU
+
+    def _read_file(self, file_pattern, index):
+        """
+        Reads the file of the PSU
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(self.psu_path + file_pattern.format(index), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.psu_path + file_pattern.format(index)))
+            return 0
+
+        return return_value
+
+    def get_psu_status(self, index):
+        """
+        Retrieves the oprational status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is operating properly, False if PSU is faulty
+        """
+        if index is None:
+            return False
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_oper_status, index)
+
+        return status == 1
+
+    def get_psu_presence(self, index):
+        """
+        Retrieves the presence status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is plugged, False if not
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_presence, index)
+
+        return status == 1
+
+    def get_output_voltage(self, index):
+        """
+        Retrieves the ouput volatage in milli volts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p volatge
+        :return: An integer, value of o/p voltage in mV if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        voltage = self._read_file(self.psu_voltage, index)
+
+        return voltage
+
+    def get_output_current(self, index):
+        """
+        Retrieves the output current in milli amperes of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p current
+        :return: An integer, value of o/p current in mA if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        current = self._read_file(self.psu_current, index)
+
+        return current
+
+    def get_output_power(self, index):
+        """
+        Retrieves the output power in micro watts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p power
+        :return: An integer, value of o/p power in micro Watts if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        power = self._read_file(self.psu_power, index)
+
+        return power
+
+    def get_fan_speed(self, index, fan_index):
+        """
+        Retrieves the speed of fan, in rpm, denoted by 1-based <fan_index> of a power 
+                supply unit (PSU) defined by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query fan speed
+        :param fan_index: An integer, 1-based index of the PSU-fan of which to query speed
+        :return: An integer, value of PSU-fan speed in rpm if PSU-fan is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if fan_index > self.MAX_PSU_FAN:
+            raise RuntimeError("fan_index ({}) shouldn't be greater than {}".format(fan_index, self.MAX_PSU_FAN))
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        fan_speed = self._read_file(self.fan_speed, index)
+
+        return fan_speed
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfputil.py
deleted file mode 120000
index 45909b88..00000000
--- a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfputil.py
new file mode 100644
index 00000000..954ed23d
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/sfputil.py
@@ -0,0 +1,688 @@
+# sfputil.py
+#
+# Platform-specific SFP transceiver interface for SONiC
+#
+
+try:
+    import time
+    import subprocess
+    from sonic_sfp.sfputilbase import *
+    import syslog
+except ImportError as e:
+    raise ImportError("%s - required module not found" % str(e))
+
+# sfp supports dom
+XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT = 0x40
+
+# sfp module threshold offset and width
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+
+# I2C page size for sfp
+SFP_I2C_PAGE_SIZE = 256
+
+# parameters for DB connection
+REDIS_TIMEOUT_USECS = 0
+
+# parameters for SFP presence
+SFP_STATUS_INSERTED = '1'
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+GET_PLATFORM_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.platform"
+
+# Ethernet<n> <=> sfp<n+SFP_PORT_NAME_OFFSET>
+SFP_PORT_NAME_OFFSET = 0
+SFP_PORT_NAME_CONVENTION = "sfp{}"
+
+# magic code defnition for port number, qsfp port position of each platform
+# port_position_tuple = (PORT_START, QSFP_PORT_START, PORT_END, PORT_IN_BLOCK, EEPROM_OFFSET)
+platform_dict = {'x86_64-mlnx_msn2700-r0': 0, 'x86_64-mlnx_msn2740-r0': 0, 'x86_64-mlnx_msn2100-r0': 1, 'x86_64-mlnx_msn2410-r0': 2, 'x86_64-mlnx_msn2010-r0': 3,
+                 'x86_64-mlnx_msn3420-r0': 5, 'x86_64-mlnx_msn3700-r0': 0, 'x86_64-mlnx_msn3700c-r0': 0, 'x86_64-mlnx_msn3800-r0': 4, 'x86_64-mlnx_msn4600c': 4, 'x86_64-mlnx_msn4700-r0': 0}
+port_position_tuple_list = [(0, 0, 31, 32, 1), (0, 0, 15, 16, 1), (0, 48, 55, 56, 1),
+                            (0, 18, 21, 22, 1), (0, 0, 63, 64, 1), (0, 48, 59, 60, 1)]
+
+
+def log_info(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+def log_err(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class SfpUtil(SfpUtilBase):
+    """Platform-specific SfpUtil class"""
+    PORT_START = 0
+    QSFP_PORT_START = 0
+    PORT_END = 0
+    PORTS_IN_BLOCK = 0
+    EEPROM_OFFSET = 0
+
+    db_sel = None
+    db_sel_timeout = None
+    db_sel_object = None
+    db_sel_tbl = None
+    state_db = None
+    sfpd_status_tbl = None
+
+    @property
+    def port_start(self):
+        return self.PORT_START
+
+    @property
+    def port_end(self):
+        return self.PORT_END
+
+    @property
+    def qsfp_ports(self):
+        return list(range(self.QSFP_PORT_START, self.PORTS_IN_BLOCK + 1))
+
+    @property
+    def port_to_eeprom_mapping(self):
+        print("dependency on sysfs has been removed")
+        raise Exception()
+
+    def get_port_position_tuple_by_platform_name(self):
+        p = subprocess.Popen(GET_PLATFORM_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        position_tuple = port_position_tuple_list[platform_dict[out.rstrip('\n')]]
+        return position_tuple
+
+    def __init__(self):
+        port_position_tuple = self.get_port_position_tuple_by_platform_name()
+        self.PORT_START = port_position_tuple[0] + 1
+        self.QSFP_PORT_START = port_position_tuple[1] + 1
+        self.PORT_END = port_position_tuple[2] + 1
+        self.PORTS_IN_BLOCK = port_position_tuple[3]
+        self.EEPROM_OFFSET = port_position_tuple[4]
+        self.mlnx_sfpd_started = False
+
+        SfpUtilBase.__init__(self)
+
+    def get_presence(self, port_num):
+        presence = False
+
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return presence
+
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        ethtool_cmd = "ethtool -m {} 2>/dev/null".format(sfpname)
+        try:
+            proc = subprocess.Popen(ethtool_cmd, stdout=subprocess.PIPE, shell=True, universal_newlines=True, stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+            if result != '':
+                presence = True
+
+        except OSError as e:
+            return presence
+
+        return presence
+
+    def get_low_power_mode(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmget.py {}".format(port_num)
+
+        try:
+            output = subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            if 'LPM ON' in output:
+                return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to get LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def set_low_power_mode(self, port_num, lpmode):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        curr_lpmode = self.get_low_power_mode(port_num)
+        if curr_lpmode == lpmode:
+            return True
+
+        # Compose LPM command
+        lpm = 'on' if lpmode else 'off'
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmset.py {} {}".format(port_num, lpm)
+
+        # Set LPM
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return True
+
+    def reset(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfpreset.py {}".format(port_num)
+
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def get_transceiver_change_event(self, timeout=0):
+        phy_port_dict = {}
+        status = True
+
+        if self.db_sel is None:
+            from swsscommon import swsscommon
+            self.state_db = swsscommon.DBConnector("STATE_DB",
+                                                   REDIS_TIMEOUT_USECS,
+                                                   True)
+
+            # Subscribe to state table for SFP change notifications
+            self.db_sel = swsscommon.Select()
+            self.db_sel_tbl = swsscommon.NotificationConsumer(self.state_db, 'TRANSCEIVER_NOTIFY')
+            self.db_sel.addSelectable(self.db_sel_tbl)
+            self.db_sel_timeout = swsscommon.Select.TIMEOUT
+            self.db_sel_object = swsscommon.Select.OBJECT
+            self.sfpd_status_tbl = swsscommon.Table(self.state_db, 'MLNX_SFPD_TASK')
+
+        # Check the liveness of mlnx-sfpd, if it failed, return system_fail event
+        # If mlnx-sfpd not started, return system_not_ready event
+        keys = self.sfpd_status_tbl.getKeys()
+        if 'LIVENESS' not in keys:
+            if self.mlnx_sfpd_started:
+                log_err("mlnx-sfpd exited, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_FAIL
+                return False, phy_port_dict
+            else:
+                log_info("mlnx-sfpd not ready, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_NOT_READY
+                return False, phy_port_dict
+        else:
+            if not self.mlnx_sfpd_started:
+                self.mlnx_sfpd_started = True
+                log_info("mlnx-sfpd is running")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_READY
+                return False, phy_port_dict
+
+        if timeout:
+            (state, c) = self.db_sel.select(timeout)
+        else:
+            (state, c) = self.db_sel.select()
+
+        if state == self.db_sel_timeout:
+            status = True
+        elif state != self.db_sel_object:
+            status = False
+        else:
+            (key, op, fvp) = self.db_sel_tbl.pop()
+            phy_port_dict[key] = op
+
+        return status, phy_port_dict
+
+    def _read_eeprom_specific_bytes(self, sysfsfile_eeprom, offset, num_bytes):
+        print("_read_eeprom_specific_bytes should not be called since the sysfs it dependents on will no longer exist.")
+        print("_read_eeprom_specific_bytes_via_ethtool should be called instead")
+        raise Exception()
+
+    # Read out any bytes from any offset
+    def _read_eeprom_specific_bytes_via_ethtool(self, port_num, offset, num_bytes):
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        eeprom_raw = []
+        ethtool_cmd = "ethtool -m {} hex on offset {} length {}".format(sfpname, offset, num_bytes)
+        try:
+            output = subprocess.check_output(ethtool_cmd, shell=True, universal_newlines=True)
+            output_lines = output.splitlines()
+            first_line_raw = output_lines[0]
+            if "Offset" in first_line_raw:
+                for line in output_lines[2:]:
+                    line_split = line.split()
+                    eeprom_raw = eeprom_raw + line_split[1:]
+        except subprocess.CalledProcessError as e:
+            return None
+
+        return eeprom_raw
+
+    # Read eeprom
+    def _read_eeprom_devid(self, port_num, devid, offset, num_bytes=512):
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            pass
+        elif (self.DOM_EEPROM_ADDR == devid):
+            offset += 256
+
+        eeprom_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, num_bytes)
+
+        return eeprom_raw
+
+    # Read out SFP type, vendor name, PN, REV, SN from eeprom.
+    def get_transceiver_info_dict(self, port_num):
+        transceiver_info_dict = {}
+        compliance_code_dict = {}
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if port_num in self.osfp_ports:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_type_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            # Below part is added to avoid fail the xcvrd, shall be implemented later
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if port_num in self.qsfp_ports:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+                sfp_type = 'QSFP'
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+                sfp_type = 'SFP'
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_INTFACE_BULK_OFFSET), interface_info_bulk_width)
+            if sfp_interface_bulk_raw is not None:
+                sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(sfp_interface_bulk_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_oui_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_OUI_OFFSET), XCVR_VENDOR_OUI_WIDTH)
+            if sfp_vendor_oui_raw is not None:
+                sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(sfp_vendor_oui_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_date_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_DATE_OFFSET), XCVR_VENDOR_DATE_WIDTH)
+            if sfp_vendor_date_raw is not None:
+                sfp_vendor_date_data = sfpi_obj.parse_vendor_date(sfp_vendor_date_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            if sfp_type == 'QSFP':
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_dom_info_dict(self, port_num):
+        transceiver_dom_info_dict = {}
+
+        # Below part is added to avoid failing xcvrd
+        # Currently, the way in which dom data is read has been changed from
+        # using sysfs to using ethtool.
+        # The ethtool returns None for ports without dom support, resulting in
+        # None being returned. However, this fails xcvrd to add the
+        # TRANSCEIVER_DOM_SENSOR table entry of associated port to CONFIG_DB
+        # and then causes SNMP fail.
+        # To address this issue a default dict is initialized with all data set to
+        # 'N/A' and is returned is the above case.
+        # BTW, in the original implementation which sysfs is used to read dom data,
+        # even though non-None data is returned for ports without dom support,
+        # it does not contain valid data. This can result in wrong data in
+        # TRANSCEIVER_DOM_SENSOR table.
+        transceiver_dom_info_dict['temperature'] = 'N/A'
+        transceiver_dom_info_dict['voltage'] = 'N/A'
+        transceiver_dom_info_dict['rx1power'] = 'N/A'
+        transceiver_dom_info_dict['rx2power'] = 'N/A'
+        transceiver_dom_info_dict['rx3power'] = 'N/A'
+        transceiver_dom_info_dict['rx4power'] = 'N/A'
+        transceiver_dom_info_dict['tx1bias'] = 'N/A'
+        transceiver_dom_info_dict['tx2bias'] = 'N/A'
+        transceiver_dom_info_dict['tx3bias'] = 'N/A'
+        transceiver_dom_info_dict['tx4bias'] = 'N/A'
+        transceiver_dom_info_dict['tx1power'] = 'N/A'
+        transceiver_dom_info_dict['tx2power'] = 'N/A'
+        transceiver_dom_info_dict['tx3power'] = 'N/A'
+        transceiver_dom_info_dict['tx4power'] = 'N/A'
+
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            offset = 0
+            offset_xcvr = 128
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset_xcvr + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qspf_dom_capability_data = sfpi_obj.parse_qsfp_dom_capability(qsfp_dom_capability_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_temperature_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_TEMPE_OFFSET), QSFP_TEMPE_WIDTH)
+            if dom_temperature_raw is not None:
+                dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_voltage_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_VOLT_OFFSET), QSFP_VOLT_WIDTH)
+            if dom_voltage_raw is not None:
+                dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            qsfp_dom_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_DOM_REV_OFFSET), QSFP_DOM_REV_WIDTH)
+            if qsfp_dom_rev_raw is not None:
+                qsfp_dom_rev_data = sfpd_obj.parse_sfp_dom_rev(qsfp_dom_rev_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+
+            # The tx_power monitoring is only available on QSFP which compliant with SFF-8636
+            # and claimed that it support tx_power with one indicator bit.
+            dom_channel_monitor_data = {}
+            qsfp_dom_rev = qsfp_dom_rev_data['data']['dom_rev']['value']
+            qsfp_tx_power_support = qspf_dom_capability_data['data']['Tx_power_support']['value']
+            if (qsfp_dom_rev[0:8] != 'SFF-8636' or (qsfp_dom_rev[0:8] == 'SFF-8636' and qsfp_tx_power_support != 'on')):
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+            else:
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+
+                transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TX1Power']['value']
+                transceiver_dom_info_dict['tx2power'] = dom_channel_monitor_data['data']['TX2Power']['value']
+                transceiver_dom_info_dict['tx3power'] = dom_channel_monitor_data['data']['TX3Power']['value']
+                transceiver_dom_info_dict['tx4power'] = dom_channel_monitor_data['data']['TX4Power']['value']
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RX1Power']['value']
+            transceiver_dom_info_dict['rx2power'] = dom_channel_monitor_data['data']['RX2Power']['value']
+            transceiver_dom_info_dict['rx3power'] = dom_channel_monitor_data['data']['RX3Power']['value']
+            transceiver_dom_info_dict['rx4power'] = dom_channel_monitor_data['data']['RX4Power']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_info_dict
+
+            eeprom_domraw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, SFP_I2C_PAGE_SIZE)
+            if eeprom_domraw is None:
+                return transceiver_dom_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                print("no sff8472Dom")
+                return None
+
+            dom_temperature_raw = eeprom_domraw[SFP_TEMPE_OFFSET:SFP_TEMPE_OFFSET+SFP_TEMPE_WIDTH]
+            dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+
+            dom_voltage_raw = eeprom_domraw[SFP_VOLT_OFFSET:SFP_VOLT_OFFSET+SFP_VOLT_WIDTH]
+            dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+
+            dom_channel_monitor_raw = eeprom_domraw[SFP_CHANNL_MON_OFFSET:SFP_CHANNL_MON_OFFSET+SFP_CHANNL_MON_WIDTH]
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RXPower']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TXBias']['value']
+            transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TXPower']['value']
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_dom_threshold_info_dict(self, port_num):
+        transceiver_dom_threshold_info_dict = {}
+
+        dom_info_dict_keys = ['temphighalarm',    'temphighwarning',
+                              'templowalarm',     'templowwarning',
+                              'vcchighalarm',     'vcchighwarning',
+                              'vcclowalarm',      'vcclowwarning',
+                              'rxpowerhighalarm', 'rxpowerhighwarning',
+                              'rxpowerlowalarm',  'rxpowerlowwarning',
+                              'txpowerhighalarm', 'txpowerhighwarning',
+                              'txpowerlowalarm',  'txpowerlowwarning',
+                              'txbiashighalarm',  'txbiashighwarning',
+                              'txbiaslowalarm',   'txbiaslowwarning'
+                              ]
+        transceiver_dom_threshold_info_dict = dict.fromkeys(dom_info_dict_keys, 'N/A')
+
+        if port_num in self.qsfp_ports:
+            # current we don't support qsfp since threshold data is on page 3 and the way to read this page is under discussion.
+            return transceiver_dom_threshold_info_dict
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num,
+                                                                                    (offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                                    SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/thermalutil.py
deleted file mode 120000
index cef21ffa..00000000
--- a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/thermalutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/thermalutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/thermalutil.py
new file mode 100644
index 00000000..980ef8a9
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn2740-r0/plugins/thermalutil.py
@@ -0,0 +1,456 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC Thermal Base API and
+# provides the thermal sensor status which are available in the platform
+#
+#############################################################################
+
+try:
+    from os.path import join
+    import syslog
+    import subprocess
+    from sonic_thermal.thermal_base import ThermalBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_info(msg):
+    syslog.openlog("thermalutil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+THERMAL_DEV_CATEGORY_CPU_CORE = "cpu_core"
+THERMAL_DEV_CATEGORY_CPU_PACK = "cpu_pack"
+THERMAL_DEV_CATEGORY_MODULE = "module"
+THERMAL_DEV_CATEGORY_PSU = "psu"
+THERMAL_DEV_CATEGORY_GEARBOX = "gearbox"
+THERMAL_DEV_CATEGORY_AMBIENT = "ambient"
+
+THERMAL_DEV_ASIC_AMBIENT = "asic_amb"
+THERMAL_DEV_FAN_AMBIENT = "fan_amb"
+THERMAL_DEV_PORT_AMBIENT = "port_amb"
+THERMAL_DEV_COMEX_AMBIENT = "comex_amb"
+THERMAL_DEV_BOARD_AMBIENT = "board_amb"
+
+THERMAL_API_GET_TEMPERATURE = "get_temperature"
+THERMAL_API_GET_HIGH_THRESHOLD = "get_high_threshold"
+THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD = "get_high_critical_threshold"
+
+THERMAL_API_INVALID_HIGH_THRESHOLD = 0.0
+
+HW_MGMT_THERMAL_ROOT = "/var/run/hw-management/thermal/"
+
+thermal_api_handler_cpu_core = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_core{}",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_core{}_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_core{}_crit"
+}
+thermal_api_handler_cpu_pack = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_pack",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_pack_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_pack_crit"
+}
+thermal_api_handler_module = {
+    THERMAL_API_GET_TEMPERATURE: "module{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: "module{}_temp_crit",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "module{}_temp_emergency"
+}
+thermal_api_handler_psu = {
+    THERMAL_API_GET_TEMPERATURE: "psu{}_temp",
+    THERMAL_API_GET_HIGH_THRESHOLD: "psu{}_temp_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_api_handler_gearbox = {
+    THERMAL_API_GET_TEMPERATURE: "gearbox{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: None,
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_ambient_apis = {
+    THERMAL_DEV_ASIC_AMBIENT: "asic",
+    THERMAL_DEV_PORT_AMBIENT: "port_amb",
+    THERMAL_DEV_FAN_AMBIENT: "fan_amb",
+    THERMAL_DEV_COMEX_AMBIENT: "comex_amb",
+    THERMAL_DEV_BOARD_AMBIENT: "board_amb"
+}
+thermal_ambient_name = {
+    THERMAL_DEV_ASIC_AMBIENT: "Ambient ASIC Temp",
+    THERMAL_DEV_PORT_AMBIENT: "Ambient Port Side Temp",
+    THERMAL_DEV_FAN_AMBIENT: "Ambient Fan Side Temp",
+    THERMAL_DEV_COMEX_AMBIENT: "Ambient COMEX Temp",
+    THERMAL_DEV_BOARD_AMBIENT: "Ambient Board Temp"
+}
+thermal_api_handlers = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: thermal_api_handler_cpu_core,
+    THERMAL_DEV_CATEGORY_CPU_PACK: thermal_api_handler_cpu_pack,
+    THERMAL_DEV_CATEGORY_MODULE: thermal_api_handler_module,
+    THERMAL_DEV_CATEGORY_PSU: thermal_api_handler_psu,
+    THERMAL_DEV_CATEGORY_GEARBOX: thermal_api_handler_gearbox
+}
+thermal_name = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: "CPU Core {} Temp",
+    THERMAL_DEV_CATEGORY_CPU_PACK: "CPU Pack Temp",
+    THERMAL_DEV_CATEGORY_MODULE: "xSFP module {} Temp",
+    THERMAL_DEV_CATEGORY_PSU: "PSU-{} Temp",
+    THERMAL_DEV_CATEGORY_GEARBOX: "Gearbox {} Temp"
+}
+
+thermal_device_categories_all = [
+    THERMAL_DEV_CATEGORY_CPU_CORE,
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_MODULE,
+    THERMAL_DEV_CATEGORY_PSU,
+    THERMAL_DEV_CATEGORY_AMBIENT,
+    THERMAL_DEV_CATEGORY_GEARBOX
+]
+
+thermal_device_categories_singleton = [
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_AMBIENT
+]
+thermal_api_names = [
+    THERMAL_API_GET_TEMPERATURE,
+    THERMAL_API_GET_HIGH_THRESHOLD
+]
+
+hwsku_dict_thermal = {'ACS-MSN2700': 0, 'LS-SN2700': 0, 'ACS-MSN2740': 3, 'ACS-MSN2100': 1, 'ACS-MSN2410': 2, 'ACS-MSN2010': 4,
+                      'ACS-MSN3700': 5, 'ACS-MSN3700C': 6, 'Mellanox-SN2700': 0, 'Mellanox-SN2700-D48C8': 0, 'ACS-MSN3800': 7, 'Mellanox-SN3800-D112C8': 7}
+thermal_profile_list = [
+    # 2700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 2100
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 16),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2410
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 56),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2740
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2010
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 22),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 3700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3700c
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3800
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 64),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (1, 32),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+]
+
+
+class Thermal(object):
+    def __init__(self, category, index, has_index):
+        """
+        index should be a string for category ambient and int for other categories
+        """
+        if category == THERMAL_DEV_CATEGORY_AMBIENT:
+            self.name = thermal_ambient_name[index]
+            self.index = index
+        elif has_index:
+            self.name = thermal_name[category].format(index)
+            self.index = index
+        else:
+            self.name = thermal_name[category]
+            self.index = 0
+
+        self.category = category
+        self.temperature = self._get_file_from_api(THERMAL_API_GET_TEMPERATURE)
+        self.high_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_THRESHOLD)
+        self.high_critical_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD)
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+
+        Returns:
+            string: The name of the device
+        """
+        return self.name
+
+    def _read_generic_file(self, filename, len):
+        """
+        Read a generic file, returns the contents of the file
+        """
+        result = None
+        try:
+            with open(filename, 'r') as fileobj:
+                result = fileobj.read()
+        except Exception as e:
+            log_info("Fail to read file {} due to {}".format(filename, repr(e)))
+        return result
+
+    def _get_file_from_api(self, api_name):
+        if self.category == THERMAL_DEV_CATEGORY_AMBIENT:
+            if api_name == THERMAL_API_GET_TEMPERATURE:
+                filename = thermal_ambient_apis[self.index]
+            else:
+                return None
+        else:
+            handler = thermal_api_handlers[self.category][api_name]
+            if self.category in thermal_device_categories_singleton:
+                filename = handler
+            else:
+                if handler:
+                    filename = handler.format(self.index)
+                else:
+                    return None
+        return join(HW_MGMT_THERMAL_ROOT, filename)
+
+    def get_temperature(self):
+        """
+        Retrieves current temperature reading from thermal
+
+        Returns:
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        value_str = self._read_generic_file(self.temperature, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_threshold(self):
+        """
+        Retrieves the high threshold temperature of thermal
+
+        Returns:
+            A float number, the high threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_critical_threshold(self):
+        """
+        Retrieves the high critical threshold temperature of thermal
+
+        Returns:
+            A float number, the high critical threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_critical_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_critical_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+
+class ThermalUtil(ThermalBase):
+    """Platform-specific Thermalutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    number_of_thermals = 0
+    thermal_list = []
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def __init__(self):
+        sku = self._get_sku_name()
+        # create thermal objects for all categories of sensors
+        tp_index = hwsku_dict_thermal[sku]
+        thermal_profile = thermal_profile_list[tp_index]
+        for category in thermal_device_categories_all:
+            if category == THERMAL_DEV_CATEGORY_AMBIENT:
+                count, ambient_list = thermal_profile[category]
+                for ambient in ambient_list:
+                    thermal = Thermal(category, ambient, True)
+                    self.thermal_list.append(thermal)
+            else:
+                start, count = 0, 0
+                if category in thermal_profile:
+                    start, count = thermal_profile[category]
+                    if count == 0:
+                        continue
+                if count == 1:
+                    thermal = Thermal(category, 0, False)
+                    self.thermal_list.append(thermal)
+                else:
+                    for index in range(count):
+                        thermal = Thermal(category, start + index, True)
+                        self.thermal_list.append(thermal)
+        self.number_of_thermals = len(self.thermal_list)
+
+    def get_num_thermals(self):
+        """
+        Retrieves the number of thermal sensors supported on the device
+
+        :return: An integer, the number of thermal sensors supported on the device
+        """
+        return self.number_of_thermals
+
+    def get_name(self, index):
+        """
+        Retrieves the human-readable name of a thermal sensor by 1-based index
+
+        Returns:
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: String,
+            A string representing the name of the thermal sensor. 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_name()
+
+    def get_temperature(self, index):
+        """
+        Retrieves current temperature reading from thermal sensor by 1-based index
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: Float,
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_temperature()
+
+    def get_high_threshold(self, index):
+        """
+        Retrieves the high threshold temperature of thermal by 1-based index
+        Actions should be taken if the temperature becomes higher than the threshold.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_threshold()
+
+    def get_high_critical_threshold(self, index):
+        """
+        Retrieves the high critical threshold temperature of thermal by 1-based index
+        Actions should be taken immediately if the temperature becomes higher than the high critical
+        threshold otherwise the device will be damaged.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high critical threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_critical_threshold()
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/psuutil.py
deleted file mode 120000
index 9f724238..00000000
--- a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/psuutil.py
new file mode 100644
index 00000000..6da5770c
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/psuutil.py
@@ -0,0 +1,184 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from sonic_psu.psu_base import PsuBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("psuutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class PsuUtil(PsuBase):
+    """Platform-specific PSUutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    # for spectrum1 switches with plugable PSUs, the output voltage file is psuX_volt
+    # for spectrum2 switches the output voltage file is psuX_volt_out2
+    sku_spectrum1_with_plugable_psu = ['ACS-MSN2410', 'ACS-MSN2700',
+                                       'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+
+    def __init__(self):
+        PsuBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.psu_path = "/var/run/hw-management/"
+        self.psu_presence = "thermal/psu{}_status"
+        self.psu_oper_status = "thermal/psu{}_pwr_status"
+        self.psu_current = "power/psu{}_curr"
+        self.psu_power = "power/psu{}_power"
+        if self.sku_name in self.sku_spectrum1_with_plugable_psu:
+            self.psu_voltage = "power/psu{}_volt"
+        else:
+            self.psu_voltage = "power/psu{}_volt_out2"
+        self.fan_speed = "thermal/psu{}_fan1_speed_get"
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def get_num_psus(self):
+        """
+        Retrieves the number of PSUs available on the device
+
+        :return: An integer, the number of PSUs available on the device
+        """
+        return self.MAX_NUM_PSU
+
+    def _read_file(self, file_pattern, index):
+        """
+        Reads the file of the PSU
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(self.psu_path + file_pattern.format(index), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.psu_path + file_pattern.format(index)))
+            return 0
+
+        return return_value
+
+    def get_psu_status(self, index):
+        """
+        Retrieves the oprational status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is operating properly, False if PSU is faulty
+        """
+        if index is None:
+            return False
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_oper_status, index)
+
+        return status == 1
+
+    def get_psu_presence(self, index):
+        """
+        Retrieves the presence status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is plugged, False if not
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_presence, index)
+
+        return status == 1
+
+    def get_output_voltage(self, index):
+        """
+        Retrieves the ouput volatage in milli volts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p volatge
+        :return: An integer, value of o/p voltage in mV if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        voltage = self._read_file(self.psu_voltage, index)
+
+        return voltage
+
+    def get_output_current(self, index):
+        """
+        Retrieves the output current in milli amperes of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p current
+        :return: An integer, value of o/p current in mA if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        current = self._read_file(self.psu_current, index)
+
+        return current
+
+    def get_output_power(self, index):
+        """
+        Retrieves the output power in micro watts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p power
+        :return: An integer, value of o/p power in micro Watts if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        power = self._read_file(self.psu_power, index)
+
+        return power
+
+    def get_fan_speed(self, index, fan_index):
+        """
+        Retrieves the speed of fan, in rpm, denoted by 1-based <fan_index> of a power 
+                supply unit (PSU) defined by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query fan speed
+        :param fan_index: An integer, 1-based index of the PSU-fan of which to query speed
+        :return: An integer, value of PSU-fan speed in rpm if PSU-fan is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if fan_index > self.MAX_PSU_FAN:
+            raise RuntimeError("fan_index ({}) shouldn't be greater than {}".format(fan_index, self.MAX_PSU_FAN))
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        fan_speed = self._read_file(self.fan_speed, index)
+
+        return fan_speed
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfputil.py
deleted file mode 120000
index 45909b88..00000000
--- a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfputil.py
new file mode 100644
index 00000000..954ed23d
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3420-r0/plugins/sfputil.py
@@ -0,0 +1,688 @@
+# sfputil.py
+#
+# Platform-specific SFP transceiver interface for SONiC
+#
+
+try:
+    import time
+    import subprocess
+    from sonic_sfp.sfputilbase import *
+    import syslog
+except ImportError as e:
+    raise ImportError("%s - required module not found" % str(e))
+
+# sfp supports dom
+XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT = 0x40
+
+# sfp module threshold offset and width
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+
+# I2C page size for sfp
+SFP_I2C_PAGE_SIZE = 256
+
+# parameters for DB connection
+REDIS_TIMEOUT_USECS = 0
+
+# parameters for SFP presence
+SFP_STATUS_INSERTED = '1'
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+GET_PLATFORM_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.platform"
+
+# Ethernet<n> <=> sfp<n+SFP_PORT_NAME_OFFSET>
+SFP_PORT_NAME_OFFSET = 0
+SFP_PORT_NAME_CONVENTION = "sfp{}"
+
+# magic code defnition for port number, qsfp port position of each platform
+# port_position_tuple = (PORT_START, QSFP_PORT_START, PORT_END, PORT_IN_BLOCK, EEPROM_OFFSET)
+platform_dict = {'x86_64-mlnx_msn2700-r0': 0, 'x86_64-mlnx_msn2740-r0': 0, 'x86_64-mlnx_msn2100-r0': 1, 'x86_64-mlnx_msn2410-r0': 2, 'x86_64-mlnx_msn2010-r0': 3,
+                 'x86_64-mlnx_msn3420-r0': 5, 'x86_64-mlnx_msn3700-r0': 0, 'x86_64-mlnx_msn3700c-r0': 0, 'x86_64-mlnx_msn3800-r0': 4, 'x86_64-mlnx_msn4600c': 4, 'x86_64-mlnx_msn4700-r0': 0}
+port_position_tuple_list = [(0, 0, 31, 32, 1), (0, 0, 15, 16, 1), (0, 48, 55, 56, 1),
+                            (0, 18, 21, 22, 1), (0, 0, 63, 64, 1), (0, 48, 59, 60, 1)]
+
+
+def log_info(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+def log_err(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class SfpUtil(SfpUtilBase):
+    """Platform-specific SfpUtil class"""
+    PORT_START = 0
+    QSFP_PORT_START = 0
+    PORT_END = 0
+    PORTS_IN_BLOCK = 0
+    EEPROM_OFFSET = 0
+
+    db_sel = None
+    db_sel_timeout = None
+    db_sel_object = None
+    db_sel_tbl = None
+    state_db = None
+    sfpd_status_tbl = None
+
+    @property
+    def port_start(self):
+        return self.PORT_START
+
+    @property
+    def port_end(self):
+        return self.PORT_END
+
+    @property
+    def qsfp_ports(self):
+        return list(range(self.QSFP_PORT_START, self.PORTS_IN_BLOCK + 1))
+
+    @property
+    def port_to_eeprom_mapping(self):
+        print("dependency on sysfs has been removed")
+        raise Exception()
+
+    def get_port_position_tuple_by_platform_name(self):
+        p = subprocess.Popen(GET_PLATFORM_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        position_tuple = port_position_tuple_list[platform_dict[out.rstrip('\n')]]
+        return position_tuple
+
+    def __init__(self):
+        port_position_tuple = self.get_port_position_tuple_by_platform_name()
+        self.PORT_START = port_position_tuple[0] + 1
+        self.QSFP_PORT_START = port_position_tuple[1] + 1
+        self.PORT_END = port_position_tuple[2] + 1
+        self.PORTS_IN_BLOCK = port_position_tuple[3]
+        self.EEPROM_OFFSET = port_position_tuple[4]
+        self.mlnx_sfpd_started = False
+
+        SfpUtilBase.__init__(self)
+
+    def get_presence(self, port_num):
+        presence = False
+
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return presence
+
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        ethtool_cmd = "ethtool -m {} 2>/dev/null".format(sfpname)
+        try:
+            proc = subprocess.Popen(ethtool_cmd, stdout=subprocess.PIPE, shell=True, universal_newlines=True, stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+            if result != '':
+                presence = True
+
+        except OSError as e:
+            return presence
+
+        return presence
+
+    def get_low_power_mode(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmget.py {}".format(port_num)
+
+        try:
+            output = subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            if 'LPM ON' in output:
+                return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to get LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def set_low_power_mode(self, port_num, lpmode):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        curr_lpmode = self.get_low_power_mode(port_num)
+        if curr_lpmode == lpmode:
+            return True
+
+        # Compose LPM command
+        lpm = 'on' if lpmode else 'off'
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmset.py {} {}".format(port_num, lpm)
+
+        # Set LPM
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return True
+
+    def reset(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfpreset.py {}".format(port_num)
+
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def get_transceiver_change_event(self, timeout=0):
+        phy_port_dict = {}
+        status = True
+
+        if self.db_sel is None:
+            from swsscommon import swsscommon
+            self.state_db = swsscommon.DBConnector("STATE_DB",
+                                                   REDIS_TIMEOUT_USECS,
+                                                   True)
+
+            # Subscribe to state table for SFP change notifications
+            self.db_sel = swsscommon.Select()
+            self.db_sel_tbl = swsscommon.NotificationConsumer(self.state_db, 'TRANSCEIVER_NOTIFY')
+            self.db_sel.addSelectable(self.db_sel_tbl)
+            self.db_sel_timeout = swsscommon.Select.TIMEOUT
+            self.db_sel_object = swsscommon.Select.OBJECT
+            self.sfpd_status_tbl = swsscommon.Table(self.state_db, 'MLNX_SFPD_TASK')
+
+        # Check the liveness of mlnx-sfpd, if it failed, return system_fail event
+        # If mlnx-sfpd not started, return system_not_ready event
+        keys = self.sfpd_status_tbl.getKeys()
+        if 'LIVENESS' not in keys:
+            if self.mlnx_sfpd_started:
+                log_err("mlnx-sfpd exited, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_FAIL
+                return False, phy_port_dict
+            else:
+                log_info("mlnx-sfpd not ready, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_NOT_READY
+                return False, phy_port_dict
+        else:
+            if not self.mlnx_sfpd_started:
+                self.mlnx_sfpd_started = True
+                log_info("mlnx-sfpd is running")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_READY
+                return False, phy_port_dict
+
+        if timeout:
+            (state, c) = self.db_sel.select(timeout)
+        else:
+            (state, c) = self.db_sel.select()
+
+        if state == self.db_sel_timeout:
+            status = True
+        elif state != self.db_sel_object:
+            status = False
+        else:
+            (key, op, fvp) = self.db_sel_tbl.pop()
+            phy_port_dict[key] = op
+
+        return status, phy_port_dict
+
+    def _read_eeprom_specific_bytes(self, sysfsfile_eeprom, offset, num_bytes):
+        print("_read_eeprom_specific_bytes should not be called since the sysfs it dependents on will no longer exist.")
+        print("_read_eeprom_specific_bytes_via_ethtool should be called instead")
+        raise Exception()
+
+    # Read out any bytes from any offset
+    def _read_eeprom_specific_bytes_via_ethtool(self, port_num, offset, num_bytes):
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        eeprom_raw = []
+        ethtool_cmd = "ethtool -m {} hex on offset {} length {}".format(sfpname, offset, num_bytes)
+        try:
+            output = subprocess.check_output(ethtool_cmd, shell=True, universal_newlines=True)
+            output_lines = output.splitlines()
+            first_line_raw = output_lines[0]
+            if "Offset" in first_line_raw:
+                for line in output_lines[2:]:
+                    line_split = line.split()
+                    eeprom_raw = eeprom_raw + line_split[1:]
+        except subprocess.CalledProcessError as e:
+            return None
+
+        return eeprom_raw
+
+    # Read eeprom
+    def _read_eeprom_devid(self, port_num, devid, offset, num_bytes=512):
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            pass
+        elif (self.DOM_EEPROM_ADDR == devid):
+            offset += 256
+
+        eeprom_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, num_bytes)
+
+        return eeprom_raw
+
+    # Read out SFP type, vendor name, PN, REV, SN from eeprom.
+    def get_transceiver_info_dict(self, port_num):
+        transceiver_info_dict = {}
+        compliance_code_dict = {}
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if port_num in self.osfp_ports:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_type_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            # Below part is added to avoid fail the xcvrd, shall be implemented later
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if port_num in self.qsfp_ports:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+                sfp_type = 'QSFP'
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+                sfp_type = 'SFP'
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_INTFACE_BULK_OFFSET), interface_info_bulk_width)
+            if sfp_interface_bulk_raw is not None:
+                sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(sfp_interface_bulk_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_oui_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_OUI_OFFSET), XCVR_VENDOR_OUI_WIDTH)
+            if sfp_vendor_oui_raw is not None:
+                sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(sfp_vendor_oui_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_date_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_DATE_OFFSET), XCVR_VENDOR_DATE_WIDTH)
+            if sfp_vendor_date_raw is not None:
+                sfp_vendor_date_data = sfpi_obj.parse_vendor_date(sfp_vendor_date_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            if sfp_type == 'QSFP':
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_dom_info_dict(self, port_num):
+        transceiver_dom_info_dict = {}
+
+        # Below part is added to avoid failing xcvrd
+        # Currently, the way in which dom data is read has been changed from
+        # using sysfs to using ethtool.
+        # The ethtool returns None for ports without dom support, resulting in
+        # None being returned. However, this fails xcvrd to add the
+        # TRANSCEIVER_DOM_SENSOR table entry of associated port to CONFIG_DB
+        # and then causes SNMP fail.
+        # To address this issue a default dict is initialized with all data set to
+        # 'N/A' and is returned is the above case.
+        # BTW, in the original implementation which sysfs is used to read dom data,
+        # even though non-None data is returned for ports without dom support,
+        # it does not contain valid data. This can result in wrong data in
+        # TRANSCEIVER_DOM_SENSOR table.
+        transceiver_dom_info_dict['temperature'] = 'N/A'
+        transceiver_dom_info_dict['voltage'] = 'N/A'
+        transceiver_dom_info_dict['rx1power'] = 'N/A'
+        transceiver_dom_info_dict['rx2power'] = 'N/A'
+        transceiver_dom_info_dict['rx3power'] = 'N/A'
+        transceiver_dom_info_dict['rx4power'] = 'N/A'
+        transceiver_dom_info_dict['tx1bias'] = 'N/A'
+        transceiver_dom_info_dict['tx2bias'] = 'N/A'
+        transceiver_dom_info_dict['tx3bias'] = 'N/A'
+        transceiver_dom_info_dict['tx4bias'] = 'N/A'
+        transceiver_dom_info_dict['tx1power'] = 'N/A'
+        transceiver_dom_info_dict['tx2power'] = 'N/A'
+        transceiver_dom_info_dict['tx3power'] = 'N/A'
+        transceiver_dom_info_dict['tx4power'] = 'N/A'
+
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            offset = 0
+            offset_xcvr = 128
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset_xcvr + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qspf_dom_capability_data = sfpi_obj.parse_qsfp_dom_capability(qsfp_dom_capability_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_temperature_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_TEMPE_OFFSET), QSFP_TEMPE_WIDTH)
+            if dom_temperature_raw is not None:
+                dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_voltage_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_VOLT_OFFSET), QSFP_VOLT_WIDTH)
+            if dom_voltage_raw is not None:
+                dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            qsfp_dom_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_DOM_REV_OFFSET), QSFP_DOM_REV_WIDTH)
+            if qsfp_dom_rev_raw is not None:
+                qsfp_dom_rev_data = sfpd_obj.parse_sfp_dom_rev(qsfp_dom_rev_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+
+            # The tx_power monitoring is only available on QSFP which compliant with SFF-8636
+            # and claimed that it support tx_power with one indicator bit.
+            dom_channel_monitor_data = {}
+            qsfp_dom_rev = qsfp_dom_rev_data['data']['dom_rev']['value']
+            qsfp_tx_power_support = qspf_dom_capability_data['data']['Tx_power_support']['value']
+            if (qsfp_dom_rev[0:8] != 'SFF-8636' or (qsfp_dom_rev[0:8] == 'SFF-8636' and qsfp_tx_power_support != 'on')):
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+            else:
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+
+                transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TX1Power']['value']
+                transceiver_dom_info_dict['tx2power'] = dom_channel_monitor_data['data']['TX2Power']['value']
+                transceiver_dom_info_dict['tx3power'] = dom_channel_monitor_data['data']['TX3Power']['value']
+                transceiver_dom_info_dict['tx4power'] = dom_channel_monitor_data['data']['TX4Power']['value']
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RX1Power']['value']
+            transceiver_dom_info_dict['rx2power'] = dom_channel_monitor_data['data']['RX2Power']['value']
+            transceiver_dom_info_dict['rx3power'] = dom_channel_monitor_data['data']['RX3Power']['value']
+            transceiver_dom_info_dict['rx4power'] = dom_channel_monitor_data['data']['RX4Power']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_info_dict
+
+            eeprom_domraw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, SFP_I2C_PAGE_SIZE)
+            if eeprom_domraw is None:
+                return transceiver_dom_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                print("no sff8472Dom")
+                return None
+
+            dom_temperature_raw = eeprom_domraw[SFP_TEMPE_OFFSET:SFP_TEMPE_OFFSET+SFP_TEMPE_WIDTH]
+            dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+
+            dom_voltage_raw = eeprom_domraw[SFP_VOLT_OFFSET:SFP_VOLT_OFFSET+SFP_VOLT_WIDTH]
+            dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+
+            dom_channel_monitor_raw = eeprom_domraw[SFP_CHANNL_MON_OFFSET:SFP_CHANNL_MON_OFFSET+SFP_CHANNL_MON_WIDTH]
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RXPower']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TXBias']['value']
+            transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TXPower']['value']
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_dom_threshold_info_dict(self, port_num):
+        transceiver_dom_threshold_info_dict = {}
+
+        dom_info_dict_keys = ['temphighalarm',    'temphighwarning',
+                              'templowalarm',     'templowwarning',
+                              'vcchighalarm',     'vcchighwarning',
+                              'vcclowalarm',      'vcclowwarning',
+                              'rxpowerhighalarm', 'rxpowerhighwarning',
+                              'rxpowerlowalarm',  'rxpowerlowwarning',
+                              'txpowerhighalarm', 'txpowerhighwarning',
+                              'txpowerlowalarm',  'txpowerlowwarning',
+                              'txbiashighalarm',  'txbiashighwarning',
+                              'txbiaslowalarm',   'txbiaslowwarning'
+                              ]
+        transceiver_dom_threshold_info_dict = dict.fromkeys(dom_info_dict_keys, 'N/A')
+
+        if port_num in self.qsfp_ports:
+            # current we don't support qsfp since threshold data is on page 3 and the way to read this page is under discussion.
+            return transceiver_dom_threshold_info_dict
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num,
+                                                                                    (offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                                    SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/fanutil.py
deleted file mode 120000
index 82ea06ef..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/fanutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/fanutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/fanutil.py
new file mode 100644
index 00000000..ee6446e7
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/fanutil.py
@@ -0,0 +1,202 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from glob import glob
+    from sonic_fan.fan_base import FanBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("fanutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class FanUtil(FanBase):
+    """Platform-specific FanUtil class"""
+
+    PWM_MAX = 255
+    MAX_FAN_PER_DRAWER = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    sku_without_fan_direction = ['ACS-MSN2010', 'ACS-MSN2100', 'ACS-MSN2410',
+                                 'ACS-MSN2700', 'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+    sku_with_unpluggable_fan = ['ACS-MSN2010', 'ACS-MSN2100']
+
+    def __init__(self):
+        FanBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.fan_path = "/var/run/hw-management/"
+        if self.sku_name in self.sku_with_unpluggable_fan:
+            self.fan_status = None
+            self.unpluggable_fan = True
+        else:
+            self.fan_status = "thermal/fan{}_status"
+            self.unpluggable_fan = False
+        self.fan_get_speed = "thermal/fan{}_speed_get"
+        self.fan_set_speed = "thermal/fan{}_speed_set"
+        if self.sku_name in self.sku_without_fan_direction:
+            self.fan_direction = None
+        else:
+            self.fan_direction = "system/fan_dir"
+
+        self.fan_led_green = "led/led_fan*_green"
+        self.num_of_fan, self.num_of_drawer = self._extract_num_of_fans_and_fan_drawers()
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def _extract_num_of_fans_and_fan_drawers(self):
+        # So far we don't have files representing the number of fans and drawers
+        # The only way to retrieve the number is to count files.
+        # for number of fans, we get it via couting the speed files.
+        # for number of draws, we get it via couting the green led files.
+        list_of_fan_speed = glob(self.fan_path + self.fan_get_speed.format("*"))
+        num_of_fan = len(list_of_fan_speed)
+        list_of_fan_leds = glob(self.fan_path + self.fan_led_green)
+        num_of_drawer = len(list_of_fan_leds)
+
+        return num_of_fan, num_of_drawer
+
+    def _convert_fan_index_to_drawer_index(self, index):
+        return (index + self.MAX_FAN_PER_DRAWER - 1) / self.MAX_FAN_PER_DRAWER
+
+    def _read_file(self, file_pattern, index=0):
+        """
+        Reads the file of the fan
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the fan of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(os.path.join(self.fan_path, file_pattern.format(index)), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.fan_path + file_pattern.format(index)))
+            return return_value
+
+        return return_value
+
+    def get_num_fans(self):
+        """
+        Retrieves the number of FANs supported on the device
+
+        :return: An integer, the number of FANs supported on the device
+        """
+        return self.num_of_fan
+
+    def get_status(self, index):
+        """
+        Retrieves the operational status of FAN defined
+                by index 1-based <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean,
+            - True if FAN is running with some speed 
+            - False if FAN has stopped running
+        """
+        if not self.get_presence(index):
+            return False
+
+        return self.get_speed(index) != 0
+
+    def get_presence(self, index):
+        """
+        Retrieves the presence status of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: Boolean, True if FAN is plugged, False if not
+        """
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        if self.unpluggable_fan:
+            return True
+
+        draw_index = self._convert_fan_index_to_drawer_index(index)
+        presence = self._read_file(self.fan_status, draw_index)
+
+        return presence != 0
+
+    def get_direction(self, index):
+        """
+        Retrieves the airflow direction of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: string, denoting FAN airflow direction
+        Note:
+            What Mellanox calls forward: 
+            Air flows from fans side to QSFP side, for example: MSN2700-CS2F
+            which means intake in community
+            What Mellanox calls reverse:
+            Air flow from QSFP side to fans side, for example: MSN2700-CS2R
+            which means exhaust in community
+            According to hw-mgmt:
+                1 stands for forward, in other words intake
+                0 stands for reverse, in other words exhaust
+        """
+        if not self.fan_direction:
+            return self.FAN_DIRECTION_NOT_APPLICABLE
+
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        drawer_index = self._convert_fan_index_to_drawer_index(index)
+
+        fan_dir_bits = self._read_file(self.fan_direction)
+        fan_mask = 1 << drawer_index - 1
+        if fan_dir_bits & fan_mask:
+            return self.FAN_DIRECTION_INTAKE
+        else:
+            return self.FAN_DIRECTION_EXHAUST
+
+    def get_speed(self, index):
+        """
+        Retrieves the speed of a Front FAN in the tray in revolutions per minute defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query speed
+        :return: integer, denoting front FAN speed
+        """
+        speed = self._read_file(self.fan_get_speed, index)
+
+        return speed
+
+    def set_speed(self, val):
+        """
+        Sets the speed of all the FANs to a value denoted by the duty-cycle percentage val
+
+        :param val: An integer, <0-100> denoting FAN duty cycle percentage 
+        :return: Boolean, True if operation is successful, False if not
+        """
+        status = True
+        pwm = int(round(self.PWM_MAX*val/100.0))
+
+        try:
+            with open(os.path.join(self.fan_path, self.fan_set_speed.format(1)), 'w') as fan_pwm:
+                fan_pwm.write(str(pwm))
+        except (ValueError, IOError):
+            log_err("Read file {} failed".format(self.fan_path + self.fan_set_speed.format(1)))
+            status = False
+
+        return status
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/psuutil.py
deleted file mode 120000
index 9f724238..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/psuutil.py
new file mode 100644
index 00000000..6da5770c
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/psuutil.py
@@ -0,0 +1,184 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from sonic_psu.psu_base import PsuBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("psuutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class PsuUtil(PsuBase):
+    """Platform-specific PSUutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    # for spectrum1 switches with plugable PSUs, the output voltage file is psuX_volt
+    # for spectrum2 switches the output voltage file is psuX_volt_out2
+    sku_spectrum1_with_plugable_psu = ['ACS-MSN2410', 'ACS-MSN2700',
+                                       'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+
+    def __init__(self):
+        PsuBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.psu_path = "/var/run/hw-management/"
+        self.psu_presence = "thermal/psu{}_status"
+        self.psu_oper_status = "thermal/psu{}_pwr_status"
+        self.psu_current = "power/psu{}_curr"
+        self.psu_power = "power/psu{}_power"
+        if self.sku_name in self.sku_spectrum1_with_plugable_psu:
+            self.psu_voltage = "power/psu{}_volt"
+        else:
+            self.psu_voltage = "power/psu{}_volt_out2"
+        self.fan_speed = "thermal/psu{}_fan1_speed_get"
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def get_num_psus(self):
+        """
+        Retrieves the number of PSUs available on the device
+
+        :return: An integer, the number of PSUs available on the device
+        """
+        return self.MAX_NUM_PSU
+
+    def _read_file(self, file_pattern, index):
+        """
+        Reads the file of the PSU
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(self.psu_path + file_pattern.format(index), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.psu_path + file_pattern.format(index)))
+            return 0
+
+        return return_value
+
+    def get_psu_status(self, index):
+        """
+        Retrieves the oprational status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is operating properly, False if PSU is faulty
+        """
+        if index is None:
+            return False
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_oper_status, index)
+
+        return status == 1
+
+    def get_psu_presence(self, index):
+        """
+        Retrieves the presence status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is plugged, False if not
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_presence, index)
+
+        return status == 1
+
+    def get_output_voltage(self, index):
+        """
+        Retrieves the ouput volatage in milli volts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p volatge
+        :return: An integer, value of o/p voltage in mV if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        voltage = self._read_file(self.psu_voltage, index)
+
+        return voltage
+
+    def get_output_current(self, index):
+        """
+        Retrieves the output current in milli amperes of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p current
+        :return: An integer, value of o/p current in mA if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        current = self._read_file(self.psu_current, index)
+
+        return current
+
+    def get_output_power(self, index):
+        """
+        Retrieves the output power in micro watts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p power
+        :return: An integer, value of o/p power in micro Watts if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        power = self._read_file(self.psu_power, index)
+
+        return power
+
+    def get_fan_speed(self, index, fan_index):
+        """
+        Retrieves the speed of fan, in rpm, denoted by 1-based <fan_index> of a power 
+                supply unit (PSU) defined by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query fan speed
+        :param fan_index: An integer, 1-based index of the PSU-fan of which to query speed
+        :return: An integer, value of PSU-fan speed in rpm if PSU-fan is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if fan_index > self.MAX_PSU_FAN:
+            raise RuntimeError("fan_index ({}) shouldn't be greater than {}".format(fan_index, self.MAX_PSU_FAN))
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        fan_speed = self._read_file(self.fan_speed, index)
+
+        return fan_speed
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfputil.py
deleted file mode 120000
index 45909b88..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfputil.py
new file mode 100644
index 00000000..954ed23d
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700-r0/plugins/sfputil.py
@@ -0,0 +1,688 @@
+# sfputil.py
+#
+# Platform-specific SFP transceiver interface for SONiC
+#
+
+try:
+    import time
+    import subprocess
+    from sonic_sfp.sfputilbase import *
+    import syslog
+except ImportError as e:
+    raise ImportError("%s - required module not found" % str(e))
+
+# sfp supports dom
+XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT = 0x40
+
+# sfp module threshold offset and width
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+
+# I2C page size for sfp
+SFP_I2C_PAGE_SIZE = 256
+
+# parameters for DB connection
+REDIS_TIMEOUT_USECS = 0
+
+# parameters for SFP presence
+SFP_STATUS_INSERTED = '1'
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+GET_PLATFORM_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.platform"
+
+# Ethernet<n> <=> sfp<n+SFP_PORT_NAME_OFFSET>
+SFP_PORT_NAME_OFFSET = 0
+SFP_PORT_NAME_CONVENTION = "sfp{}"
+
+# magic code defnition for port number, qsfp port position of each platform
+# port_position_tuple = (PORT_START, QSFP_PORT_START, PORT_END, PORT_IN_BLOCK, EEPROM_OFFSET)
+platform_dict = {'x86_64-mlnx_msn2700-r0': 0, 'x86_64-mlnx_msn2740-r0': 0, 'x86_64-mlnx_msn2100-r0': 1, 'x86_64-mlnx_msn2410-r0': 2, 'x86_64-mlnx_msn2010-r0': 3,
+                 'x86_64-mlnx_msn3420-r0': 5, 'x86_64-mlnx_msn3700-r0': 0, 'x86_64-mlnx_msn3700c-r0': 0, 'x86_64-mlnx_msn3800-r0': 4, 'x86_64-mlnx_msn4600c': 4, 'x86_64-mlnx_msn4700-r0': 0}
+port_position_tuple_list = [(0, 0, 31, 32, 1), (0, 0, 15, 16, 1), (0, 48, 55, 56, 1),
+                            (0, 18, 21, 22, 1), (0, 0, 63, 64, 1), (0, 48, 59, 60, 1)]
+
+
+def log_info(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+def log_err(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class SfpUtil(SfpUtilBase):
+    """Platform-specific SfpUtil class"""
+    PORT_START = 0
+    QSFP_PORT_START = 0
+    PORT_END = 0
+    PORTS_IN_BLOCK = 0
+    EEPROM_OFFSET = 0
+
+    db_sel = None
+    db_sel_timeout = None
+    db_sel_object = None
+    db_sel_tbl = None
+    state_db = None
+    sfpd_status_tbl = None
+
+    @property
+    def port_start(self):
+        return self.PORT_START
+
+    @property
+    def port_end(self):
+        return self.PORT_END
+
+    @property
+    def qsfp_ports(self):
+        return list(range(self.QSFP_PORT_START, self.PORTS_IN_BLOCK + 1))
+
+    @property
+    def port_to_eeprom_mapping(self):
+        print("dependency on sysfs has been removed")
+        raise Exception()
+
+    def get_port_position_tuple_by_platform_name(self):
+        p = subprocess.Popen(GET_PLATFORM_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        position_tuple = port_position_tuple_list[platform_dict[out.rstrip('\n')]]
+        return position_tuple
+
+    def __init__(self):
+        port_position_tuple = self.get_port_position_tuple_by_platform_name()
+        self.PORT_START = port_position_tuple[0] + 1
+        self.QSFP_PORT_START = port_position_tuple[1] + 1
+        self.PORT_END = port_position_tuple[2] + 1
+        self.PORTS_IN_BLOCK = port_position_tuple[3]
+        self.EEPROM_OFFSET = port_position_tuple[4]
+        self.mlnx_sfpd_started = False
+
+        SfpUtilBase.__init__(self)
+
+    def get_presence(self, port_num):
+        presence = False
+
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return presence
+
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        ethtool_cmd = "ethtool -m {} 2>/dev/null".format(sfpname)
+        try:
+            proc = subprocess.Popen(ethtool_cmd, stdout=subprocess.PIPE, shell=True, universal_newlines=True, stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+            if result != '':
+                presence = True
+
+        except OSError as e:
+            return presence
+
+        return presence
+
+    def get_low_power_mode(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmget.py {}".format(port_num)
+
+        try:
+            output = subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            if 'LPM ON' in output:
+                return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to get LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def set_low_power_mode(self, port_num, lpmode):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        curr_lpmode = self.get_low_power_mode(port_num)
+        if curr_lpmode == lpmode:
+            return True
+
+        # Compose LPM command
+        lpm = 'on' if lpmode else 'off'
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmset.py {} {}".format(port_num, lpm)
+
+        # Set LPM
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return True
+
+    def reset(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfpreset.py {}".format(port_num)
+
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def get_transceiver_change_event(self, timeout=0):
+        phy_port_dict = {}
+        status = True
+
+        if self.db_sel is None:
+            from swsscommon import swsscommon
+            self.state_db = swsscommon.DBConnector("STATE_DB",
+                                                   REDIS_TIMEOUT_USECS,
+                                                   True)
+
+            # Subscribe to state table for SFP change notifications
+            self.db_sel = swsscommon.Select()
+            self.db_sel_tbl = swsscommon.NotificationConsumer(self.state_db, 'TRANSCEIVER_NOTIFY')
+            self.db_sel.addSelectable(self.db_sel_tbl)
+            self.db_sel_timeout = swsscommon.Select.TIMEOUT
+            self.db_sel_object = swsscommon.Select.OBJECT
+            self.sfpd_status_tbl = swsscommon.Table(self.state_db, 'MLNX_SFPD_TASK')
+
+        # Check the liveness of mlnx-sfpd, if it failed, return system_fail event
+        # If mlnx-sfpd not started, return system_not_ready event
+        keys = self.sfpd_status_tbl.getKeys()
+        if 'LIVENESS' not in keys:
+            if self.mlnx_sfpd_started:
+                log_err("mlnx-sfpd exited, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_FAIL
+                return False, phy_port_dict
+            else:
+                log_info("mlnx-sfpd not ready, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_NOT_READY
+                return False, phy_port_dict
+        else:
+            if not self.mlnx_sfpd_started:
+                self.mlnx_sfpd_started = True
+                log_info("mlnx-sfpd is running")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_READY
+                return False, phy_port_dict
+
+        if timeout:
+            (state, c) = self.db_sel.select(timeout)
+        else:
+            (state, c) = self.db_sel.select()
+
+        if state == self.db_sel_timeout:
+            status = True
+        elif state != self.db_sel_object:
+            status = False
+        else:
+            (key, op, fvp) = self.db_sel_tbl.pop()
+            phy_port_dict[key] = op
+
+        return status, phy_port_dict
+
+    def _read_eeprom_specific_bytes(self, sysfsfile_eeprom, offset, num_bytes):
+        print("_read_eeprom_specific_bytes should not be called since the sysfs it dependents on will no longer exist.")
+        print("_read_eeprom_specific_bytes_via_ethtool should be called instead")
+        raise Exception()
+
+    # Read out any bytes from any offset
+    def _read_eeprom_specific_bytes_via_ethtool(self, port_num, offset, num_bytes):
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        eeprom_raw = []
+        ethtool_cmd = "ethtool -m {} hex on offset {} length {}".format(sfpname, offset, num_bytes)
+        try:
+            output = subprocess.check_output(ethtool_cmd, shell=True, universal_newlines=True)
+            output_lines = output.splitlines()
+            first_line_raw = output_lines[0]
+            if "Offset" in first_line_raw:
+                for line in output_lines[2:]:
+                    line_split = line.split()
+                    eeprom_raw = eeprom_raw + line_split[1:]
+        except subprocess.CalledProcessError as e:
+            return None
+
+        return eeprom_raw
+
+    # Read eeprom
+    def _read_eeprom_devid(self, port_num, devid, offset, num_bytes=512):
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            pass
+        elif (self.DOM_EEPROM_ADDR == devid):
+            offset += 256
+
+        eeprom_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, num_bytes)
+
+        return eeprom_raw
+
+    # Read out SFP type, vendor name, PN, REV, SN from eeprom.
+    def get_transceiver_info_dict(self, port_num):
+        transceiver_info_dict = {}
+        compliance_code_dict = {}
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if port_num in self.osfp_ports:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_type_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            # Below part is added to avoid fail the xcvrd, shall be implemented later
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if port_num in self.qsfp_ports:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+                sfp_type = 'QSFP'
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+                sfp_type = 'SFP'
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_INTFACE_BULK_OFFSET), interface_info_bulk_width)
+            if sfp_interface_bulk_raw is not None:
+                sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(sfp_interface_bulk_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_oui_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_OUI_OFFSET), XCVR_VENDOR_OUI_WIDTH)
+            if sfp_vendor_oui_raw is not None:
+                sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(sfp_vendor_oui_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_date_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_DATE_OFFSET), XCVR_VENDOR_DATE_WIDTH)
+            if sfp_vendor_date_raw is not None:
+                sfp_vendor_date_data = sfpi_obj.parse_vendor_date(sfp_vendor_date_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            if sfp_type == 'QSFP':
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_dom_info_dict(self, port_num):
+        transceiver_dom_info_dict = {}
+
+        # Below part is added to avoid failing xcvrd
+        # Currently, the way in which dom data is read has been changed from
+        # using sysfs to using ethtool.
+        # The ethtool returns None for ports without dom support, resulting in
+        # None being returned. However, this fails xcvrd to add the
+        # TRANSCEIVER_DOM_SENSOR table entry of associated port to CONFIG_DB
+        # and then causes SNMP fail.
+        # To address this issue a default dict is initialized with all data set to
+        # 'N/A' and is returned is the above case.
+        # BTW, in the original implementation which sysfs is used to read dom data,
+        # even though non-None data is returned for ports without dom support,
+        # it does not contain valid data. This can result in wrong data in
+        # TRANSCEIVER_DOM_SENSOR table.
+        transceiver_dom_info_dict['temperature'] = 'N/A'
+        transceiver_dom_info_dict['voltage'] = 'N/A'
+        transceiver_dom_info_dict['rx1power'] = 'N/A'
+        transceiver_dom_info_dict['rx2power'] = 'N/A'
+        transceiver_dom_info_dict['rx3power'] = 'N/A'
+        transceiver_dom_info_dict['rx4power'] = 'N/A'
+        transceiver_dom_info_dict['tx1bias'] = 'N/A'
+        transceiver_dom_info_dict['tx2bias'] = 'N/A'
+        transceiver_dom_info_dict['tx3bias'] = 'N/A'
+        transceiver_dom_info_dict['tx4bias'] = 'N/A'
+        transceiver_dom_info_dict['tx1power'] = 'N/A'
+        transceiver_dom_info_dict['tx2power'] = 'N/A'
+        transceiver_dom_info_dict['tx3power'] = 'N/A'
+        transceiver_dom_info_dict['tx4power'] = 'N/A'
+
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            offset = 0
+            offset_xcvr = 128
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset_xcvr + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qspf_dom_capability_data = sfpi_obj.parse_qsfp_dom_capability(qsfp_dom_capability_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_temperature_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_TEMPE_OFFSET), QSFP_TEMPE_WIDTH)
+            if dom_temperature_raw is not None:
+                dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_voltage_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_VOLT_OFFSET), QSFP_VOLT_WIDTH)
+            if dom_voltage_raw is not None:
+                dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            qsfp_dom_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_DOM_REV_OFFSET), QSFP_DOM_REV_WIDTH)
+            if qsfp_dom_rev_raw is not None:
+                qsfp_dom_rev_data = sfpd_obj.parse_sfp_dom_rev(qsfp_dom_rev_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+
+            # The tx_power monitoring is only available on QSFP which compliant with SFF-8636
+            # and claimed that it support tx_power with one indicator bit.
+            dom_channel_monitor_data = {}
+            qsfp_dom_rev = qsfp_dom_rev_data['data']['dom_rev']['value']
+            qsfp_tx_power_support = qspf_dom_capability_data['data']['Tx_power_support']['value']
+            if (qsfp_dom_rev[0:8] != 'SFF-8636' or (qsfp_dom_rev[0:8] == 'SFF-8636' and qsfp_tx_power_support != 'on')):
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+            else:
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+
+                transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TX1Power']['value']
+                transceiver_dom_info_dict['tx2power'] = dom_channel_monitor_data['data']['TX2Power']['value']
+                transceiver_dom_info_dict['tx3power'] = dom_channel_monitor_data['data']['TX3Power']['value']
+                transceiver_dom_info_dict['tx4power'] = dom_channel_monitor_data['data']['TX4Power']['value']
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RX1Power']['value']
+            transceiver_dom_info_dict['rx2power'] = dom_channel_monitor_data['data']['RX2Power']['value']
+            transceiver_dom_info_dict['rx3power'] = dom_channel_monitor_data['data']['RX3Power']['value']
+            transceiver_dom_info_dict['rx4power'] = dom_channel_monitor_data['data']['RX4Power']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_info_dict
+
+            eeprom_domraw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, SFP_I2C_PAGE_SIZE)
+            if eeprom_domraw is None:
+                return transceiver_dom_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                print("no sff8472Dom")
+                return None
+
+            dom_temperature_raw = eeprom_domraw[SFP_TEMPE_OFFSET:SFP_TEMPE_OFFSET+SFP_TEMPE_WIDTH]
+            dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+
+            dom_voltage_raw = eeprom_domraw[SFP_VOLT_OFFSET:SFP_VOLT_OFFSET+SFP_VOLT_WIDTH]
+            dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+
+            dom_channel_monitor_raw = eeprom_domraw[SFP_CHANNL_MON_OFFSET:SFP_CHANNL_MON_OFFSET+SFP_CHANNL_MON_WIDTH]
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RXPower']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TXBias']['value']
+            transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TXPower']['value']
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_dom_threshold_info_dict(self, port_num):
+        transceiver_dom_threshold_info_dict = {}
+
+        dom_info_dict_keys = ['temphighalarm',    'temphighwarning',
+                              'templowalarm',     'templowwarning',
+                              'vcchighalarm',     'vcchighwarning',
+                              'vcclowalarm',      'vcclowwarning',
+                              'rxpowerhighalarm', 'rxpowerhighwarning',
+                              'rxpowerlowalarm',  'rxpowerlowwarning',
+                              'txpowerhighalarm', 'txpowerhighwarning',
+                              'txpowerlowalarm',  'txpowerlowwarning',
+                              'txbiashighalarm',  'txbiashighwarning',
+                              'txbiaslowalarm',   'txbiaslowwarning'
+                              ]
+        transceiver_dom_threshold_info_dict = dict.fromkeys(dom_info_dict_keys, 'N/A')
+
+        if port_num in self.qsfp_ports:
+            # current we don't support qsfp since threshold data is on page 3 and the way to read this page is under discussion.
+            return transceiver_dom_threshold_info_dict
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num,
+                                                                                    (offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                                    SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/fanutil.py
deleted file mode 120000
index 82ea06ef..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/fanutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/fanutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/fanutil.py
new file mode 100644
index 00000000..ee6446e7
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/fanutil.py
@@ -0,0 +1,202 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from glob import glob
+    from sonic_fan.fan_base import FanBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("fanutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class FanUtil(FanBase):
+    """Platform-specific FanUtil class"""
+
+    PWM_MAX = 255
+    MAX_FAN_PER_DRAWER = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    sku_without_fan_direction = ['ACS-MSN2010', 'ACS-MSN2100', 'ACS-MSN2410',
+                                 'ACS-MSN2700', 'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+    sku_with_unpluggable_fan = ['ACS-MSN2010', 'ACS-MSN2100']
+
+    def __init__(self):
+        FanBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.fan_path = "/var/run/hw-management/"
+        if self.sku_name in self.sku_with_unpluggable_fan:
+            self.fan_status = None
+            self.unpluggable_fan = True
+        else:
+            self.fan_status = "thermal/fan{}_status"
+            self.unpluggable_fan = False
+        self.fan_get_speed = "thermal/fan{}_speed_get"
+        self.fan_set_speed = "thermal/fan{}_speed_set"
+        if self.sku_name in self.sku_without_fan_direction:
+            self.fan_direction = None
+        else:
+            self.fan_direction = "system/fan_dir"
+
+        self.fan_led_green = "led/led_fan*_green"
+        self.num_of_fan, self.num_of_drawer = self._extract_num_of_fans_and_fan_drawers()
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def _extract_num_of_fans_and_fan_drawers(self):
+        # So far we don't have files representing the number of fans and drawers
+        # The only way to retrieve the number is to count files.
+        # for number of fans, we get it via couting the speed files.
+        # for number of draws, we get it via couting the green led files.
+        list_of_fan_speed = glob(self.fan_path + self.fan_get_speed.format("*"))
+        num_of_fan = len(list_of_fan_speed)
+        list_of_fan_leds = glob(self.fan_path + self.fan_led_green)
+        num_of_drawer = len(list_of_fan_leds)
+
+        return num_of_fan, num_of_drawer
+
+    def _convert_fan_index_to_drawer_index(self, index):
+        return (index + self.MAX_FAN_PER_DRAWER - 1) / self.MAX_FAN_PER_DRAWER
+
+    def _read_file(self, file_pattern, index=0):
+        """
+        Reads the file of the fan
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the fan of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(os.path.join(self.fan_path, file_pattern.format(index)), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.fan_path + file_pattern.format(index)))
+            return return_value
+
+        return return_value
+
+    def get_num_fans(self):
+        """
+        Retrieves the number of FANs supported on the device
+
+        :return: An integer, the number of FANs supported on the device
+        """
+        return self.num_of_fan
+
+    def get_status(self, index):
+        """
+        Retrieves the operational status of FAN defined
+                by index 1-based <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean,
+            - True if FAN is running with some speed 
+            - False if FAN has stopped running
+        """
+        if not self.get_presence(index):
+            return False
+
+        return self.get_speed(index) != 0
+
+    def get_presence(self, index):
+        """
+        Retrieves the presence status of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: Boolean, True if FAN is plugged, False if not
+        """
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        if self.unpluggable_fan:
+            return True
+
+        draw_index = self._convert_fan_index_to_drawer_index(index)
+        presence = self._read_file(self.fan_status, draw_index)
+
+        return presence != 0
+
+    def get_direction(self, index):
+        """
+        Retrieves the airflow direction of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: string, denoting FAN airflow direction
+        Note:
+            What Mellanox calls forward: 
+            Air flows from fans side to QSFP side, for example: MSN2700-CS2F
+            which means intake in community
+            What Mellanox calls reverse:
+            Air flow from QSFP side to fans side, for example: MSN2700-CS2R
+            which means exhaust in community
+            According to hw-mgmt:
+                1 stands for forward, in other words intake
+                0 stands for reverse, in other words exhaust
+        """
+        if not self.fan_direction:
+            return self.FAN_DIRECTION_NOT_APPLICABLE
+
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        drawer_index = self._convert_fan_index_to_drawer_index(index)
+
+        fan_dir_bits = self._read_file(self.fan_direction)
+        fan_mask = 1 << drawer_index - 1
+        if fan_dir_bits & fan_mask:
+            return self.FAN_DIRECTION_INTAKE
+        else:
+            return self.FAN_DIRECTION_EXHAUST
+
+    def get_speed(self, index):
+        """
+        Retrieves the speed of a Front FAN in the tray in revolutions per minute defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query speed
+        :return: integer, denoting front FAN speed
+        """
+        speed = self._read_file(self.fan_get_speed, index)
+
+        return speed
+
+    def set_speed(self, val):
+        """
+        Sets the speed of all the FANs to a value denoted by the duty-cycle percentage val
+
+        :param val: An integer, <0-100> denoting FAN duty cycle percentage 
+        :return: Boolean, True if operation is successful, False if not
+        """
+        status = True
+        pwm = int(round(self.PWM_MAX*val/100.0))
+
+        try:
+            with open(os.path.join(self.fan_path, self.fan_set_speed.format(1)), 'w') as fan_pwm:
+                fan_pwm.write(str(pwm))
+        except (ValueError, IOError):
+            log_err("Read file {} failed".format(self.fan_path + self.fan_set_speed.format(1)))
+            status = False
+
+        return status
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/psuutil.py
deleted file mode 120000
index 9f724238..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/psuutil.py
new file mode 100644
index 00000000..6da5770c
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/psuutil.py
@@ -0,0 +1,184 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from sonic_psu.psu_base import PsuBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("psuutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class PsuUtil(PsuBase):
+    """Platform-specific PSUutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    # for spectrum1 switches with plugable PSUs, the output voltage file is psuX_volt
+    # for spectrum2 switches the output voltage file is psuX_volt_out2
+    sku_spectrum1_with_plugable_psu = ['ACS-MSN2410', 'ACS-MSN2700',
+                                       'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+
+    def __init__(self):
+        PsuBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.psu_path = "/var/run/hw-management/"
+        self.psu_presence = "thermal/psu{}_status"
+        self.psu_oper_status = "thermal/psu{}_pwr_status"
+        self.psu_current = "power/psu{}_curr"
+        self.psu_power = "power/psu{}_power"
+        if self.sku_name in self.sku_spectrum1_with_plugable_psu:
+            self.psu_voltage = "power/psu{}_volt"
+        else:
+            self.psu_voltage = "power/psu{}_volt_out2"
+        self.fan_speed = "thermal/psu{}_fan1_speed_get"
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def get_num_psus(self):
+        """
+        Retrieves the number of PSUs available on the device
+
+        :return: An integer, the number of PSUs available on the device
+        """
+        return self.MAX_NUM_PSU
+
+    def _read_file(self, file_pattern, index):
+        """
+        Reads the file of the PSU
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(self.psu_path + file_pattern.format(index), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.psu_path + file_pattern.format(index)))
+            return 0
+
+        return return_value
+
+    def get_psu_status(self, index):
+        """
+        Retrieves the oprational status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is operating properly, False if PSU is faulty
+        """
+        if index is None:
+            return False
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_oper_status, index)
+
+        return status == 1
+
+    def get_psu_presence(self, index):
+        """
+        Retrieves the presence status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is plugged, False if not
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_presence, index)
+
+        return status == 1
+
+    def get_output_voltage(self, index):
+        """
+        Retrieves the ouput volatage in milli volts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p volatge
+        :return: An integer, value of o/p voltage in mV if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        voltage = self._read_file(self.psu_voltage, index)
+
+        return voltage
+
+    def get_output_current(self, index):
+        """
+        Retrieves the output current in milli amperes of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p current
+        :return: An integer, value of o/p current in mA if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        current = self._read_file(self.psu_current, index)
+
+        return current
+
+    def get_output_power(self, index):
+        """
+        Retrieves the output power in micro watts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p power
+        :return: An integer, value of o/p power in micro Watts if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        power = self._read_file(self.psu_power, index)
+
+        return power
+
+    def get_fan_speed(self, index, fan_index):
+        """
+        Retrieves the speed of fan, in rpm, denoted by 1-based <fan_index> of a power 
+                supply unit (PSU) defined by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query fan speed
+        :param fan_index: An integer, 1-based index of the PSU-fan of which to query speed
+        :return: An integer, value of PSU-fan speed in rpm if PSU-fan is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if fan_index > self.MAX_PSU_FAN:
+            raise RuntimeError("fan_index ({}) shouldn't be greater than {}".format(fan_index, self.MAX_PSU_FAN))
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        fan_speed = self._read_file(self.fan_speed, index)
+
+        return fan_speed
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfputil.py
deleted file mode 120000
index 45909b88..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfputil.py
new file mode 100644
index 00000000..954ed23d
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/sfputil.py
@@ -0,0 +1,688 @@
+# sfputil.py
+#
+# Platform-specific SFP transceiver interface for SONiC
+#
+
+try:
+    import time
+    import subprocess
+    from sonic_sfp.sfputilbase import *
+    import syslog
+except ImportError as e:
+    raise ImportError("%s - required module not found" % str(e))
+
+# sfp supports dom
+XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT = 0x40
+
+# sfp module threshold offset and width
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+
+# I2C page size for sfp
+SFP_I2C_PAGE_SIZE = 256
+
+# parameters for DB connection
+REDIS_TIMEOUT_USECS = 0
+
+# parameters for SFP presence
+SFP_STATUS_INSERTED = '1'
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+GET_PLATFORM_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.platform"
+
+# Ethernet<n> <=> sfp<n+SFP_PORT_NAME_OFFSET>
+SFP_PORT_NAME_OFFSET = 0
+SFP_PORT_NAME_CONVENTION = "sfp{}"
+
+# magic code defnition for port number, qsfp port position of each platform
+# port_position_tuple = (PORT_START, QSFP_PORT_START, PORT_END, PORT_IN_BLOCK, EEPROM_OFFSET)
+platform_dict = {'x86_64-mlnx_msn2700-r0': 0, 'x86_64-mlnx_msn2740-r0': 0, 'x86_64-mlnx_msn2100-r0': 1, 'x86_64-mlnx_msn2410-r0': 2, 'x86_64-mlnx_msn2010-r0': 3,
+                 'x86_64-mlnx_msn3420-r0': 5, 'x86_64-mlnx_msn3700-r0': 0, 'x86_64-mlnx_msn3700c-r0': 0, 'x86_64-mlnx_msn3800-r0': 4, 'x86_64-mlnx_msn4600c': 4, 'x86_64-mlnx_msn4700-r0': 0}
+port_position_tuple_list = [(0, 0, 31, 32, 1), (0, 0, 15, 16, 1), (0, 48, 55, 56, 1),
+                            (0, 18, 21, 22, 1), (0, 0, 63, 64, 1), (0, 48, 59, 60, 1)]
+
+
+def log_info(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+def log_err(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class SfpUtil(SfpUtilBase):
+    """Platform-specific SfpUtil class"""
+    PORT_START = 0
+    QSFP_PORT_START = 0
+    PORT_END = 0
+    PORTS_IN_BLOCK = 0
+    EEPROM_OFFSET = 0
+
+    db_sel = None
+    db_sel_timeout = None
+    db_sel_object = None
+    db_sel_tbl = None
+    state_db = None
+    sfpd_status_tbl = None
+
+    @property
+    def port_start(self):
+        return self.PORT_START
+
+    @property
+    def port_end(self):
+        return self.PORT_END
+
+    @property
+    def qsfp_ports(self):
+        return list(range(self.QSFP_PORT_START, self.PORTS_IN_BLOCK + 1))
+
+    @property
+    def port_to_eeprom_mapping(self):
+        print("dependency on sysfs has been removed")
+        raise Exception()
+
+    def get_port_position_tuple_by_platform_name(self):
+        p = subprocess.Popen(GET_PLATFORM_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        position_tuple = port_position_tuple_list[platform_dict[out.rstrip('\n')]]
+        return position_tuple
+
+    def __init__(self):
+        port_position_tuple = self.get_port_position_tuple_by_platform_name()
+        self.PORT_START = port_position_tuple[0] + 1
+        self.QSFP_PORT_START = port_position_tuple[1] + 1
+        self.PORT_END = port_position_tuple[2] + 1
+        self.PORTS_IN_BLOCK = port_position_tuple[3]
+        self.EEPROM_OFFSET = port_position_tuple[4]
+        self.mlnx_sfpd_started = False
+
+        SfpUtilBase.__init__(self)
+
+    def get_presence(self, port_num):
+        presence = False
+
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return presence
+
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        ethtool_cmd = "ethtool -m {} 2>/dev/null".format(sfpname)
+        try:
+            proc = subprocess.Popen(ethtool_cmd, stdout=subprocess.PIPE, shell=True, universal_newlines=True, stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+            if result != '':
+                presence = True
+
+        except OSError as e:
+            return presence
+
+        return presence
+
+    def get_low_power_mode(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmget.py {}".format(port_num)
+
+        try:
+            output = subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            if 'LPM ON' in output:
+                return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to get LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def set_low_power_mode(self, port_num, lpmode):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        curr_lpmode = self.get_low_power_mode(port_num)
+        if curr_lpmode == lpmode:
+            return True
+
+        # Compose LPM command
+        lpm = 'on' if lpmode else 'off'
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmset.py {} {}".format(port_num, lpm)
+
+        # Set LPM
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return True
+
+    def reset(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfpreset.py {}".format(port_num)
+
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def get_transceiver_change_event(self, timeout=0):
+        phy_port_dict = {}
+        status = True
+
+        if self.db_sel is None:
+            from swsscommon import swsscommon
+            self.state_db = swsscommon.DBConnector("STATE_DB",
+                                                   REDIS_TIMEOUT_USECS,
+                                                   True)
+
+            # Subscribe to state table for SFP change notifications
+            self.db_sel = swsscommon.Select()
+            self.db_sel_tbl = swsscommon.NotificationConsumer(self.state_db, 'TRANSCEIVER_NOTIFY')
+            self.db_sel.addSelectable(self.db_sel_tbl)
+            self.db_sel_timeout = swsscommon.Select.TIMEOUT
+            self.db_sel_object = swsscommon.Select.OBJECT
+            self.sfpd_status_tbl = swsscommon.Table(self.state_db, 'MLNX_SFPD_TASK')
+
+        # Check the liveness of mlnx-sfpd, if it failed, return system_fail event
+        # If mlnx-sfpd not started, return system_not_ready event
+        keys = self.sfpd_status_tbl.getKeys()
+        if 'LIVENESS' not in keys:
+            if self.mlnx_sfpd_started:
+                log_err("mlnx-sfpd exited, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_FAIL
+                return False, phy_port_dict
+            else:
+                log_info("mlnx-sfpd not ready, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_NOT_READY
+                return False, phy_port_dict
+        else:
+            if not self.mlnx_sfpd_started:
+                self.mlnx_sfpd_started = True
+                log_info("mlnx-sfpd is running")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_READY
+                return False, phy_port_dict
+
+        if timeout:
+            (state, c) = self.db_sel.select(timeout)
+        else:
+            (state, c) = self.db_sel.select()
+
+        if state == self.db_sel_timeout:
+            status = True
+        elif state != self.db_sel_object:
+            status = False
+        else:
+            (key, op, fvp) = self.db_sel_tbl.pop()
+            phy_port_dict[key] = op
+
+        return status, phy_port_dict
+
+    def _read_eeprom_specific_bytes(self, sysfsfile_eeprom, offset, num_bytes):
+        print("_read_eeprom_specific_bytes should not be called since the sysfs it dependents on will no longer exist.")
+        print("_read_eeprom_specific_bytes_via_ethtool should be called instead")
+        raise Exception()
+
+    # Read out any bytes from any offset
+    def _read_eeprom_specific_bytes_via_ethtool(self, port_num, offset, num_bytes):
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        eeprom_raw = []
+        ethtool_cmd = "ethtool -m {} hex on offset {} length {}".format(sfpname, offset, num_bytes)
+        try:
+            output = subprocess.check_output(ethtool_cmd, shell=True, universal_newlines=True)
+            output_lines = output.splitlines()
+            first_line_raw = output_lines[0]
+            if "Offset" in first_line_raw:
+                for line in output_lines[2:]:
+                    line_split = line.split()
+                    eeprom_raw = eeprom_raw + line_split[1:]
+        except subprocess.CalledProcessError as e:
+            return None
+
+        return eeprom_raw
+
+    # Read eeprom
+    def _read_eeprom_devid(self, port_num, devid, offset, num_bytes=512):
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            pass
+        elif (self.DOM_EEPROM_ADDR == devid):
+            offset += 256
+
+        eeprom_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, num_bytes)
+
+        return eeprom_raw
+
+    # Read out SFP type, vendor name, PN, REV, SN from eeprom.
+    def get_transceiver_info_dict(self, port_num):
+        transceiver_info_dict = {}
+        compliance_code_dict = {}
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if port_num in self.osfp_ports:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_type_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            # Below part is added to avoid fail the xcvrd, shall be implemented later
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if port_num in self.qsfp_ports:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+                sfp_type = 'QSFP'
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+                sfp_type = 'SFP'
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_INTFACE_BULK_OFFSET), interface_info_bulk_width)
+            if sfp_interface_bulk_raw is not None:
+                sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(sfp_interface_bulk_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_oui_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_OUI_OFFSET), XCVR_VENDOR_OUI_WIDTH)
+            if sfp_vendor_oui_raw is not None:
+                sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(sfp_vendor_oui_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_date_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_DATE_OFFSET), XCVR_VENDOR_DATE_WIDTH)
+            if sfp_vendor_date_raw is not None:
+                sfp_vendor_date_data = sfpi_obj.parse_vendor_date(sfp_vendor_date_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            if sfp_type == 'QSFP':
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_dom_info_dict(self, port_num):
+        transceiver_dom_info_dict = {}
+
+        # Below part is added to avoid failing xcvrd
+        # Currently, the way in which dom data is read has been changed from
+        # using sysfs to using ethtool.
+        # The ethtool returns None for ports without dom support, resulting in
+        # None being returned. However, this fails xcvrd to add the
+        # TRANSCEIVER_DOM_SENSOR table entry of associated port to CONFIG_DB
+        # and then causes SNMP fail.
+        # To address this issue a default dict is initialized with all data set to
+        # 'N/A' and is returned is the above case.
+        # BTW, in the original implementation which sysfs is used to read dom data,
+        # even though non-None data is returned for ports without dom support,
+        # it does not contain valid data. This can result in wrong data in
+        # TRANSCEIVER_DOM_SENSOR table.
+        transceiver_dom_info_dict['temperature'] = 'N/A'
+        transceiver_dom_info_dict['voltage'] = 'N/A'
+        transceiver_dom_info_dict['rx1power'] = 'N/A'
+        transceiver_dom_info_dict['rx2power'] = 'N/A'
+        transceiver_dom_info_dict['rx3power'] = 'N/A'
+        transceiver_dom_info_dict['rx4power'] = 'N/A'
+        transceiver_dom_info_dict['tx1bias'] = 'N/A'
+        transceiver_dom_info_dict['tx2bias'] = 'N/A'
+        transceiver_dom_info_dict['tx3bias'] = 'N/A'
+        transceiver_dom_info_dict['tx4bias'] = 'N/A'
+        transceiver_dom_info_dict['tx1power'] = 'N/A'
+        transceiver_dom_info_dict['tx2power'] = 'N/A'
+        transceiver_dom_info_dict['tx3power'] = 'N/A'
+        transceiver_dom_info_dict['tx4power'] = 'N/A'
+
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            offset = 0
+            offset_xcvr = 128
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset_xcvr + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qspf_dom_capability_data = sfpi_obj.parse_qsfp_dom_capability(qsfp_dom_capability_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_temperature_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_TEMPE_OFFSET), QSFP_TEMPE_WIDTH)
+            if dom_temperature_raw is not None:
+                dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_voltage_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_VOLT_OFFSET), QSFP_VOLT_WIDTH)
+            if dom_voltage_raw is not None:
+                dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            qsfp_dom_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_DOM_REV_OFFSET), QSFP_DOM_REV_WIDTH)
+            if qsfp_dom_rev_raw is not None:
+                qsfp_dom_rev_data = sfpd_obj.parse_sfp_dom_rev(qsfp_dom_rev_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+
+            # The tx_power monitoring is only available on QSFP which compliant with SFF-8636
+            # and claimed that it support tx_power with one indicator bit.
+            dom_channel_monitor_data = {}
+            qsfp_dom_rev = qsfp_dom_rev_data['data']['dom_rev']['value']
+            qsfp_tx_power_support = qspf_dom_capability_data['data']['Tx_power_support']['value']
+            if (qsfp_dom_rev[0:8] != 'SFF-8636' or (qsfp_dom_rev[0:8] == 'SFF-8636' and qsfp_tx_power_support != 'on')):
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+            else:
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+
+                transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TX1Power']['value']
+                transceiver_dom_info_dict['tx2power'] = dom_channel_monitor_data['data']['TX2Power']['value']
+                transceiver_dom_info_dict['tx3power'] = dom_channel_monitor_data['data']['TX3Power']['value']
+                transceiver_dom_info_dict['tx4power'] = dom_channel_monitor_data['data']['TX4Power']['value']
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RX1Power']['value']
+            transceiver_dom_info_dict['rx2power'] = dom_channel_monitor_data['data']['RX2Power']['value']
+            transceiver_dom_info_dict['rx3power'] = dom_channel_monitor_data['data']['RX3Power']['value']
+            transceiver_dom_info_dict['rx4power'] = dom_channel_monitor_data['data']['RX4Power']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_info_dict
+
+            eeprom_domraw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, SFP_I2C_PAGE_SIZE)
+            if eeprom_domraw is None:
+                return transceiver_dom_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                print("no sff8472Dom")
+                return None
+
+            dom_temperature_raw = eeprom_domraw[SFP_TEMPE_OFFSET:SFP_TEMPE_OFFSET+SFP_TEMPE_WIDTH]
+            dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+
+            dom_voltage_raw = eeprom_domraw[SFP_VOLT_OFFSET:SFP_VOLT_OFFSET+SFP_VOLT_WIDTH]
+            dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+
+            dom_channel_monitor_raw = eeprom_domraw[SFP_CHANNL_MON_OFFSET:SFP_CHANNL_MON_OFFSET+SFP_CHANNL_MON_WIDTH]
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RXPower']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TXBias']['value']
+            transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TXPower']['value']
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_dom_threshold_info_dict(self, port_num):
+        transceiver_dom_threshold_info_dict = {}
+
+        dom_info_dict_keys = ['temphighalarm',    'temphighwarning',
+                              'templowalarm',     'templowwarning',
+                              'vcchighalarm',     'vcchighwarning',
+                              'vcclowalarm',      'vcclowwarning',
+                              'rxpowerhighalarm', 'rxpowerhighwarning',
+                              'rxpowerlowalarm',  'rxpowerlowwarning',
+                              'txpowerhighalarm', 'txpowerhighwarning',
+                              'txpowerlowalarm',  'txpowerlowwarning',
+                              'txbiashighalarm',  'txbiashighwarning',
+                              'txbiaslowalarm',   'txbiaslowwarning'
+                              ]
+        transceiver_dom_threshold_info_dict = dict.fromkeys(dom_info_dict_keys, 'N/A')
+
+        if port_num in self.qsfp_ports:
+            # current we don't support qsfp since threshold data is on page 3 and the way to read this page is under discussion.
+            return transceiver_dom_threshold_info_dict
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num,
+                                                                                    (offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                                    SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/thermalutil.py
deleted file mode 120000
index cef21ffa..00000000
--- a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/thermalutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/thermalutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/thermalutil.py
new file mode 100644
index 00000000..980ef8a9
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3700c-r0/plugins/thermalutil.py
@@ -0,0 +1,456 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC Thermal Base API and
+# provides the thermal sensor status which are available in the platform
+#
+#############################################################################
+
+try:
+    from os.path import join
+    import syslog
+    import subprocess
+    from sonic_thermal.thermal_base import ThermalBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_info(msg):
+    syslog.openlog("thermalutil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+THERMAL_DEV_CATEGORY_CPU_CORE = "cpu_core"
+THERMAL_DEV_CATEGORY_CPU_PACK = "cpu_pack"
+THERMAL_DEV_CATEGORY_MODULE = "module"
+THERMAL_DEV_CATEGORY_PSU = "psu"
+THERMAL_DEV_CATEGORY_GEARBOX = "gearbox"
+THERMAL_DEV_CATEGORY_AMBIENT = "ambient"
+
+THERMAL_DEV_ASIC_AMBIENT = "asic_amb"
+THERMAL_DEV_FAN_AMBIENT = "fan_amb"
+THERMAL_DEV_PORT_AMBIENT = "port_amb"
+THERMAL_DEV_COMEX_AMBIENT = "comex_amb"
+THERMAL_DEV_BOARD_AMBIENT = "board_amb"
+
+THERMAL_API_GET_TEMPERATURE = "get_temperature"
+THERMAL_API_GET_HIGH_THRESHOLD = "get_high_threshold"
+THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD = "get_high_critical_threshold"
+
+THERMAL_API_INVALID_HIGH_THRESHOLD = 0.0
+
+HW_MGMT_THERMAL_ROOT = "/var/run/hw-management/thermal/"
+
+thermal_api_handler_cpu_core = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_core{}",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_core{}_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_core{}_crit"
+}
+thermal_api_handler_cpu_pack = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_pack",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_pack_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_pack_crit"
+}
+thermal_api_handler_module = {
+    THERMAL_API_GET_TEMPERATURE: "module{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: "module{}_temp_crit",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "module{}_temp_emergency"
+}
+thermal_api_handler_psu = {
+    THERMAL_API_GET_TEMPERATURE: "psu{}_temp",
+    THERMAL_API_GET_HIGH_THRESHOLD: "psu{}_temp_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_api_handler_gearbox = {
+    THERMAL_API_GET_TEMPERATURE: "gearbox{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: None,
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_ambient_apis = {
+    THERMAL_DEV_ASIC_AMBIENT: "asic",
+    THERMAL_DEV_PORT_AMBIENT: "port_amb",
+    THERMAL_DEV_FAN_AMBIENT: "fan_amb",
+    THERMAL_DEV_COMEX_AMBIENT: "comex_amb",
+    THERMAL_DEV_BOARD_AMBIENT: "board_amb"
+}
+thermal_ambient_name = {
+    THERMAL_DEV_ASIC_AMBIENT: "Ambient ASIC Temp",
+    THERMAL_DEV_PORT_AMBIENT: "Ambient Port Side Temp",
+    THERMAL_DEV_FAN_AMBIENT: "Ambient Fan Side Temp",
+    THERMAL_DEV_COMEX_AMBIENT: "Ambient COMEX Temp",
+    THERMAL_DEV_BOARD_AMBIENT: "Ambient Board Temp"
+}
+thermal_api_handlers = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: thermal_api_handler_cpu_core,
+    THERMAL_DEV_CATEGORY_CPU_PACK: thermal_api_handler_cpu_pack,
+    THERMAL_DEV_CATEGORY_MODULE: thermal_api_handler_module,
+    THERMAL_DEV_CATEGORY_PSU: thermal_api_handler_psu,
+    THERMAL_DEV_CATEGORY_GEARBOX: thermal_api_handler_gearbox
+}
+thermal_name = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: "CPU Core {} Temp",
+    THERMAL_DEV_CATEGORY_CPU_PACK: "CPU Pack Temp",
+    THERMAL_DEV_CATEGORY_MODULE: "xSFP module {} Temp",
+    THERMAL_DEV_CATEGORY_PSU: "PSU-{} Temp",
+    THERMAL_DEV_CATEGORY_GEARBOX: "Gearbox {} Temp"
+}
+
+thermal_device_categories_all = [
+    THERMAL_DEV_CATEGORY_CPU_CORE,
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_MODULE,
+    THERMAL_DEV_CATEGORY_PSU,
+    THERMAL_DEV_CATEGORY_AMBIENT,
+    THERMAL_DEV_CATEGORY_GEARBOX
+]
+
+thermal_device_categories_singleton = [
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_AMBIENT
+]
+thermal_api_names = [
+    THERMAL_API_GET_TEMPERATURE,
+    THERMAL_API_GET_HIGH_THRESHOLD
+]
+
+hwsku_dict_thermal = {'ACS-MSN2700': 0, 'LS-SN2700': 0, 'ACS-MSN2740': 3, 'ACS-MSN2100': 1, 'ACS-MSN2410': 2, 'ACS-MSN2010': 4,
+                      'ACS-MSN3700': 5, 'ACS-MSN3700C': 6, 'Mellanox-SN2700': 0, 'Mellanox-SN2700-D48C8': 0, 'ACS-MSN3800': 7, 'Mellanox-SN3800-D112C8': 7}
+thermal_profile_list = [
+    # 2700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 2100
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 16),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2410
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 56),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2740
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2010
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 22),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 3700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3700c
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3800
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 64),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (1, 32),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+]
+
+
+class Thermal(object):
+    def __init__(self, category, index, has_index):
+        """
+        index should be a string for category ambient and int for other categories
+        """
+        if category == THERMAL_DEV_CATEGORY_AMBIENT:
+            self.name = thermal_ambient_name[index]
+            self.index = index
+        elif has_index:
+            self.name = thermal_name[category].format(index)
+            self.index = index
+        else:
+            self.name = thermal_name[category]
+            self.index = 0
+
+        self.category = category
+        self.temperature = self._get_file_from_api(THERMAL_API_GET_TEMPERATURE)
+        self.high_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_THRESHOLD)
+        self.high_critical_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD)
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+
+        Returns:
+            string: The name of the device
+        """
+        return self.name
+
+    def _read_generic_file(self, filename, len):
+        """
+        Read a generic file, returns the contents of the file
+        """
+        result = None
+        try:
+            with open(filename, 'r') as fileobj:
+                result = fileobj.read()
+        except Exception as e:
+            log_info("Fail to read file {} due to {}".format(filename, repr(e)))
+        return result
+
+    def _get_file_from_api(self, api_name):
+        if self.category == THERMAL_DEV_CATEGORY_AMBIENT:
+            if api_name == THERMAL_API_GET_TEMPERATURE:
+                filename = thermal_ambient_apis[self.index]
+            else:
+                return None
+        else:
+            handler = thermal_api_handlers[self.category][api_name]
+            if self.category in thermal_device_categories_singleton:
+                filename = handler
+            else:
+                if handler:
+                    filename = handler.format(self.index)
+                else:
+                    return None
+        return join(HW_MGMT_THERMAL_ROOT, filename)
+
+    def get_temperature(self):
+        """
+        Retrieves current temperature reading from thermal
+
+        Returns:
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        value_str = self._read_generic_file(self.temperature, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_threshold(self):
+        """
+        Retrieves the high threshold temperature of thermal
+
+        Returns:
+            A float number, the high threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_critical_threshold(self):
+        """
+        Retrieves the high critical threshold temperature of thermal
+
+        Returns:
+            A float number, the high critical threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_critical_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_critical_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+
+class ThermalUtil(ThermalBase):
+    """Platform-specific Thermalutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    number_of_thermals = 0
+    thermal_list = []
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def __init__(self):
+        sku = self._get_sku_name()
+        # create thermal objects for all categories of sensors
+        tp_index = hwsku_dict_thermal[sku]
+        thermal_profile = thermal_profile_list[tp_index]
+        for category in thermal_device_categories_all:
+            if category == THERMAL_DEV_CATEGORY_AMBIENT:
+                count, ambient_list = thermal_profile[category]
+                for ambient in ambient_list:
+                    thermal = Thermal(category, ambient, True)
+                    self.thermal_list.append(thermal)
+            else:
+                start, count = 0, 0
+                if category in thermal_profile:
+                    start, count = thermal_profile[category]
+                    if count == 0:
+                        continue
+                if count == 1:
+                    thermal = Thermal(category, 0, False)
+                    self.thermal_list.append(thermal)
+                else:
+                    for index in range(count):
+                        thermal = Thermal(category, start + index, True)
+                        self.thermal_list.append(thermal)
+        self.number_of_thermals = len(self.thermal_list)
+
+    def get_num_thermals(self):
+        """
+        Retrieves the number of thermal sensors supported on the device
+
+        :return: An integer, the number of thermal sensors supported on the device
+        """
+        return self.number_of_thermals
+
+    def get_name(self, index):
+        """
+        Retrieves the human-readable name of a thermal sensor by 1-based index
+
+        Returns:
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: String,
+            A string representing the name of the thermal sensor. 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_name()
+
+    def get_temperature(self, index):
+        """
+        Retrieves current temperature reading from thermal sensor by 1-based index
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: Float,
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_temperature()
+
+    def get_high_threshold(self, index):
+        """
+        Retrieves the high threshold temperature of thermal by 1-based index
+        Actions should be taken if the temperature becomes higher than the threshold.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_threshold()
+
+    def get_high_critical_threshold(self, index):
+        """
+        Retrieves the high critical threshold temperature of thermal by 1-based index
+        Actions should be taken immediately if the temperature becomes higher than the high critical
+        threshold otherwise the device will be damaged.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high critical threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_critical_threshold()
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/fanutil.py
deleted file mode 120000
index 82ea06ef..00000000
--- a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/fanutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/fanutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/fanutil.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/fanutil.py
new file mode 100644
index 00000000..ee6446e7
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/fanutil.py
@@ -0,0 +1,202 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from glob import glob
+    from sonic_fan.fan_base import FanBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("fanutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class FanUtil(FanBase):
+    """Platform-specific FanUtil class"""
+
+    PWM_MAX = 255
+    MAX_FAN_PER_DRAWER = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    sku_without_fan_direction = ['ACS-MSN2010', 'ACS-MSN2100', 'ACS-MSN2410',
+                                 'ACS-MSN2700', 'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+    sku_with_unpluggable_fan = ['ACS-MSN2010', 'ACS-MSN2100']
+
+    def __init__(self):
+        FanBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.fan_path = "/var/run/hw-management/"
+        if self.sku_name in self.sku_with_unpluggable_fan:
+            self.fan_status = None
+            self.unpluggable_fan = True
+        else:
+            self.fan_status = "thermal/fan{}_status"
+            self.unpluggable_fan = False
+        self.fan_get_speed = "thermal/fan{}_speed_get"
+        self.fan_set_speed = "thermal/fan{}_speed_set"
+        if self.sku_name in self.sku_without_fan_direction:
+            self.fan_direction = None
+        else:
+            self.fan_direction = "system/fan_dir"
+
+        self.fan_led_green = "led/led_fan*_green"
+        self.num_of_fan, self.num_of_drawer = self._extract_num_of_fans_and_fan_drawers()
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def _extract_num_of_fans_and_fan_drawers(self):
+        # So far we don't have files representing the number of fans and drawers
+        # The only way to retrieve the number is to count files.
+        # for number of fans, we get it via couting the speed files.
+        # for number of draws, we get it via couting the green led files.
+        list_of_fan_speed = glob(self.fan_path + self.fan_get_speed.format("*"))
+        num_of_fan = len(list_of_fan_speed)
+        list_of_fan_leds = glob(self.fan_path + self.fan_led_green)
+        num_of_drawer = len(list_of_fan_leds)
+
+        return num_of_fan, num_of_drawer
+
+    def _convert_fan_index_to_drawer_index(self, index):
+        return (index + self.MAX_FAN_PER_DRAWER - 1) / self.MAX_FAN_PER_DRAWER
+
+    def _read_file(self, file_pattern, index=0):
+        """
+        Reads the file of the fan
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the fan of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(os.path.join(self.fan_path, file_pattern.format(index)), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.fan_path + file_pattern.format(index)))
+            return return_value
+
+        return return_value
+
+    def get_num_fans(self):
+        """
+        Retrieves the number of FANs supported on the device
+
+        :return: An integer, the number of FANs supported on the device
+        """
+        return self.num_of_fan
+
+    def get_status(self, index):
+        """
+        Retrieves the operational status of FAN defined
+                by index 1-based <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean,
+            - True if FAN is running with some speed 
+            - False if FAN has stopped running
+        """
+        if not self.get_presence(index):
+            return False
+
+        return self.get_speed(index) != 0
+
+    def get_presence(self, index):
+        """
+        Retrieves the presence status of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: Boolean, True if FAN is plugged, False if not
+        """
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        if self.unpluggable_fan:
+            return True
+
+        draw_index = self._convert_fan_index_to_drawer_index(index)
+        presence = self._read_file(self.fan_status, draw_index)
+
+        return presence != 0
+
+    def get_direction(self, index):
+        """
+        Retrieves the airflow direction of a FAN defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query status
+        :return: string, denoting FAN airflow direction
+        Note:
+            What Mellanox calls forward: 
+            Air flows from fans side to QSFP side, for example: MSN2700-CS2F
+            which means intake in community
+            What Mellanox calls reverse:
+            Air flow from QSFP side to fans side, for example: MSN2700-CS2R
+            which means exhaust in community
+            According to hw-mgmt:
+                1 stands for forward, in other words intake
+                0 stands for reverse, in other words exhaust
+        """
+        if not self.fan_direction:
+            return self.FAN_DIRECTION_NOT_APPLICABLE
+
+        if index > self.num_of_fan:
+            raise RuntimeError(
+                "index ({}) shouldn't be greater than number of fans ({})".format(index, self.num_of_fan))
+
+        drawer_index = self._convert_fan_index_to_drawer_index(index)
+
+        fan_dir_bits = self._read_file(self.fan_direction)
+        fan_mask = 1 << drawer_index - 1
+        if fan_dir_bits & fan_mask:
+            return self.FAN_DIRECTION_INTAKE
+        else:
+            return self.FAN_DIRECTION_EXHAUST
+
+    def get_speed(self, index):
+        """
+        Retrieves the speed of a Front FAN in the tray in revolutions per minute defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the FAN of which to query speed
+        :return: integer, denoting front FAN speed
+        """
+        speed = self._read_file(self.fan_get_speed, index)
+
+        return speed
+
+    def set_speed(self, val):
+        """
+        Sets the speed of all the FANs to a value denoted by the duty-cycle percentage val
+
+        :param val: An integer, <0-100> denoting FAN duty cycle percentage 
+        :return: Boolean, True if operation is successful, False if not
+        """
+        status = True
+        pwm = int(round(self.PWM_MAX*val/100.0))
+
+        try:
+            with open(os.path.join(self.fan_path, self.fan_set_speed.format(1)), 'w') as fan_pwm:
+                fan_pwm.write(str(pwm))
+        except (ValueError, IOError):
+            log_err("Read file {} failed".format(self.fan_path + self.fan_set_speed.format(1)))
+            status = False
+
+        return status
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/psuutil.py
deleted file mode 120000
index 9f724238..00000000
--- a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/psuutil.py
new file mode 100644
index 00000000..6da5770c
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/psuutil.py
@@ -0,0 +1,184 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from sonic_psu.psu_base import PsuBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("psuutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class PsuUtil(PsuBase):
+    """Platform-specific PSUutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    # for spectrum1 switches with plugable PSUs, the output voltage file is psuX_volt
+    # for spectrum2 switches the output voltage file is psuX_volt_out2
+    sku_spectrum1_with_plugable_psu = ['ACS-MSN2410', 'ACS-MSN2700',
+                                       'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+
+    def __init__(self):
+        PsuBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.psu_path = "/var/run/hw-management/"
+        self.psu_presence = "thermal/psu{}_status"
+        self.psu_oper_status = "thermal/psu{}_pwr_status"
+        self.psu_current = "power/psu{}_curr"
+        self.psu_power = "power/psu{}_power"
+        if self.sku_name in self.sku_spectrum1_with_plugable_psu:
+            self.psu_voltage = "power/psu{}_volt"
+        else:
+            self.psu_voltage = "power/psu{}_volt_out2"
+        self.fan_speed = "thermal/psu{}_fan1_speed_get"
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def get_num_psus(self):
+        """
+        Retrieves the number of PSUs available on the device
+
+        :return: An integer, the number of PSUs available on the device
+        """
+        return self.MAX_NUM_PSU
+
+    def _read_file(self, file_pattern, index):
+        """
+        Reads the file of the PSU
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(self.psu_path + file_pattern.format(index), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.psu_path + file_pattern.format(index)))
+            return 0
+
+        return return_value
+
+    def get_psu_status(self, index):
+        """
+        Retrieves the oprational status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is operating properly, False if PSU is faulty
+        """
+        if index is None:
+            return False
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_oper_status, index)
+
+        return status == 1
+
+    def get_psu_presence(self, index):
+        """
+        Retrieves the presence status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is plugged, False if not
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_presence, index)
+
+        return status == 1
+
+    def get_output_voltage(self, index):
+        """
+        Retrieves the ouput volatage in milli volts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p volatge
+        :return: An integer, value of o/p voltage in mV if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        voltage = self._read_file(self.psu_voltage, index)
+
+        return voltage
+
+    def get_output_current(self, index):
+        """
+        Retrieves the output current in milli amperes of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p current
+        :return: An integer, value of o/p current in mA if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        current = self._read_file(self.psu_current, index)
+
+        return current
+
+    def get_output_power(self, index):
+        """
+        Retrieves the output power in micro watts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p power
+        :return: An integer, value of o/p power in micro Watts if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        power = self._read_file(self.psu_power, index)
+
+        return power
+
+    def get_fan_speed(self, index, fan_index):
+        """
+        Retrieves the speed of fan, in rpm, denoted by 1-based <fan_index> of a power 
+                supply unit (PSU) defined by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query fan speed
+        :param fan_index: An integer, 1-based index of the PSU-fan of which to query speed
+        :return: An integer, value of PSU-fan speed in rpm if PSU-fan is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if fan_index > self.MAX_PSU_FAN:
+            raise RuntimeError("fan_index ({}) shouldn't be greater than {}".format(fan_index, self.MAX_PSU_FAN))
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        fan_speed = self._read_file(self.fan_speed, index)
+
+        return fan_speed
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfputil.py
deleted file mode 120000
index 45909b88..00000000
--- a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfputil.py
new file mode 100644
index 00000000..954ed23d
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/sfputil.py
@@ -0,0 +1,688 @@
+# sfputil.py
+#
+# Platform-specific SFP transceiver interface for SONiC
+#
+
+try:
+    import time
+    import subprocess
+    from sonic_sfp.sfputilbase import *
+    import syslog
+except ImportError as e:
+    raise ImportError("%s - required module not found" % str(e))
+
+# sfp supports dom
+XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT = 0x40
+
+# sfp module threshold offset and width
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+
+# I2C page size for sfp
+SFP_I2C_PAGE_SIZE = 256
+
+# parameters for DB connection
+REDIS_TIMEOUT_USECS = 0
+
+# parameters for SFP presence
+SFP_STATUS_INSERTED = '1'
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+GET_PLATFORM_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.platform"
+
+# Ethernet<n> <=> sfp<n+SFP_PORT_NAME_OFFSET>
+SFP_PORT_NAME_OFFSET = 0
+SFP_PORT_NAME_CONVENTION = "sfp{}"
+
+# magic code defnition for port number, qsfp port position of each platform
+# port_position_tuple = (PORT_START, QSFP_PORT_START, PORT_END, PORT_IN_BLOCK, EEPROM_OFFSET)
+platform_dict = {'x86_64-mlnx_msn2700-r0': 0, 'x86_64-mlnx_msn2740-r0': 0, 'x86_64-mlnx_msn2100-r0': 1, 'x86_64-mlnx_msn2410-r0': 2, 'x86_64-mlnx_msn2010-r0': 3,
+                 'x86_64-mlnx_msn3420-r0': 5, 'x86_64-mlnx_msn3700-r0': 0, 'x86_64-mlnx_msn3700c-r0': 0, 'x86_64-mlnx_msn3800-r0': 4, 'x86_64-mlnx_msn4600c': 4, 'x86_64-mlnx_msn4700-r0': 0}
+port_position_tuple_list = [(0, 0, 31, 32, 1), (0, 0, 15, 16, 1), (0, 48, 55, 56, 1),
+                            (0, 18, 21, 22, 1), (0, 0, 63, 64, 1), (0, 48, 59, 60, 1)]
+
+
+def log_info(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+def log_err(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class SfpUtil(SfpUtilBase):
+    """Platform-specific SfpUtil class"""
+    PORT_START = 0
+    QSFP_PORT_START = 0
+    PORT_END = 0
+    PORTS_IN_BLOCK = 0
+    EEPROM_OFFSET = 0
+
+    db_sel = None
+    db_sel_timeout = None
+    db_sel_object = None
+    db_sel_tbl = None
+    state_db = None
+    sfpd_status_tbl = None
+
+    @property
+    def port_start(self):
+        return self.PORT_START
+
+    @property
+    def port_end(self):
+        return self.PORT_END
+
+    @property
+    def qsfp_ports(self):
+        return list(range(self.QSFP_PORT_START, self.PORTS_IN_BLOCK + 1))
+
+    @property
+    def port_to_eeprom_mapping(self):
+        print("dependency on sysfs has been removed")
+        raise Exception()
+
+    def get_port_position_tuple_by_platform_name(self):
+        p = subprocess.Popen(GET_PLATFORM_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        position_tuple = port_position_tuple_list[platform_dict[out.rstrip('\n')]]
+        return position_tuple
+
+    def __init__(self):
+        port_position_tuple = self.get_port_position_tuple_by_platform_name()
+        self.PORT_START = port_position_tuple[0] + 1
+        self.QSFP_PORT_START = port_position_tuple[1] + 1
+        self.PORT_END = port_position_tuple[2] + 1
+        self.PORTS_IN_BLOCK = port_position_tuple[3]
+        self.EEPROM_OFFSET = port_position_tuple[4]
+        self.mlnx_sfpd_started = False
+
+        SfpUtilBase.__init__(self)
+
+    def get_presence(self, port_num):
+        presence = False
+
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return presence
+
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        ethtool_cmd = "ethtool -m {} 2>/dev/null".format(sfpname)
+        try:
+            proc = subprocess.Popen(ethtool_cmd, stdout=subprocess.PIPE, shell=True, universal_newlines=True, stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+            if result != '':
+                presence = True
+
+        except OSError as e:
+            return presence
+
+        return presence
+
+    def get_low_power_mode(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmget.py {}".format(port_num)
+
+        try:
+            output = subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            if 'LPM ON' in output:
+                return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to get LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def set_low_power_mode(self, port_num, lpmode):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        curr_lpmode = self.get_low_power_mode(port_num)
+        if curr_lpmode == lpmode:
+            return True
+
+        # Compose LPM command
+        lpm = 'on' if lpmode else 'off'
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmset.py {} {}".format(port_num, lpm)
+
+        # Set LPM
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return True
+
+    def reset(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfpreset.py {}".format(port_num)
+
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def get_transceiver_change_event(self, timeout=0):
+        phy_port_dict = {}
+        status = True
+
+        if self.db_sel is None:
+            from swsscommon import swsscommon
+            self.state_db = swsscommon.DBConnector("STATE_DB",
+                                                   REDIS_TIMEOUT_USECS,
+                                                   True)
+
+            # Subscribe to state table for SFP change notifications
+            self.db_sel = swsscommon.Select()
+            self.db_sel_tbl = swsscommon.NotificationConsumer(self.state_db, 'TRANSCEIVER_NOTIFY')
+            self.db_sel.addSelectable(self.db_sel_tbl)
+            self.db_sel_timeout = swsscommon.Select.TIMEOUT
+            self.db_sel_object = swsscommon.Select.OBJECT
+            self.sfpd_status_tbl = swsscommon.Table(self.state_db, 'MLNX_SFPD_TASK')
+
+        # Check the liveness of mlnx-sfpd, if it failed, return system_fail event
+        # If mlnx-sfpd not started, return system_not_ready event
+        keys = self.sfpd_status_tbl.getKeys()
+        if 'LIVENESS' not in keys:
+            if self.mlnx_sfpd_started:
+                log_err("mlnx-sfpd exited, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_FAIL
+                return False, phy_port_dict
+            else:
+                log_info("mlnx-sfpd not ready, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_NOT_READY
+                return False, phy_port_dict
+        else:
+            if not self.mlnx_sfpd_started:
+                self.mlnx_sfpd_started = True
+                log_info("mlnx-sfpd is running")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_READY
+                return False, phy_port_dict
+
+        if timeout:
+            (state, c) = self.db_sel.select(timeout)
+        else:
+            (state, c) = self.db_sel.select()
+
+        if state == self.db_sel_timeout:
+            status = True
+        elif state != self.db_sel_object:
+            status = False
+        else:
+            (key, op, fvp) = self.db_sel_tbl.pop()
+            phy_port_dict[key] = op
+
+        return status, phy_port_dict
+
+    def _read_eeprom_specific_bytes(self, sysfsfile_eeprom, offset, num_bytes):
+        print("_read_eeprom_specific_bytes should not be called since the sysfs it dependents on will no longer exist.")
+        print("_read_eeprom_specific_bytes_via_ethtool should be called instead")
+        raise Exception()
+
+    # Read out any bytes from any offset
+    def _read_eeprom_specific_bytes_via_ethtool(self, port_num, offset, num_bytes):
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        eeprom_raw = []
+        ethtool_cmd = "ethtool -m {} hex on offset {} length {}".format(sfpname, offset, num_bytes)
+        try:
+            output = subprocess.check_output(ethtool_cmd, shell=True, universal_newlines=True)
+            output_lines = output.splitlines()
+            first_line_raw = output_lines[0]
+            if "Offset" in first_line_raw:
+                for line in output_lines[2:]:
+                    line_split = line.split()
+                    eeprom_raw = eeprom_raw + line_split[1:]
+        except subprocess.CalledProcessError as e:
+            return None
+
+        return eeprom_raw
+
+    # Read eeprom
+    def _read_eeprom_devid(self, port_num, devid, offset, num_bytes=512):
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            pass
+        elif (self.DOM_EEPROM_ADDR == devid):
+            offset += 256
+
+        eeprom_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, num_bytes)
+
+        return eeprom_raw
+
+    # Read out SFP type, vendor name, PN, REV, SN from eeprom.
+    def get_transceiver_info_dict(self, port_num):
+        transceiver_info_dict = {}
+        compliance_code_dict = {}
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if port_num in self.osfp_ports:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_type_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            # Below part is added to avoid fail the xcvrd, shall be implemented later
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if port_num in self.qsfp_ports:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+                sfp_type = 'QSFP'
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+                sfp_type = 'SFP'
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_INTFACE_BULK_OFFSET), interface_info_bulk_width)
+            if sfp_interface_bulk_raw is not None:
+                sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(sfp_interface_bulk_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_oui_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_OUI_OFFSET), XCVR_VENDOR_OUI_WIDTH)
+            if sfp_vendor_oui_raw is not None:
+                sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(sfp_vendor_oui_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_date_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_DATE_OFFSET), XCVR_VENDOR_DATE_WIDTH)
+            if sfp_vendor_date_raw is not None:
+                sfp_vendor_date_data = sfpi_obj.parse_vendor_date(sfp_vendor_date_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            if sfp_type == 'QSFP':
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_dom_info_dict(self, port_num):
+        transceiver_dom_info_dict = {}
+
+        # Below part is added to avoid failing xcvrd
+        # Currently, the way in which dom data is read has been changed from
+        # using sysfs to using ethtool.
+        # The ethtool returns None for ports without dom support, resulting in
+        # None being returned. However, this fails xcvrd to add the
+        # TRANSCEIVER_DOM_SENSOR table entry of associated port to CONFIG_DB
+        # and then causes SNMP fail.
+        # To address this issue a default dict is initialized with all data set to
+        # 'N/A' and is returned is the above case.
+        # BTW, in the original implementation which sysfs is used to read dom data,
+        # even though non-None data is returned for ports without dom support,
+        # it does not contain valid data. This can result in wrong data in
+        # TRANSCEIVER_DOM_SENSOR table.
+        transceiver_dom_info_dict['temperature'] = 'N/A'
+        transceiver_dom_info_dict['voltage'] = 'N/A'
+        transceiver_dom_info_dict['rx1power'] = 'N/A'
+        transceiver_dom_info_dict['rx2power'] = 'N/A'
+        transceiver_dom_info_dict['rx3power'] = 'N/A'
+        transceiver_dom_info_dict['rx4power'] = 'N/A'
+        transceiver_dom_info_dict['tx1bias'] = 'N/A'
+        transceiver_dom_info_dict['tx2bias'] = 'N/A'
+        transceiver_dom_info_dict['tx3bias'] = 'N/A'
+        transceiver_dom_info_dict['tx4bias'] = 'N/A'
+        transceiver_dom_info_dict['tx1power'] = 'N/A'
+        transceiver_dom_info_dict['tx2power'] = 'N/A'
+        transceiver_dom_info_dict['tx3power'] = 'N/A'
+        transceiver_dom_info_dict['tx4power'] = 'N/A'
+
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            offset = 0
+            offset_xcvr = 128
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset_xcvr + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qspf_dom_capability_data = sfpi_obj.parse_qsfp_dom_capability(qsfp_dom_capability_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_temperature_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_TEMPE_OFFSET), QSFP_TEMPE_WIDTH)
+            if dom_temperature_raw is not None:
+                dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_voltage_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_VOLT_OFFSET), QSFP_VOLT_WIDTH)
+            if dom_voltage_raw is not None:
+                dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            qsfp_dom_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_DOM_REV_OFFSET), QSFP_DOM_REV_WIDTH)
+            if qsfp_dom_rev_raw is not None:
+                qsfp_dom_rev_data = sfpd_obj.parse_sfp_dom_rev(qsfp_dom_rev_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+
+            # The tx_power monitoring is only available on QSFP which compliant with SFF-8636
+            # and claimed that it support tx_power with one indicator bit.
+            dom_channel_monitor_data = {}
+            qsfp_dom_rev = qsfp_dom_rev_data['data']['dom_rev']['value']
+            qsfp_tx_power_support = qspf_dom_capability_data['data']['Tx_power_support']['value']
+            if (qsfp_dom_rev[0:8] != 'SFF-8636' or (qsfp_dom_rev[0:8] == 'SFF-8636' and qsfp_tx_power_support != 'on')):
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+            else:
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+
+                transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TX1Power']['value']
+                transceiver_dom_info_dict['tx2power'] = dom_channel_monitor_data['data']['TX2Power']['value']
+                transceiver_dom_info_dict['tx3power'] = dom_channel_monitor_data['data']['TX3Power']['value']
+                transceiver_dom_info_dict['tx4power'] = dom_channel_monitor_data['data']['TX4Power']['value']
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RX1Power']['value']
+            transceiver_dom_info_dict['rx2power'] = dom_channel_monitor_data['data']['RX2Power']['value']
+            transceiver_dom_info_dict['rx3power'] = dom_channel_monitor_data['data']['RX3Power']['value']
+            transceiver_dom_info_dict['rx4power'] = dom_channel_monitor_data['data']['RX4Power']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_info_dict
+
+            eeprom_domraw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, SFP_I2C_PAGE_SIZE)
+            if eeprom_domraw is None:
+                return transceiver_dom_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                print("no sff8472Dom")
+                return None
+
+            dom_temperature_raw = eeprom_domraw[SFP_TEMPE_OFFSET:SFP_TEMPE_OFFSET+SFP_TEMPE_WIDTH]
+            dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+
+            dom_voltage_raw = eeprom_domraw[SFP_VOLT_OFFSET:SFP_VOLT_OFFSET+SFP_VOLT_WIDTH]
+            dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+
+            dom_channel_monitor_raw = eeprom_domraw[SFP_CHANNL_MON_OFFSET:SFP_CHANNL_MON_OFFSET+SFP_CHANNL_MON_WIDTH]
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RXPower']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TXBias']['value']
+            transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TXPower']['value']
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_dom_threshold_info_dict(self, port_num):
+        transceiver_dom_threshold_info_dict = {}
+
+        dom_info_dict_keys = ['temphighalarm',    'temphighwarning',
+                              'templowalarm',     'templowwarning',
+                              'vcchighalarm',     'vcchighwarning',
+                              'vcclowalarm',      'vcclowwarning',
+                              'rxpowerhighalarm', 'rxpowerhighwarning',
+                              'rxpowerlowalarm',  'rxpowerlowwarning',
+                              'txpowerhighalarm', 'txpowerhighwarning',
+                              'txpowerlowalarm',  'txpowerlowwarning',
+                              'txbiashighalarm',  'txbiashighwarning',
+                              'txbiaslowalarm',   'txbiaslowwarning'
+                              ]
+        transceiver_dom_threshold_info_dict = dict.fromkeys(dom_info_dict_keys, 'N/A')
+
+        if port_num in self.qsfp_ports:
+            # current we don't support qsfp since threshold data is on page 3 and the way to read this page is under discussion.
+            return transceiver_dom_threshold_info_dict
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num,
+                                                                                    (offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                                    SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/thermalutil.py
deleted file mode 120000
index cef21ffa..00000000
--- a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/thermalutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/thermalutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/thermalutil.py b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/thermalutil.py
new file mode 100644
index 00000000..980ef8a9
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn3800-r0/plugins/thermalutil.py
@@ -0,0 +1,456 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC Thermal Base API and
+# provides the thermal sensor status which are available in the platform
+#
+#############################################################################
+
+try:
+    from os.path import join
+    import syslog
+    import subprocess
+    from sonic_thermal.thermal_base import ThermalBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_info(msg):
+    syslog.openlog("thermalutil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+THERMAL_DEV_CATEGORY_CPU_CORE = "cpu_core"
+THERMAL_DEV_CATEGORY_CPU_PACK = "cpu_pack"
+THERMAL_DEV_CATEGORY_MODULE = "module"
+THERMAL_DEV_CATEGORY_PSU = "psu"
+THERMAL_DEV_CATEGORY_GEARBOX = "gearbox"
+THERMAL_DEV_CATEGORY_AMBIENT = "ambient"
+
+THERMAL_DEV_ASIC_AMBIENT = "asic_amb"
+THERMAL_DEV_FAN_AMBIENT = "fan_amb"
+THERMAL_DEV_PORT_AMBIENT = "port_amb"
+THERMAL_DEV_COMEX_AMBIENT = "comex_amb"
+THERMAL_DEV_BOARD_AMBIENT = "board_amb"
+
+THERMAL_API_GET_TEMPERATURE = "get_temperature"
+THERMAL_API_GET_HIGH_THRESHOLD = "get_high_threshold"
+THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD = "get_high_critical_threshold"
+
+THERMAL_API_INVALID_HIGH_THRESHOLD = 0.0
+
+HW_MGMT_THERMAL_ROOT = "/var/run/hw-management/thermal/"
+
+thermal_api_handler_cpu_core = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_core{}",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_core{}_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_core{}_crit"
+}
+thermal_api_handler_cpu_pack = {
+    THERMAL_API_GET_TEMPERATURE: "cpu_pack",
+    THERMAL_API_GET_HIGH_THRESHOLD: "cpu_pack_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "cpu_pack_crit"
+}
+thermal_api_handler_module = {
+    THERMAL_API_GET_TEMPERATURE: "module{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: "module{}_temp_crit",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: "module{}_temp_emergency"
+}
+thermal_api_handler_psu = {
+    THERMAL_API_GET_TEMPERATURE: "psu{}_temp",
+    THERMAL_API_GET_HIGH_THRESHOLD: "psu{}_temp_max",
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_api_handler_gearbox = {
+    THERMAL_API_GET_TEMPERATURE: "gearbox{}_temp_input",
+    THERMAL_API_GET_HIGH_THRESHOLD: None,
+    THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD: None
+}
+thermal_ambient_apis = {
+    THERMAL_DEV_ASIC_AMBIENT: "asic",
+    THERMAL_DEV_PORT_AMBIENT: "port_amb",
+    THERMAL_DEV_FAN_AMBIENT: "fan_amb",
+    THERMAL_DEV_COMEX_AMBIENT: "comex_amb",
+    THERMAL_DEV_BOARD_AMBIENT: "board_amb"
+}
+thermal_ambient_name = {
+    THERMAL_DEV_ASIC_AMBIENT: "Ambient ASIC Temp",
+    THERMAL_DEV_PORT_AMBIENT: "Ambient Port Side Temp",
+    THERMAL_DEV_FAN_AMBIENT: "Ambient Fan Side Temp",
+    THERMAL_DEV_COMEX_AMBIENT: "Ambient COMEX Temp",
+    THERMAL_DEV_BOARD_AMBIENT: "Ambient Board Temp"
+}
+thermal_api_handlers = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: thermal_api_handler_cpu_core,
+    THERMAL_DEV_CATEGORY_CPU_PACK: thermal_api_handler_cpu_pack,
+    THERMAL_DEV_CATEGORY_MODULE: thermal_api_handler_module,
+    THERMAL_DEV_CATEGORY_PSU: thermal_api_handler_psu,
+    THERMAL_DEV_CATEGORY_GEARBOX: thermal_api_handler_gearbox
+}
+thermal_name = {
+    THERMAL_DEV_CATEGORY_CPU_CORE: "CPU Core {} Temp",
+    THERMAL_DEV_CATEGORY_CPU_PACK: "CPU Pack Temp",
+    THERMAL_DEV_CATEGORY_MODULE: "xSFP module {} Temp",
+    THERMAL_DEV_CATEGORY_PSU: "PSU-{} Temp",
+    THERMAL_DEV_CATEGORY_GEARBOX: "Gearbox {} Temp"
+}
+
+thermal_device_categories_all = [
+    THERMAL_DEV_CATEGORY_CPU_CORE,
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_MODULE,
+    THERMAL_DEV_CATEGORY_PSU,
+    THERMAL_DEV_CATEGORY_AMBIENT,
+    THERMAL_DEV_CATEGORY_GEARBOX
+]
+
+thermal_device_categories_singleton = [
+    THERMAL_DEV_CATEGORY_CPU_PACK,
+    THERMAL_DEV_CATEGORY_AMBIENT
+]
+thermal_api_names = [
+    THERMAL_API_GET_TEMPERATURE,
+    THERMAL_API_GET_HIGH_THRESHOLD
+]
+
+hwsku_dict_thermal = {'ACS-MSN2700': 0, 'LS-SN2700': 0, 'ACS-MSN2740': 3, 'ACS-MSN2100': 1, 'ACS-MSN2410': 2, 'ACS-MSN2010': 4,
+                      'ACS-MSN3700': 5, 'ACS-MSN3700C': 6, 'Mellanox-SN2700': 0, 'Mellanox-SN2700-D48C8': 0, 'ACS-MSN3800': 7, 'Mellanox-SN3800-D112C8': 7}
+thermal_profile_list = [
+    # 2700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 2100
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 16),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2410
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 56),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2740
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 2010
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 22),
+        THERMAL_DEV_CATEGORY_PSU: (0, 0),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 0),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT,
+                                       ]
+                                       )
+    },
+    # 3700
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3700c
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 2),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 32),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (0, 0),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+    # 3800
+    {
+        THERMAL_DEV_CATEGORY_CPU_CORE: (0, 4),
+        THERMAL_DEV_CATEGORY_MODULE: (1, 64),
+        THERMAL_DEV_CATEGORY_PSU: (1, 2),
+        THERMAL_DEV_CATEGORY_CPU_PACK: (0, 1),
+        THERMAL_DEV_CATEGORY_GEARBOX: (1, 32),
+        THERMAL_DEV_CATEGORY_AMBIENT: (0,
+                                       [
+                                           THERMAL_DEV_ASIC_AMBIENT,
+                                           THERMAL_DEV_COMEX_AMBIENT,
+                                           THERMAL_DEV_PORT_AMBIENT,
+                                           THERMAL_DEV_FAN_AMBIENT
+                                       ]
+                                       )
+    },
+]
+
+
+class Thermal(object):
+    def __init__(self, category, index, has_index):
+        """
+        index should be a string for category ambient and int for other categories
+        """
+        if category == THERMAL_DEV_CATEGORY_AMBIENT:
+            self.name = thermal_ambient_name[index]
+            self.index = index
+        elif has_index:
+            self.name = thermal_name[category].format(index)
+            self.index = index
+        else:
+            self.name = thermal_name[category]
+            self.index = 0
+
+        self.category = category
+        self.temperature = self._get_file_from_api(THERMAL_API_GET_TEMPERATURE)
+        self.high_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_THRESHOLD)
+        self.high_critical_threshold = self._get_file_from_api(THERMAL_API_GET_HIGH_CRITICAL_THRESHOLD)
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+
+        Returns:
+            string: The name of the device
+        """
+        return self.name
+
+    def _read_generic_file(self, filename, len):
+        """
+        Read a generic file, returns the contents of the file
+        """
+        result = None
+        try:
+            with open(filename, 'r') as fileobj:
+                result = fileobj.read()
+        except Exception as e:
+            log_info("Fail to read file {} due to {}".format(filename, repr(e)))
+        return result
+
+    def _get_file_from_api(self, api_name):
+        if self.category == THERMAL_DEV_CATEGORY_AMBIENT:
+            if api_name == THERMAL_API_GET_TEMPERATURE:
+                filename = thermal_ambient_apis[self.index]
+            else:
+                return None
+        else:
+            handler = thermal_api_handlers[self.category][api_name]
+            if self.category in thermal_device_categories_singleton:
+                filename = handler
+            else:
+                if handler:
+                    filename = handler.format(self.index)
+                else:
+                    return None
+        return join(HW_MGMT_THERMAL_ROOT, filename)
+
+    def get_temperature(self):
+        """
+        Retrieves current temperature reading from thermal
+
+        Returns:
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        value_str = self._read_generic_file(self.temperature, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_threshold(self):
+        """
+        Retrieves the high threshold temperature of thermal
+
+        Returns:
+            A float number, the high threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+    def get_high_critical_threshold(self):
+        """
+        Retrieves the high critical threshold temperature of thermal
+
+        Returns:
+            A float number, the high critical threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.high_critical_threshold is None:
+            return None
+        value_str = self._read_generic_file(self.high_critical_threshold, 0)
+        if value_str is None:
+            return None
+        value_float = float(value_str)
+        if self.category == THERMAL_DEV_CATEGORY_MODULE and value_float == THERMAL_API_INVALID_HIGH_THRESHOLD:
+            return None
+        return value_float / 1000.0
+
+
+class ThermalUtil(ThermalBase):
+    """Platform-specific Thermalutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    number_of_thermals = 0
+    thermal_list = []
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def __init__(self):
+        sku = self._get_sku_name()
+        # create thermal objects for all categories of sensors
+        tp_index = hwsku_dict_thermal[sku]
+        thermal_profile = thermal_profile_list[tp_index]
+        for category in thermal_device_categories_all:
+            if category == THERMAL_DEV_CATEGORY_AMBIENT:
+                count, ambient_list = thermal_profile[category]
+                for ambient in ambient_list:
+                    thermal = Thermal(category, ambient, True)
+                    self.thermal_list.append(thermal)
+            else:
+                start, count = 0, 0
+                if category in thermal_profile:
+                    start, count = thermal_profile[category]
+                    if count == 0:
+                        continue
+                if count == 1:
+                    thermal = Thermal(category, 0, False)
+                    self.thermal_list.append(thermal)
+                else:
+                    for index in range(count):
+                        thermal = Thermal(category, start + index, True)
+                        self.thermal_list.append(thermal)
+        self.number_of_thermals = len(self.thermal_list)
+
+    def get_num_thermals(self):
+        """
+        Retrieves the number of thermal sensors supported on the device
+
+        :return: An integer, the number of thermal sensors supported on the device
+        """
+        return self.number_of_thermals
+
+    def get_name(self, index):
+        """
+        Retrieves the human-readable name of a thermal sensor by 1-based index
+
+        Returns:
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: String,
+            A string representing the name of the thermal sensor. 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_name()
+
+    def get_temperature(self, index):
+        """
+        Retrieves current temperature reading from thermal sensor by 1-based index
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: Float,
+            A float number of current temperature in Celsius up to nearest thousandth
+            of one degree Celsius, e.g. 30.125 
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_temperature()
+
+    def get_high_threshold(self, index):
+        """
+        Retrieves the high threshold temperature of thermal by 1-based index
+        Actions should be taken if the temperature becomes higher than the threshold.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_threshold()
+
+    def get_high_critical_threshold(self, index):
+        """
+        Retrieves the high critical threshold temperature of thermal by 1-based index
+        Actions should be taken immediately if the temperature becomes higher than the high critical
+        threshold otherwise the device will be damaged.
+
+        :param index: An integer, 1-based index of the thermal sensor of which to query status
+        :return: A float number, the high critical threshold temperature of thermal in Celsius
+                 up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if index >= self.number_of_thermals:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.number_of_thermals))
+        return self.thermal_list[index].get_high_critical_threshold()
diff --git a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/psuutil.py
deleted file mode 120000
index 9f724238..00000000
--- a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/psuutil.py
new file mode 100644
index 00000000..6da5770c
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/psuutil.py
@@ -0,0 +1,184 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from sonic_psu.psu_base import PsuBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("psuutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class PsuUtil(PsuBase):
+    """Platform-specific PSUutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    # for spectrum1 switches with plugable PSUs, the output voltage file is psuX_volt
+    # for spectrum2 switches the output voltage file is psuX_volt_out2
+    sku_spectrum1_with_plugable_psu = ['ACS-MSN2410', 'ACS-MSN2700',
+                                       'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+
+    def __init__(self):
+        PsuBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.psu_path = "/var/run/hw-management/"
+        self.psu_presence = "thermal/psu{}_status"
+        self.psu_oper_status = "thermal/psu{}_pwr_status"
+        self.psu_current = "power/psu{}_curr"
+        self.psu_power = "power/psu{}_power"
+        if self.sku_name in self.sku_spectrum1_with_plugable_psu:
+            self.psu_voltage = "power/psu{}_volt"
+        else:
+            self.psu_voltage = "power/psu{}_volt_out2"
+        self.fan_speed = "thermal/psu{}_fan1_speed_get"
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def get_num_psus(self):
+        """
+        Retrieves the number of PSUs available on the device
+
+        :return: An integer, the number of PSUs available on the device
+        """
+        return self.MAX_NUM_PSU
+
+    def _read_file(self, file_pattern, index):
+        """
+        Reads the file of the PSU
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(self.psu_path + file_pattern.format(index), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.psu_path + file_pattern.format(index)))
+            return 0
+
+        return return_value
+
+    def get_psu_status(self, index):
+        """
+        Retrieves the oprational status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is operating properly, False if PSU is faulty
+        """
+        if index is None:
+            return False
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_oper_status, index)
+
+        return status == 1
+
+    def get_psu_presence(self, index):
+        """
+        Retrieves the presence status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is plugged, False if not
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_presence, index)
+
+        return status == 1
+
+    def get_output_voltage(self, index):
+        """
+        Retrieves the ouput volatage in milli volts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p volatge
+        :return: An integer, value of o/p voltage in mV if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        voltage = self._read_file(self.psu_voltage, index)
+
+        return voltage
+
+    def get_output_current(self, index):
+        """
+        Retrieves the output current in milli amperes of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p current
+        :return: An integer, value of o/p current in mA if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        current = self._read_file(self.psu_current, index)
+
+        return current
+
+    def get_output_power(self, index):
+        """
+        Retrieves the output power in micro watts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p power
+        :return: An integer, value of o/p power in micro Watts if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        power = self._read_file(self.psu_power, index)
+
+        return power
+
+    def get_fan_speed(self, index, fan_index):
+        """
+        Retrieves the speed of fan, in rpm, denoted by 1-based <fan_index> of a power 
+                supply unit (PSU) defined by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query fan speed
+        :param fan_index: An integer, 1-based index of the PSU-fan of which to query speed
+        :return: An integer, value of PSU-fan speed in rpm if PSU-fan is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if fan_index > self.MAX_PSU_FAN:
+            raise RuntimeError("fan_index ({}) shouldn't be greater than {}".format(fan_index, self.MAX_PSU_FAN))
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        fan_speed = self._read_file(self.fan_speed, index)
+
+        return fan_speed
diff --git a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4410-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/psuutil.py
deleted file mode 120000
index 9f724238..00000000
--- a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/psuutil.py
new file mode 100644
index 00000000..6da5770c
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/psuutil.py
@@ -0,0 +1,184 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from sonic_psu.psu_base import PsuBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("psuutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class PsuUtil(PsuBase):
+    """Platform-specific PSUutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    # for spectrum1 switches with plugable PSUs, the output voltage file is psuX_volt
+    # for spectrum2 switches the output voltage file is psuX_volt_out2
+    sku_spectrum1_with_plugable_psu = ['ACS-MSN2410', 'ACS-MSN2700',
+                                       'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+
+    def __init__(self):
+        PsuBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.psu_path = "/var/run/hw-management/"
+        self.psu_presence = "thermal/psu{}_status"
+        self.psu_oper_status = "thermal/psu{}_pwr_status"
+        self.psu_current = "power/psu{}_curr"
+        self.psu_power = "power/psu{}_power"
+        if self.sku_name in self.sku_spectrum1_with_plugable_psu:
+            self.psu_voltage = "power/psu{}_volt"
+        else:
+            self.psu_voltage = "power/psu{}_volt_out2"
+        self.fan_speed = "thermal/psu{}_fan1_speed_get"
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def get_num_psus(self):
+        """
+        Retrieves the number of PSUs available on the device
+
+        :return: An integer, the number of PSUs available on the device
+        """
+        return self.MAX_NUM_PSU
+
+    def _read_file(self, file_pattern, index):
+        """
+        Reads the file of the PSU
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(self.psu_path + file_pattern.format(index), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.psu_path + file_pattern.format(index)))
+            return 0
+
+        return return_value
+
+    def get_psu_status(self, index):
+        """
+        Retrieves the oprational status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is operating properly, False if PSU is faulty
+        """
+        if index is None:
+            return False
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_oper_status, index)
+
+        return status == 1
+
+    def get_psu_presence(self, index):
+        """
+        Retrieves the presence status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is plugged, False if not
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_presence, index)
+
+        return status == 1
+
+    def get_output_voltage(self, index):
+        """
+        Retrieves the ouput volatage in milli volts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p volatge
+        :return: An integer, value of o/p voltage in mV if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        voltage = self._read_file(self.psu_voltage, index)
+
+        return voltage
+
+    def get_output_current(self, index):
+        """
+        Retrieves the output current in milli amperes of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p current
+        :return: An integer, value of o/p current in mA if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        current = self._read_file(self.psu_current, index)
+
+        return current
+
+    def get_output_power(self, index):
+        """
+        Retrieves the output power in micro watts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p power
+        :return: An integer, value of o/p power in micro Watts if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        power = self._read_file(self.psu_power, index)
+
+        return power
+
+    def get_fan_speed(self, index, fan_index):
+        """
+        Retrieves the speed of fan, in rpm, denoted by 1-based <fan_index> of a power 
+                supply unit (PSU) defined by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query fan speed
+        :param fan_index: An integer, 1-based index of the PSU-fan of which to query speed
+        :return: An integer, value of PSU-fan speed in rpm if PSU-fan is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if fan_index > self.MAX_PSU_FAN:
+            raise RuntimeError("fan_index ({}) shouldn't be greater than {}".format(fan_index, self.MAX_PSU_FAN))
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        fan_speed = self._read_file(self.fan_speed, index)
+
+        return fan_speed
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfputil.py
deleted file mode 120000
index 45909b88..00000000
--- a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfputil.py
new file mode 100644
index 00000000..954ed23d
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4600c-r0/plugins/sfputil.py
@@ -0,0 +1,688 @@
+# sfputil.py
+#
+# Platform-specific SFP transceiver interface for SONiC
+#
+
+try:
+    import time
+    import subprocess
+    from sonic_sfp.sfputilbase import *
+    import syslog
+except ImportError as e:
+    raise ImportError("%s - required module not found" % str(e))
+
+# sfp supports dom
+XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT = 0x40
+
+# sfp module threshold offset and width
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+
+# I2C page size for sfp
+SFP_I2C_PAGE_SIZE = 256
+
+# parameters for DB connection
+REDIS_TIMEOUT_USECS = 0
+
+# parameters for SFP presence
+SFP_STATUS_INSERTED = '1'
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+GET_PLATFORM_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.platform"
+
+# Ethernet<n> <=> sfp<n+SFP_PORT_NAME_OFFSET>
+SFP_PORT_NAME_OFFSET = 0
+SFP_PORT_NAME_CONVENTION = "sfp{}"
+
+# magic code defnition for port number, qsfp port position of each platform
+# port_position_tuple = (PORT_START, QSFP_PORT_START, PORT_END, PORT_IN_BLOCK, EEPROM_OFFSET)
+platform_dict = {'x86_64-mlnx_msn2700-r0': 0, 'x86_64-mlnx_msn2740-r0': 0, 'x86_64-mlnx_msn2100-r0': 1, 'x86_64-mlnx_msn2410-r0': 2, 'x86_64-mlnx_msn2010-r0': 3,
+                 'x86_64-mlnx_msn3420-r0': 5, 'x86_64-mlnx_msn3700-r0': 0, 'x86_64-mlnx_msn3700c-r0': 0, 'x86_64-mlnx_msn3800-r0': 4, 'x86_64-mlnx_msn4600c': 4, 'x86_64-mlnx_msn4700-r0': 0}
+port_position_tuple_list = [(0, 0, 31, 32, 1), (0, 0, 15, 16, 1), (0, 48, 55, 56, 1),
+                            (0, 18, 21, 22, 1), (0, 0, 63, 64, 1), (0, 48, 59, 60, 1)]
+
+
+def log_info(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+def log_err(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class SfpUtil(SfpUtilBase):
+    """Platform-specific SfpUtil class"""
+    PORT_START = 0
+    QSFP_PORT_START = 0
+    PORT_END = 0
+    PORTS_IN_BLOCK = 0
+    EEPROM_OFFSET = 0
+
+    db_sel = None
+    db_sel_timeout = None
+    db_sel_object = None
+    db_sel_tbl = None
+    state_db = None
+    sfpd_status_tbl = None
+
+    @property
+    def port_start(self):
+        return self.PORT_START
+
+    @property
+    def port_end(self):
+        return self.PORT_END
+
+    @property
+    def qsfp_ports(self):
+        return list(range(self.QSFP_PORT_START, self.PORTS_IN_BLOCK + 1))
+
+    @property
+    def port_to_eeprom_mapping(self):
+        print("dependency on sysfs has been removed")
+        raise Exception()
+
+    def get_port_position_tuple_by_platform_name(self):
+        p = subprocess.Popen(GET_PLATFORM_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        position_tuple = port_position_tuple_list[platform_dict[out.rstrip('\n')]]
+        return position_tuple
+
+    def __init__(self):
+        port_position_tuple = self.get_port_position_tuple_by_platform_name()
+        self.PORT_START = port_position_tuple[0] + 1
+        self.QSFP_PORT_START = port_position_tuple[1] + 1
+        self.PORT_END = port_position_tuple[2] + 1
+        self.PORTS_IN_BLOCK = port_position_tuple[3]
+        self.EEPROM_OFFSET = port_position_tuple[4]
+        self.mlnx_sfpd_started = False
+
+        SfpUtilBase.__init__(self)
+
+    def get_presence(self, port_num):
+        presence = False
+
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return presence
+
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        ethtool_cmd = "ethtool -m {} 2>/dev/null".format(sfpname)
+        try:
+            proc = subprocess.Popen(ethtool_cmd, stdout=subprocess.PIPE, shell=True, universal_newlines=True, stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+            if result != '':
+                presence = True
+
+        except OSError as e:
+            return presence
+
+        return presence
+
+    def get_low_power_mode(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmget.py {}".format(port_num)
+
+        try:
+            output = subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            if 'LPM ON' in output:
+                return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to get LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def set_low_power_mode(self, port_num, lpmode):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        curr_lpmode = self.get_low_power_mode(port_num)
+        if curr_lpmode == lpmode:
+            return True
+
+        # Compose LPM command
+        lpm = 'on' if lpmode else 'off'
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmset.py {} {}".format(port_num, lpm)
+
+        # Set LPM
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return True
+
+    def reset(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfpreset.py {}".format(port_num)
+
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def get_transceiver_change_event(self, timeout=0):
+        phy_port_dict = {}
+        status = True
+
+        if self.db_sel is None:
+            from swsscommon import swsscommon
+            self.state_db = swsscommon.DBConnector("STATE_DB",
+                                                   REDIS_TIMEOUT_USECS,
+                                                   True)
+
+            # Subscribe to state table for SFP change notifications
+            self.db_sel = swsscommon.Select()
+            self.db_sel_tbl = swsscommon.NotificationConsumer(self.state_db, 'TRANSCEIVER_NOTIFY')
+            self.db_sel.addSelectable(self.db_sel_tbl)
+            self.db_sel_timeout = swsscommon.Select.TIMEOUT
+            self.db_sel_object = swsscommon.Select.OBJECT
+            self.sfpd_status_tbl = swsscommon.Table(self.state_db, 'MLNX_SFPD_TASK')
+
+        # Check the liveness of mlnx-sfpd, if it failed, return system_fail event
+        # If mlnx-sfpd not started, return system_not_ready event
+        keys = self.sfpd_status_tbl.getKeys()
+        if 'LIVENESS' not in keys:
+            if self.mlnx_sfpd_started:
+                log_err("mlnx-sfpd exited, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_FAIL
+                return False, phy_port_dict
+            else:
+                log_info("mlnx-sfpd not ready, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_NOT_READY
+                return False, phy_port_dict
+        else:
+            if not self.mlnx_sfpd_started:
+                self.mlnx_sfpd_started = True
+                log_info("mlnx-sfpd is running")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_READY
+                return False, phy_port_dict
+
+        if timeout:
+            (state, c) = self.db_sel.select(timeout)
+        else:
+            (state, c) = self.db_sel.select()
+
+        if state == self.db_sel_timeout:
+            status = True
+        elif state != self.db_sel_object:
+            status = False
+        else:
+            (key, op, fvp) = self.db_sel_tbl.pop()
+            phy_port_dict[key] = op
+
+        return status, phy_port_dict
+
+    def _read_eeprom_specific_bytes(self, sysfsfile_eeprom, offset, num_bytes):
+        print("_read_eeprom_specific_bytes should not be called since the sysfs it dependents on will no longer exist.")
+        print("_read_eeprom_specific_bytes_via_ethtool should be called instead")
+        raise Exception()
+
+    # Read out any bytes from any offset
+    def _read_eeprom_specific_bytes_via_ethtool(self, port_num, offset, num_bytes):
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        eeprom_raw = []
+        ethtool_cmd = "ethtool -m {} hex on offset {} length {}".format(sfpname, offset, num_bytes)
+        try:
+            output = subprocess.check_output(ethtool_cmd, shell=True, universal_newlines=True)
+            output_lines = output.splitlines()
+            first_line_raw = output_lines[0]
+            if "Offset" in first_line_raw:
+                for line in output_lines[2:]:
+                    line_split = line.split()
+                    eeprom_raw = eeprom_raw + line_split[1:]
+        except subprocess.CalledProcessError as e:
+            return None
+
+        return eeprom_raw
+
+    # Read eeprom
+    def _read_eeprom_devid(self, port_num, devid, offset, num_bytes=512):
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            pass
+        elif (self.DOM_EEPROM_ADDR == devid):
+            offset += 256
+
+        eeprom_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, num_bytes)
+
+        return eeprom_raw
+
+    # Read out SFP type, vendor name, PN, REV, SN from eeprom.
+    def get_transceiver_info_dict(self, port_num):
+        transceiver_info_dict = {}
+        compliance_code_dict = {}
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if port_num in self.osfp_ports:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_type_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            # Below part is added to avoid fail the xcvrd, shall be implemented later
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if port_num in self.qsfp_ports:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+                sfp_type = 'QSFP'
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+                sfp_type = 'SFP'
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_INTFACE_BULK_OFFSET), interface_info_bulk_width)
+            if sfp_interface_bulk_raw is not None:
+                sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(sfp_interface_bulk_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_oui_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_OUI_OFFSET), XCVR_VENDOR_OUI_WIDTH)
+            if sfp_vendor_oui_raw is not None:
+                sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(sfp_vendor_oui_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_date_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_DATE_OFFSET), XCVR_VENDOR_DATE_WIDTH)
+            if sfp_vendor_date_raw is not None:
+                sfp_vendor_date_data = sfpi_obj.parse_vendor_date(sfp_vendor_date_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            if sfp_type == 'QSFP':
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_dom_info_dict(self, port_num):
+        transceiver_dom_info_dict = {}
+
+        # Below part is added to avoid failing xcvrd
+        # Currently, the way in which dom data is read has been changed from
+        # using sysfs to using ethtool.
+        # The ethtool returns None for ports without dom support, resulting in
+        # None being returned. However, this fails xcvrd to add the
+        # TRANSCEIVER_DOM_SENSOR table entry of associated port to CONFIG_DB
+        # and then causes SNMP fail.
+        # To address this issue a default dict is initialized with all data set to
+        # 'N/A' and is returned is the above case.
+        # BTW, in the original implementation which sysfs is used to read dom data,
+        # even though non-None data is returned for ports without dom support,
+        # it does not contain valid data. This can result in wrong data in
+        # TRANSCEIVER_DOM_SENSOR table.
+        transceiver_dom_info_dict['temperature'] = 'N/A'
+        transceiver_dom_info_dict['voltage'] = 'N/A'
+        transceiver_dom_info_dict['rx1power'] = 'N/A'
+        transceiver_dom_info_dict['rx2power'] = 'N/A'
+        transceiver_dom_info_dict['rx3power'] = 'N/A'
+        transceiver_dom_info_dict['rx4power'] = 'N/A'
+        transceiver_dom_info_dict['tx1bias'] = 'N/A'
+        transceiver_dom_info_dict['tx2bias'] = 'N/A'
+        transceiver_dom_info_dict['tx3bias'] = 'N/A'
+        transceiver_dom_info_dict['tx4bias'] = 'N/A'
+        transceiver_dom_info_dict['tx1power'] = 'N/A'
+        transceiver_dom_info_dict['tx2power'] = 'N/A'
+        transceiver_dom_info_dict['tx3power'] = 'N/A'
+        transceiver_dom_info_dict['tx4power'] = 'N/A'
+
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            offset = 0
+            offset_xcvr = 128
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset_xcvr + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qspf_dom_capability_data = sfpi_obj.parse_qsfp_dom_capability(qsfp_dom_capability_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_temperature_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_TEMPE_OFFSET), QSFP_TEMPE_WIDTH)
+            if dom_temperature_raw is not None:
+                dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_voltage_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_VOLT_OFFSET), QSFP_VOLT_WIDTH)
+            if dom_voltage_raw is not None:
+                dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            qsfp_dom_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_DOM_REV_OFFSET), QSFP_DOM_REV_WIDTH)
+            if qsfp_dom_rev_raw is not None:
+                qsfp_dom_rev_data = sfpd_obj.parse_sfp_dom_rev(qsfp_dom_rev_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+
+            # The tx_power monitoring is only available on QSFP which compliant with SFF-8636
+            # and claimed that it support tx_power with one indicator bit.
+            dom_channel_monitor_data = {}
+            qsfp_dom_rev = qsfp_dom_rev_data['data']['dom_rev']['value']
+            qsfp_tx_power_support = qspf_dom_capability_data['data']['Tx_power_support']['value']
+            if (qsfp_dom_rev[0:8] != 'SFF-8636' or (qsfp_dom_rev[0:8] == 'SFF-8636' and qsfp_tx_power_support != 'on')):
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+            else:
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+
+                transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TX1Power']['value']
+                transceiver_dom_info_dict['tx2power'] = dom_channel_monitor_data['data']['TX2Power']['value']
+                transceiver_dom_info_dict['tx3power'] = dom_channel_monitor_data['data']['TX3Power']['value']
+                transceiver_dom_info_dict['tx4power'] = dom_channel_monitor_data['data']['TX4Power']['value']
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RX1Power']['value']
+            transceiver_dom_info_dict['rx2power'] = dom_channel_monitor_data['data']['RX2Power']['value']
+            transceiver_dom_info_dict['rx3power'] = dom_channel_monitor_data['data']['RX3Power']['value']
+            transceiver_dom_info_dict['rx4power'] = dom_channel_monitor_data['data']['RX4Power']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_info_dict
+
+            eeprom_domraw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, SFP_I2C_PAGE_SIZE)
+            if eeprom_domraw is None:
+                return transceiver_dom_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                print("no sff8472Dom")
+                return None
+
+            dom_temperature_raw = eeprom_domraw[SFP_TEMPE_OFFSET:SFP_TEMPE_OFFSET+SFP_TEMPE_WIDTH]
+            dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+
+            dom_voltage_raw = eeprom_domraw[SFP_VOLT_OFFSET:SFP_VOLT_OFFSET+SFP_VOLT_WIDTH]
+            dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+
+            dom_channel_monitor_raw = eeprom_domraw[SFP_CHANNL_MON_OFFSET:SFP_CHANNL_MON_OFFSET+SFP_CHANNL_MON_WIDTH]
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RXPower']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TXBias']['value']
+            transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TXPower']['value']
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_dom_threshold_info_dict(self, port_num):
+        transceiver_dom_threshold_info_dict = {}
+
+        dom_info_dict_keys = ['temphighalarm',    'temphighwarning',
+                              'templowalarm',     'templowwarning',
+                              'vcchighalarm',     'vcchighwarning',
+                              'vcclowalarm',      'vcclowwarning',
+                              'rxpowerhighalarm', 'rxpowerhighwarning',
+                              'rxpowerlowalarm',  'rxpowerlowwarning',
+                              'txpowerhighalarm', 'txpowerhighwarning',
+                              'txpowerlowalarm',  'txpowerlowwarning',
+                              'txbiashighalarm',  'txbiashighwarning',
+                              'txbiaslowalarm',   'txbiaslowwarning'
+                              ]
+        transceiver_dom_threshold_info_dict = dict.fromkeys(dom_info_dict_keys, 'N/A')
+
+        if port_num in self.qsfp_ports:
+            # current we don't support qsfp since threshold data is on page 3 and the way to read this page is under discussion.
+            return transceiver_dom_threshold_info_dict
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num,
+                                                                                    (offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                                    SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/eeprom.py
deleted file mode 120000
index b4e2a6a6..00000000
--- a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/eeprom.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/eeprom.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/eeprom.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/eeprom.py
new file mode 100644
index 00000000..0f20ffff
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/eeprom.py
@@ -0,0 +1,75 @@
+#############################################################################
+# Mellanox
+#
+# Platform and model specific eeprom subclass, inherits from the base class,
+# and provides the followings:
+# - the eeprom format definition
+# - specific encoder/decoder if there is special need
+#############################################################################
+
+try:
+    import binascii
+    import time
+    import optparse
+    import warnings
+    import os
+    import sys
+    import syslog
+
+    if sys.version_info.major == 3:
+        from io import StringIO
+    else:
+        from cStringIO import StringIO
+
+    from sonic_eeprom import eeprom_base
+    from sonic_eeprom import eeprom_tlvinfo
+    from sonic_py_common.device_info import get_machine_info
+    import subprocess
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSLOG_IDENTIFIER = "eeprom.py"
+EEPROM_SYMLINK = "/var/run/hw-management/eeprom/vpd_info"
+CACHE_FILE = "/var/cache/sonic/decode-syseeprom/syseeprom_cache"
+
+
+def log_error(msg):
+    syslog.openlog(SYSLOG_IDENTIFIER)
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+machine_info = get_machine_info()
+onie_platform = machine_info['onie_platform']
+if 'simx' in onie_platform:
+    platform_path = os.path.join('/usr/share/sonic/device', onie_platform)
+    subprocess.check_call(['/usr/bin/xxd', '-r', '-p', 'syseeprom.hex', 'syseeprom.bin'], cwd=platform_path)
+    CACHE_FILE = os.path.join(platform_path, 'syseeprom.bin')
+
+
+class board(eeprom_tlvinfo.TlvInfoDecoder):
+
+    _TLV_INFO_MAX_LEN = 256
+    RETRIES = 5
+
+    def __init__(self, name, path, cpld_root, ro):
+        for attempt in range(self.RETRIES):
+            if not os.path.islink(EEPROM_SYMLINK):
+                time.sleep(1)
+            else:
+                break
+
+        if not (os.path.exists(EEPROM_SYMLINK) or os.path.isfile(CACHE_FILE)):
+            log_error("Nowhere to read syseeprom from! No symlink or cache file found")
+            raise RuntimeError("No syseeprom symlink or cache file found")
+
+        self.eeprom_path = EEPROM_SYMLINK if 'simx' not in onie_platform else CACHE_FILE
+        super(board, self).__init__(self.eeprom_path, 0, '', True)
+
+    def decode_eeprom(self, e):
+        original_stdout = sys.stdout
+        sys.stdout = StringIO()
+        eeprom_tlvinfo.TlvInfoDecoder.decode_eeprom(self, e)
+        decode_output = sys.stdout.getvalue()
+        sys.stdout = original_stdout
+        print(decode_output.replace('\0', ''))
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/psuutil.py
deleted file mode 120000
index 9f724238..00000000
--- a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/psuutil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/psuutil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/psuutil.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/psuutil.py
new file mode 100644
index 00000000..6da5770c
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/psuutil.py
@@ -0,0 +1,184 @@
+#############################################################################
+# Mellanox
+#
+# Module contains an implementation of SONiC PSU Base API and
+# provides the PSUs status which are available in the platform
+#
+#############################################################################
+
+try:
+    import os.path
+    import syslog
+    import subprocess
+    from sonic_psu.psu_base import PsuBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def log_err(msg):
+    syslog.openlog("psuutil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class PsuUtil(PsuBase):
+    """Platform-specific PSUutil class"""
+
+    MAX_PSU_FAN = 1
+    MAX_NUM_PSU = 2
+    GET_HWSKU_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.hwsku"
+    # for spectrum1 switches with plugable PSUs, the output voltage file is psuX_volt
+    # for spectrum2 switches the output voltage file is psuX_volt_out2
+    sku_spectrum1_with_plugable_psu = ['ACS-MSN2410', 'ACS-MSN2700',
+                                       'Mellanox-SN2700', 'Mellanox-SN2700-D48C8', 'LS-SN2700', 'ACS-MSN2740']
+
+    def __init__(self):
+        PsuBase.__init__(self)
+
+        self.sku_name = self._get_sku_name()
+
+        self.psu_path = "/var/run/hw-management/"
+        self.psu_presence = "thermal/psu{}_status"
+        self.psu_oper_status = "thermal/psu{}_pwr_status"
+        self.psu_current = "power/psu{}_curr"
+        self.psu_power = "power/psu{}_power"
+        if self.sku_name in self.sku_spectrum1_with_plugable_psu:
+            self.psu_voltage = "power/psu{}_volt"
+        else:
+            self.psu_voltage = "power/psu{}_volt_out2"
+        self.fan_speed = "thermal/psu{}_fan1_speed_get"
+
+    def _get_sku_name(self):
+        p = subprocess.Popen(self.GET_HWSKU_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        return out.rstrip('\n')
+
+    def get_num_psus(self):
+        """
+        Retrieves the number of PSUs available on the device
+
+        :return: An integer, the number of PSUs available on the device
+        """
+        return self.MAX_NUM_PSU
+
+    def _read_file(self, file_pattern, index):
+        """
+        Reads the file of the PSU
+
+        :param file_pattern: The filename convention
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: int
+        """
+        return_value = 0
+        try:
+            with open(self.psu_path + file_pattern.format(index), 'r') as file_to_read:
+                return_value = int(file_to_read.read())
+        except IOError:
+            log_err("Read file {} failed".format(self.psu_path + file_pattern.format(index)))
+            return 0
+
+        return return_value
+
+    def get_psu_status(self, index):
+        """
+        Retrieves the oprational status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is operating properly, False if PSU is faulty
+        """
+        if index is None:
+            return False
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_oper_status, index)
+
+        return status == 1
+
+    def get_psu_presence(self, index):
+        """
+        Retrieves the presence status of power supply unit (PSU) defined
+                by 1-based index <index>
+
+        :param index: An integer, 1-based index of the PSU of which to query status
+        :return: Boolean, True if PSU is plugged, False if not
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if index > self.MAX_NUM_PSU:
+            raise RuntimeError("index ({}) shouldn't be greater than {}".format(index, self.MAX_NUM_PSU))
+
+        status = self._read_file(self.psu_presence, index)
+
+        return status == 1
+
+    def get_output_voltage(self, index):
+        """
+        Retrieves the ouput volatage in milli volts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p volatge
+        :return: An integer, value of o/p voltage in mV if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        voltage = self._read_file(self.psu_voltage, index)
+
+        return voltage
+
+    def get_output_current(self, index):
+        """
+        Retrieves the output current in milli amperes of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p current
+        :return: An integer, value of o/p current in mA if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        current = self._read_file(self.psu_current, index)
+
+        return current
+
+    def get_output_power(self, index):
+        """
+        Retrieves the output power in micro watts of a power supply unit (PSU) defined
+                by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query o/p power
+        :return: An integer, value of o/p power in micro Watts if PSU is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        power = self._read_file(self.psu_power, index)
+
+        return power
+
+    def get_fan_speed(self, index, fan_index):
+        """
+        Retrieves the speed of fan, in rpm, denoted by 1-based <fan_index> of a power 
+                supply unit (PSU) defined by 1-based index <index>
+        :param index: An integer, 1-based index of the PSU of which to query fan speed
+        :param fan_index: An integer, 1-based index of the PSU-fan of which to query speed
+        :return: An integer, value of PSU-fan speed in rpm if PSU-fan is good, else zero
+        """
+        if index is None:
+            raise RuntimeError("index shouldn't be None")
+        if fan_index > self.MAX_PSU_FAN:
+            raise RuntimeError("fan_index ({}) shouldn't be greater than {}".format(fan_index, self.MAX_PSU_FAN))
+        if not self.get_psu_presence(index) or not self.get_psu_status(index):
+            return 0
+
+        fan_speed = self._read_file(self.fan_speed, index)
+
+        return fan_speed
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmget.py
deleted file mode 120000
index 2e84f435..00000000
--- a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmget.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmget.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmget.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmget.py
new file mode 100644
index 00000000..ca16c357
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmget.py
@@ -0,0 +1,54 @@
+#!/usr/bin/env python3
+
+"""
+This utility get the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number is missed.")
+    print("Usage: sfplpmget.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, sfp_module, SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E)
+
+lpm_status = None
+if oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_HIGH_E:
+    lpm_status = False
+elif oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E:
+    lpm_status = True
+else:
+    print("LPM UNKNOWN")
+
+print("LPM ON" if lpm_status else "LPM OFF")
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmset.py
deleted file mode 120000
index 6a88bac3..00000000
--- a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfplpmset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmset.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmset.py
new file mode 100644
index 00000000..61423880
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfplpmset.py
@@ -0,0 +1,169 @@
+#!/usr/bin/env python3
+
+"""
+This utility set the power mode of a given module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+
+DEVICE_ID = 1
+SWITCH_ID = 0
+SX_PORT_ATTR_ARR_SIZE = 64
+
+PORT_TYPE_CPU = 4
+PORT_TYPE_NVE = 8
+PORT_TYPE_OFFSET = 28
+PORT_TYPE_MASK = 0xF0000000
+NVE_MASK = PORT_TYPE_MASK & (PORT_TYPE_NVE << PORT_TYPE_OFFSET)
+CPU_MASK = PORT_TYPE_MASK & (PORT_TYPE_CPU << PORT_TYPE_OFFSET)
+
+
+def is_nve(port):
+    return (port & NVE_MASK) != 0
+
+
+def is_cpu(port):
+    return (port & CPU_MASK) != 0
+
+
+def is_port_admin_status_up(log_port):
+    oper_state_p = new_sx_port_oper_state_t_p()
+    admin_state_p = new_sx_port_admin_state_t_p()
+    module_state_p = new_sx_port_module_state_t_p()
+    rc = sx_api_port_state_get(handle, log_port, oper_state_p, admin_state_p, module_state_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_get failed, rc = %d" % rc
+
+    admin_state = sx_port_admin_state_t_p_value(admin_state_p)
+    if admin_state == SX_PORT_ADMIN_STATUS_UP:
+        return True
+    else:
+        return False
+
+
+def set_port_admin_status_by_log_port(handle, log_port, admin_status):
+    rc = sx_api_port_state_set(handle, log_port, admin_status)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_state_set failed, rc = %d" % rc
+
+# Get all the ports related to the sfp, if port admin status is up, put it to list
+
+
+def get_log_ports(handle, sfp_module):
+    port_attributes_list = new_sx_port_attributes_t_arr(SX_PORT_ATTR_ARR_SIZE)
+    port_cnt_p = new_uint32_t_p()
+    uint32_t_p_assign(port_cnt_p, SX_PORT_ATTR_ARR_SIZE)
+
+    rc = sx_api_port_device_get(handle, DEVICE_ID, SWITCH_ID, port_attributes_list,  port_cnt_p)
+    assert rc == SX_STATUS_SUCCESS, "sx_api_port_device_get failed, rc = %d" % rc
+
+    port_cnt = uint32_t_p_value(port_cnt_p)
+    log_port_list = []
+    for i in range(0, port_cnt):
+        port_attributes = sx_port_attributes_t_arr_getitem(port_attributes_list, i)
+        if not is_nve(int(port_attributes.log_port)) \
+           and not is_cpu(int(port_attributes.log_port)) \
+           and port_attributes.port_mapping.module_port == sfp_module \
+           and is_port_admin_status_up(port_attributes.log_port):
+            log_port_list.append(port_attributes.log_port)
+
+    return log_port_list
+
+
+def mgmt_phy_mod_pwr_attr_set(handle, module_id, power_attr_type, admin_pwr_mode):
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_mode_attr.admin_pwr_mode_e = admin_pwr_mode
+    sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr = sx_mgmt_phy_mod_pwr_mode_attr
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_set(handle, SX_ACCESS_CMD_SET, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_set failed"
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def mgmt_phy_mod_pwr_attr_get(handle, module_id, power_attr_type):
+    sx_mgmt_phy_mod_pwr_attr_p = new_sx_mgmt_phy_mod_pwr_attr_t_p()
+    sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t()
+    sx_mgmt_phy_mod_pwr_attr.power_attr_type = power_attr_type
+    sx_mgmt_phy_mod_pwr_attr_t_p_assign(sx_mgmt_phy_mod_pwr_attr_p, sx_mgmt_phy_mod_pwr_attr)
+    try:
+        rc = sx_mgmt_phy_mod_pwr_attr_get(handle, module_id, sx_mgmt_phy_mod_pwr_attr_p)
+        assert SX_STATUS_SUCCESS == rc, "sx_mgmt_phy_mod_pwr_attr_get failed"
+        sx_mgmt_phy_mod_pwr_attr = sx_mgmt_phy_mod_pwr_attr_t_p_value(sx_mgmt_phy_mod_pwr_attr_p)
+        pwr_mode_attr = sx_mgmt_phy_mod_pwr_attr.pwr_mode_attr
+        return pwr_mode_attr.admin_pwr_mode_e, pwr_mode_attr.oper_pwr_mode_e
+    finally:
+        delete_sx_mgmt_phy_mod_pwr_attr_t_p(sx_mgmt_phy_mod_pwr_attr_p)
+
+
+def pwr_attr_set(handle, module_id, ports, attr_type, power_mode):
+    # Check if the module already works in the same mode
+    admin_pwr_mode, oper_pwr_mode = mgmt_phy_mod_pwr_attr_get(handle, module_id, attr_type)
+    if (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E and oper_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_LOW_E) \
+       or (power_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E and admin_pwr_mode == SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E):
+        return
+    try:
+        # Bring the port down
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_DOWN)
+        # Set the desired power mode
+        mgmt_phy_mod_pwr_attr_set(handle, module_id, attr_type, power_mode)
+        # Bring the port up
+    finally:
+        for port in ports:
+            set_port_admin_status_by_log_port(handle, port, SX_PORT_ADMIN_STATUS_UP)
+
+
+def set_lpmode(handle, cmd, module_id):
+    # Construct the port module map.
+    log_port_list = get_log_ports(handle, module_id)
+
+    if cmd == "enable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_LOW_E)
+        print("Enabled low power mode for module [%d]" % module_id)
+    elif cmd == "disable":
+        pwr_attr_set(handle, module_id, log_port_list,
+                     SX_MGMT_PHY_MOD_PWR_ATTR_PWR_MODE_E, SX_MGMT_PHY_MOD_PWR_MODE_AUTO_E)
+        print("Disabled low power mode for module [%d]" % module_id)
+    else:
+        print("Error: Invalid command")
+        sys.exit(0)
+
+
+if len(sys.argv) < 3:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfplpmset.py <SFP module> <on|off>")
+    sys.exit(errno.EINVAL)
+
+cmd = None
+lpm_enable = None
+if sys.argv[2] == 'on':
+    lpm_enable = True
+    cmd = 'enable'
+elif sys.argv[2] == 'off':
+    lpm_enable = False
+    cmd = 'disable'
+else:
+    print("Unrecognized LPM parameter. Please use <on> or <off> values")
+    sys.exit(errno.EINVAL)
+
+# Get SFP module
+sfp_module = int(sys.argv[1]) - 1
+
+print("[+] opening sdk")
+rc, handle = sx_api_open(None)
+
+if (rc != SX_STATUS_SUCCESS):
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Set low power mode
+set_lpmode(handle, cmd, sfp_module)
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfpreset.py
deleted file mode 120000
index fef2063e..00000000
--- a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfpreset.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfpreset.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfpreset.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfpreset.py
new file mode 100644
index 00000000..af237b70
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfpreset.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+"""
+This utility reset the given SFP module.
+"""
+
+import sys
+import errno
+from python_sdk_api.sx_api import *
+
+# Check if SFP port number is provided
+if len(sys.argv) < 2:
+    print("SFP module number or LPM is missed.")
+    print("Usage: sfpreset.py <SFP module>")
+    sys.exit(errno.EINVAL)
+
+# Init SDK API
+rc, handle = sx_api_open(None)
+if rc != SX_STATUS_SUCCESS:
+    print("Failed to open api handle.\nPlease check that SDK is running.")
+    sys.exit(errno.EACCES)
+
+# Get SFP module number
+sfp_module = int(sys.argv[1]) - 1
+
+rc = sx_mgmt_phy_mod_reset(handle, sfp_module)
+assert rc == SX_STATUS_SUCCESS, "sx_mgmt_phy_mod_reset failed, rc = %d" % rc
+
+sx_api_close(handle)
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfputil.py
deleted file mode 120000
index 45909b88..00000000
--- a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfputil.py
+++ /dev/null
@@ -1 +0,0 @@
-../../x86_64-mlnx_msn2700-r0/plugins/sfputil.py
\ No newline at end of file
diff --git a/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfputil.py b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfputil.py
new file mode 100644
index 00000000..954ed23d
--- /dev/null
+++ b/device/mellanox/x86_64-mlnx_msn4700-r0/plugins/sfputil.py
@@ -0,0 +1,688 @@
+# sfputil.py
+#
+# Platform-specific SFP transceiver interface for SONiC
+#
+
+try:
+    import time
+    import subprocess
+    from sonic_sfp.sfputilbase import *
+    import syslog
+except ImportError as e:
+    raise ImportError("%s - required module not found" % str(e))
+
+# sfp supports dom
+XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT = 0x40
+
+# sfp module threshold offset and width
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+
+# I2C page size for sfp
+SFP_I2C_PAGE_SIZE = 256
+
+# parameters for DB connection
+REDIS_TIMEOUT_USECS = 0
+
+# parameters for SFP presence
+SFP_STATUS_INSERTED = '1'
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+GET_PLATFORM_CMD = "sonic-cfggen -d -v DEVICE_METADATA.localhost.platform"
+
+# Ethernet<n> <=> sfp<n+SFP_PORT_NAME_OFFSET>
+SFP_PORT_NAME_OFFSET = 0
+SFP_PORT_NAME_CONVENTION = "sfp{}"
+
+# magic code defnition for port number, qsfp port position of each platform
+# port_position_tuple = (PORT_START, QSFP_PORT_START, PORT_END, PORT_IN_BLOCK, EEPROM_OFFSET)
+platform_dict = {'x86_64-mlnx_msn2700-r0': 0, 'x86_64-mlnx_msn2740-r0': 0, 'x86_64-mlnx_msn2100-r0': 1, 'x86_64-mlnx_msn2410-r0': 2, 'x86_64-mlnx_msn2010-r0': 3,
+                 'x86_64-mlnx_msn3420-r0': 5, 'x86_64-mlnx_msn3700-r0': 0, 'x86_64-mlnx_msn3700c-r0': 0, 'x86_64-mlnx_msn3800-r0': 4, 'x86_64-mlnx_msn4600c': 4, 'x86_64-mlnx_msn4700-r0': 0}
+port_position_tuple_list = [(0, 0, 31, 32, 1), (0, 0, 15, 16, 1), (0, 48, 55, 56, 1),
+                            (0, 18, 21, 22, 1), (0, 0, 63, 64, 1), (0, 48, 59, 60, 1)]
+
+
+def log_info(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_INFO, msg)
+    syslog.closelog()
+
+
+def log_err(msg, also_print_to_console=False):
+    syslog.openlog("sfputil")
+    syslog.syslog(syslog.LOG_ERR, msg)
+    syslog.closelog()
+
+
+class SfpUtil(SfpUtilBase):
+    """Platform-specific SfpUtil class"""
+    PORT_START = 0
+    QSFP_PORT_START = 0
+    PORT_END = 0
+    PORTS_IN_BLOCK = 0
+    EEPROM_OFFSET = 0
+
+    db_sel = None
+    db_sel_timeout = None
+    db_sel_object = None
+    db_sel_tbl = None
+    state_db = None
+    sfpd_status_tbl = None
+
+    @property
+    def port_start(self):
+        return self.PORT_START
+
+    @property
+    def port_end(self):
+        return self.PORT_END
+
+    @property
+    def qsfp_ports(self):
+        return list(range(self.QSFP_PORT_START, self.PORTS_IN_BLOCK + 1))
+
+    @property
+    def port_to_eeprom_mapping(self):
+        print("dependency on sysfs has been removed")
+        raise Exception()
+
+    def get_port_position_tuple_by_platform_name(self):
+        p = subprocess.Popen(GET_PLATFORM_CMD, shell=True, universal_newlines=True, stdout=subprocess.PIPE)
+        out, err = p.communicate()
+        position_tuple = port_position_tuple_list[platform_dict[out.rstrip('\n')]]
+        return position_tuple
+
+    def __init__(self):
+        port_position_tuple = self.get_port_position_tuple_by_platform_name()
+        self.PORT_START = port_position_tuple[0] + 1
+        self.QSFP_PORT_START = port_position_tuple[1] + 1
+        self.PORT_END = port_position_tuple[2] + 1
+        self.PORTS_IN_BLOCK = port_position_tuple[3]
+        self.EEPROM_OFFSET = port_position_tuple[4]
+        self.mlnx_sfpd_started = False
+
+        SfpUtilBase.__init__(self)
+
+    def get_presence(self, port_num):
+        presence = False
+
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return presence
+
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        ethtool_cmd = "ethtool -m {} 2>/dev/null".format(sfpname)
+        try:
+            proc = subprocess.Popen(ethtool_cmd, stdout=subprocess.PIPE, shell=True, universal_newlines=True, stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+            if result != '':
+                presence = True
+
+        except OSError as e:
+            return presence
+
+        return presence
+
+    def get_low_power_mode(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmget.py {}".format(port_num)
+
+        try:
+            output = subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            if 'LPM ON' in output:
+                return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to get LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def set_low_power_mode(self, port_num, lpmode):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        curr_lpmode = self.get_low_power_mode(port_num)
+        if curr_lpmode == lpmode:
+            return True
+
+        # Compose LPM command
+        lpm = 'on' if lpmode else 'off'
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfplpmset.py {} {}".format(port_num, lpm)
+
+        # Set LPM
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return True
+
+    def reset(self, port_num):
+        # Check for invalid port_num
+        if port_num < self.port_start or port_num > self.port_end:
+            return False
+
+        lpm_cmd = "docker exec syncd python /usr/share/sonic/platform/plugins/sfpreset.py {}".format(port_num)
+
+        try:
+            subprocess.check_output(lpm_cmd, shell=True, universal_newlines=True)
+            return True
+        except subprocess.CalledProcessError as e:
+            print("Error! Unable to set LPM for {}, rc = {}, err msg: {}".format(port_num, e.returncode, e.output))
+            return False
+
+        return False
+
+    def get_transceiver_change_event(self, timeout=0):
+        phy_port_dict = {}
+        status = True
+
+        if self.db_sel is None:
+            from swsscommon import swsscommon
+            self.state_db = swsscommon.DBConnector("STATE_DB",
+                                                   REDIS_TIMEOUT_USECS,
+                                                   True)
+
+            # Subscribe to state table for SFP change notifications
+            self.db_sel = swsscommon.Select()
+            self.db_sel_tbl = swsscommon.NotificationConsumer(self.state_db, 'TRANSCEIVER_NOTIFY')
+            self.db_sel.addSelectable(self.db_sel_tbl)
+            self.db_sel_timeout = swsscommon.Select.TIMEOUT
+            self.db_sel_object = swsscommon.Select.OBJECT
+            self.sfpd_status_tbl = swsscommon.Table(self.state_db, 'MLNX_SFPD_TASK')
+
+        # Check the liveness of mlnx-sfpd, if it failed, return system_fail event
+        # If mlnx-sfpd not started, return system_not_ready event
+        keys = self.sfpd_status_tbl.getKeys()
+        if 'LIVENESS' not in keys:
+            if self.mlnx_sfpd_started:
+                log_err("mlnx-sfpd exited, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_FAIL
+                return False, phy_port_dict
+            else:
+                log_info("mlnx-sfpd not ready, return false to notify xcvrd.")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_NOT_READY
+                return False, phy_port_dict
+        else:
+            if not self.mlnx_sfpd_started:
+                self.mlnx_sfpd_started = True
+                log_info("mlnx-sfpd is running")
+                phy_port_dict[EVENT_ON_ALL_SFP] = SYSTEM_READY
+                return False, phy_port_dict
+
+        if timeout:
+            (state, c) = self.db_sel.select(timeout)
+        else:
+            (state, c) = self.db_sel.select()
+
+        if state == self.db_sel_timeout:
+            status = True
+        elif state != self.db_sel_object:
+            status = False
+        else:
+            (key, op, fvp) = self.db_sel_tbl.pop()
+            phy_port_dict[key] = op
+
+        return status, phy_port_dict
+
+    def _read_eeprom_specific_bytes(self, sysfsfile_eeprom, offset, num_bytes):
+        print("_read_eeprom_specific_bytes should not be called since the sysfs it dependents on will no longer exist.")
+        print("_read_eeprom_specific_bytes_via_ethtool should be called instead")
+        raise Exception()
+
+    # Read out any bytes from any offset
+    def _read_eeprom_specific_bytes_via_ethtool(self, port_num, offset, num_bytes):
+        port_num += SFP_PORT_NAME_OFFSET
+        sfpname = SFP_PORT_NAME_CONVENTION.format(port_num)
+
+        eeprom_raw = []
+        ethtool_cmd = "ethtool -m {} hex on offset {} length {}".format(sfpname, offset, num_bytes)
+        try:
+            output = subprocess.check_output(ethtool_cmd, shell=True, universal_newlines=True)
+            output_lines = output.splitlines()
+            first_line_raw = output_lines[0]
+            if "Offset" in first_line_raw:
+                for line in output_lines[2:]:
+                    line_split = line.split()
+                    eeprom_raw = eeprom_raw + line_split[1:]
+        except subprocess.CalledProcessError as e:
+            return None
+
+        return eeprom_raw
+
+    # Read eeprom
+    def _read_eeprom_devid(self, port_num, devid, offset, num_bytes=512):
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            pass
+        elif (self.DOM_EEPROM_ADDR == devid):
+            offset += 256
+
+        eeprom_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, num_bytes)
+
+        return eeprom_raw
+
+    # Read out SFP type, vendor name, PN, REV, SN from eeprom.
+    def get_transceiver_info_dict(self, port_num):
+        transceiver_info_dict = {}
+        compliance_code_dict = {}
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if port_num in self.osfp_ports:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_type_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            # Below part is added to avoid fail the xcvrd, shall be implemented later
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if port_num in self.qsfp_ports:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+                sfp_type = 'QSFP'
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                cable_length_width = XCVR_CABLE_LENGTH_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+                sfp_type = 'SFP'
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_INTFACE_BULK_OFFSET), interface_info_bulk_width)
+            if sfp_interface_bulk_raw is not None:
+                sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(sfp_interface_bulk_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_oui_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_OUI_OFFSET), XCVR_VENDOR_OUI_WIDTH)
+            if sfp_vendor_oui_raw is not None:
+                sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(sfp_vendor_oui_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_date_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + XCVR_VENDOR_DATE_OFFSET), XCVR_VENDOR_DATE_WIDTH)
+            if sfp_vendor_date_raw is not None:
+                sfp_vendor_date_data = sfpi_obj.parse_vendor_date(sfp_vendor_date_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            if sfp_type == 'QSFP':
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_dom_info_dict(self, port_num):
+        transceiver_dom_info_dict = {}
+
+        # Below part is added to avoid failing xcvrd
+        # Currently, the way in which dom data is read has been changed from
+        # using sysfs to using ethtool.
+        # The ethtool returns None for ports without dom support, resulting in
+        # None being returned. However, this fails xcvrd to add the
+        # TRANSCEIVER_DOM_SENSOR table entry of associated port to CONFIG_DB
+        # and then causes SNMP fail.
+        # To address this issue a default dict is initialized with all data set to
+        # 'N/A' and is returned is the above case.
+        # BTW, in the original implementation which sysfs is used to read dom data,
+        # even though non-None data is returned for ports without dom support,
+        # it does not contain valid data. This can result in wrong data in
+        # TRANSCEIVER_DOM_SENSOR table.
+        transceiver_dom_info_dict['temperature'] = 'N/A'
+        transceiver_dom_info_dict['voltage'] = 'N/A'
+        transceiver_dom_info_dict['rx1power'] = 'N/A'
+        transceiver_dom_info_dict['rx2power'] = 'N/A'
+        transceiver_dom_info_dict['rx3power'] = 'N/A'
+        transceiver_dom_info_dict['rx4power'] = 'N/A'
+        transceiver_dom_info_dict['tx1bias'] = 'N/A'
+        transceiver_dom_info_dict['tx2bias'] = 'N/A'
+        transceiver_dom_info_dict['tx3bias'] = 'N/A'
+        transceiver_dom_info_dict['tx4bias'] = 'N/A'
+        transceiver_dom_info_dict['tx1power'] = 'N/A'
+        transceiver_dom_info_dict['tx2power'] = 'N/A'
+        transceiver_dom_info_dict['tx3power'] = 'N/A'
+        transceiver_dom_info_dict['tx4power'] = 'N/A'
+
+        if port_num in self.osfp_ports:
+            pass
+        elif port_num in self.qsfp_ports:
+            offset = 0
+            offset_xcvr = 128
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset_xcvr + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qspf_dom_capability_data = sfpi_obj.parse_qsfp_dom_capability(qsfp_dom_capability_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_temperature_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_TEMPE_OFFSET), QSFP_TEMPE_WIDTH)
+            if dom_temperature_raw is not None:
+                dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            dom_voltage_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_VOLT_OFFSET), QSFP_VOLT_WIDTH)
+            if dom_voltage_raw is not None:
+                dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            qsfp_dom_rev_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                port_num, (offset + QSFP_DOM_REV_OFFSET), QSFP_DOM_REV_WIDTH)
+            if qsfp_dom_rev_raw is not None:
+                qsfp_dom_rev_data = sfpd_obj.parse_sfp_dom_rev(qsfp_dom_rev_raw, 0)
+            else:
+                return transceiver_dom_info_dict
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+
+            # The tx_power monitoring is only available on QSFP which compliant with SFF-8636
+            # and claimed that it support tx_power with one indicator bit.
+            dom_channel_monitor_data = {}
+            qsfp_dom_rev = qsfp_dom_rev_data['data']['dom_rev']['value']
+            qsfp_tx_power_support = qspf_dom_capability_data['data']['Tx_power_support']['value']
+            if (qsfp_dom_rev[0:8] != 'SFF-8636' or (qsfp_dom_rev[0:8] == 'SFF-8636' and qsfp_tx_power_support != 'on')):
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+            else:
+                dom_channel_monitor_raw = self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                else:
+                    return transceiver_dom_info_dict
+
+                transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TX1Power']['value']
+                transceiver_dom_info_dict['tx2power'] = dom_channel_monitor_data['data']['TX2Power']['value']
+                transceiver_dom_info_dict['tx3power'] = dom_channel_monitor_data['data']['TX3Power']['value']
+                transceiver_dom_info_dict['tx4power'] = dom_channel_monitor_data['data']['TX4Power']['value']
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RX1Power']['value']
+            transceiver_dom_info_dict['rx2power'] = dom_channel_monitor_data['data']['RX2Power']['value']
+            transceiver_dom_info_dict['rx3power'] = dom_channel_monitor_data['data']['RX3Power']['value']
+            transceiver_dom_info_dict['rx4power'] = dom_channel_monitor_data['data']['RX4Power']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_info_dict
+
+            eeprom_domraw = self._read_eeprom_specific_bytes_via_ethtool(port_num, offset, SFP_I2C_PAGE_SIZE)
+            if eeprom_domraw is None:
+                return transceiver_dom_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                print("no sff8472Dom")
+                return None
+
+            dom_temperature_raw = eeprom_domraw[SFP_TEMPE_OFFSET:SFP_TEMPE_OFFSET+SFP_TEMPE_WIDTH]
+            dom_temperature_data = sfpd_obj.parse_temperature(dom_temperature_raw, 0)
+
+            dom_voltage_raw = eeprom_domraw[SFP_VOLT_OFFSET:SFP_VOLT_OFFSET+SFP_VOLT_WIDTH]
+            dom_voltage_data = sfpd_obj.parse_voltage(dom_voltage_raw, 0)
+
+            dom_channel_monitor_raw = eeprom_domraw[SFP_CHANNL_MON_OFFSET:SFP_CHANNL_MON_OFFSET+SFP_CHANNL_MON_WIDTH]
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(dom_channel_monitor_raw, 0)
+
+            transceiver_dom_info_dict['temperature'] = dom_temperature_data['data']['Temperature']['value']
+            transceiver_dom_info_dict['voltage'] = dom_voltage_data['data']['Vcc']['value']
+            transceiver_dom_info_dict['rx1power'] = dom_channel_monitor_data['data']['RXPower']['value']
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TXBias']['value']
+            transceiver_dom_info_dict['tx1power'] = dom_channel_monitor_data['data']['TXPower']['value']
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_dom_threshold_info_dict(self, port_num):
+        transceiver_dom_threshold_info_dict = {}
+
+        dom_info_dict_keys = ['temphighalarm',    'temphighwarning',
+                              'templowalarm',     'templowwarning',
+                              'vcchighalarm',     'vcchighwarning',
+                              'vcclowalarm',      'vcclowwarning',
+                              'rxpowerhighalarm', 'rxpowerhighwarning',
+                              'rxpowerlowalarm',  'rxpowerlowwarning',
+                              'txpowerhighalarm', 'txpowerhighwarning',
+                              'txpowerlowalarm',  'txpowerlowwarning',
+                              'txbiashighalarm',  'txbiashighwarning',
+                              'txbiaslowalarm',   'txbiaslowwarning'
+                              ]
+        transceiver_dom_threshold_info_dict = dict.fromkeys(dom_info_dict_keys, 'N/A')
+
+        if port_num in self.qsfp_ports:
+            # current we don't support qsfp since threshold data is on page 3 and the way to read this page is under discussion.
+            return transceiver_dom_threshold_info_dict
+        else:
+            offset = SFP_I2C_PAGE_SIZE
+
+            eeprom_raw = ['0'] * SFP_I2C_PAGE_SIZE
+            eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET: XCVR_DOM_CAPABILITY_OFFSET + XCVR_DOM_CAPABILITY_WIDTH] = \
+                self._read_eeprom_specific_bytes_via_ethtool(
+                    port_num, XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            sfp_obj = sff8472InterfaceId()
+            calibration_type = sfp_obj._get_calibration_type(eeprom_raw)
+
+            dom_supported = (int(eeprom_raw[XCVR_DOM_CAPABILITY_OFFSET], 16) & XCVR_DOM_CAPABILITY_DOM_SUPPORT_BIT != 0)
+            if not dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, calibration_type)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self._read_eeprom_specific_bytes_via_ethtool(port_num,
+                                                                                    (offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                                    SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
diff --git a/device/virtual/x86_64-kvm_x86_64-r0/asic.conf b/device/virtual/x86_64-kvm_x86_64-r0/asic.conf
index 58c5d534..8a4f716d 100644
--- a/device/virtual/x86_64-kvm_x86_64-r0/asic.conf
+++ b/device/virtual/x86_64-kvm_x86_64-r0/asic.conf
@@ -1 +1 @@
-NUM_ASIC=1
+NUM_ASIC=6
diff --git a/dockers/docker-base-buster/sources.list b/dockers/docker-base-buster/sources.list
index 0eef72d9..0f690f57 100644
--- a/dockers/docker-base-buster/sources.list
+++ b/dockers/docker-base-buster/sources.list
@@ -1,11 +1,11 @@
 ## Debian mirror on Microsoft Azure
-## Ref: http://debian-archive.trafficmanager.net/
+## Ref: http://mirrors.ustc.edu.cn/
 
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian/ buster main contrib non-free
-deb-src [arch=amd64] http://debian-archive.trafficmanager.net/debian/ buster main contrib non-free
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ buster/updates main contrib non-free
-deb-src [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ buster/updates main contrib non-free
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian/ buster-backports main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian/ buster main contrib non-free
+deb-src [arch=amd64] http://mirrors.ustc.edu.cn/debian/ buster main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-free
+deb-src [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian/ buster-backports main contrib non-free
 
 # Debian mirror supports multiple versions for a package
 deb [arch=amd64] http://packages.trafficmanager.net/debian/debian buster main contrib non-free
diff --git a/dockers/docker-base-stretch/sources.list b/dockers/docker-base-stretch/sources.list
index 0c29b339..96b044a0 100644
--- a/dockers/docker-base-stretch/sources.list
+++ b/dockers/docker-base-stretch/sources.list
@@ -1,11 +1,11 @@
 ## Debian mirror on Microsoft Azure
-## Ref: http://debian-archive.trafficmanager.net/
+## Ref: http://mirrors.ustc.edu.cn/
 
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian/ stretch main contrib non-free
-deb-src [arch=amd64] http://debian-archive.trafficmanager.net/debian/ stretch main contrib non-free
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ stretch/updates main contrib non-free
-deb-src [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ stretch/updates main contrib non-free
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian/ stretch-backports main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian/ stretch main contrib non-free
+deb-src [arch=amd64] http://mirrors.ustc.edu.cn/debian/ stretch main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ stretch/updates main contrib non-free
+deb-src [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ stretch/updates main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian/ stretch-backports main contrib non-free
 deb [arch=amd64] http://packages.trafficmanager.net/debian/debian stretch main contrib non-free
 deb [arch=amd64] http://packages.trafficmanager.net/debian/debian stretch-updates main contrib non-free
 deb [arch=amd64] http://packages.trafficmanager.net/debian/debian stretch-backports main contrib non-free
diff --git a/dockers/docker-base/sources.list b/dockers/docker-base/sources.list
index afdff92d..dc37d8c7 100644
--- a/dockers/docker-base/sources.list
+++ b/dockers/docker-base/sources.list
@@ -1,7 +1,7 @@
 ## Debian mirror on Microsoft Azure
-## Ref: http://debian-archive.trafficmanager.net/
+## Ref: http://mirrors.ustc.edu.cn/
 
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian/ jessie main contrib non-free
-deb-src [arch=amd64] http://debian-archive.trafficmanager.net/debian/ jessie main contrib non-free
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ jessie/updates main contrib non-free
-deb-src [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ jessie/updates main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian/ jessie main contrib non-free
+deb-src [arch=amd64] http://mirrors.ustc.edu.cn/debian/ jessie main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ jessie/updates main contrib non-free
+deb-src [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ jessie/updates main contrib non-free
diff --git a/dockers/docker-config-engine-buster/Dockerfile.j2 b/dockers/docker-config-engine-buster/Dockerfile.j2
index 3022546a..de5fb7ce 100644
--- a/dockers/docker-config-engine-buster/Dockerfile.j2
+++ b/dockers/docker-config-engine-buster/Dockerfile.j2
@@ -19,7 +19,7 @@ RUN apt-get install -y        \
 # For sonic-config-engine Python 3 package
 # Explicitly install pyangbind here, as pyangbind causes enum34 to be installed.
 # enum34 causes Python 're' package to not work properly as it redefines an incompatible enum.py module
-# https://github.com/robshakir/pyangbind/issues/232
+# https://hub.fastgit.org/robshakir/pyangbind/issues/232
 RUN pip3 install pyangbind==0.8.1
 RUN pip3 uninstall -y enum34
 
diff --git a/dockers/docker-ptf/Dockerfile.j2 b/dockers/docker-ptf/Dockerfile.j2
index faa927d9..0ac71c64 100644
--- a/dockers/docker-ptf/Dockerfile.j2
+++ b/dockers/docker-ptf/Dockerfile.j2
@@ -84,12 +84,12 @@ RUN rm -rf /debs \
     && pip install setuptools \
     && pip install supervisor \
     && pip install ipython==5.4.1 \
-    && git clone https://github.com/p4lang/scapy-vxlan.git \
+    && git clone https://hub.fastgit.org/p4lang/scapy-vxlan.git \
     && cd scapy-vxlan \
     && python setup.py install \
     && cd .. \
     && rm -fr scapy-vxlan \
-    && git clone https://github.com/sflow/sflowtool \
+    && git clone https://hub.fastgit.org/sflow/sflowtool \
     && cd sflowtool \
     && ./boot.sh \
     && ./configure \
@@ -97,7 +97,7 @@ RUN rm -rf /debs \
     && make install \
     && cd  .. \
     && rm -fr sflowtool \
-    && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+    && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
     && tar xvfz 1.0.0.tar.gz \
     && cd nanomsg-1.0.0    \
     && mkdir -p build      \
@@ -140,7 +140,7 @@ RUN ln -s /usr/bin/tcpdump /usr/sbin/tcpdump
 RUN mkdir -p /var/log/supervisor
 
 # Install Python-based GNMI client
-RUN git clone https://github.com/lguohan/gnxi.git \
+RUN git clone https://hub.fastgit.org/lguohan/gnxi.git \
     && cd gnxi \
     && git checkout 53901ab \
     && cd gnmi_cli_py \
diff --git a/dockers/docker-sonic-mgmt/Dockerfile.j2 b/dockers/docker-sonic-mgmt/Dockerfile.j2
index b6abdb8d..8047cade 100644
--- a/dockers/docker-sonic-mgmt/Dockerfile.j2
+++ b/dockers/docker-sonic-mgmt/Dockerfile.j2
@@ -68,12 +68,12 @@ RUN pip install cffi==1.10.0 \
                 tabulate \
                 textfsm \
                 virtualenv \
-    && git clone https://github.com/p4lang/scapy-vxlan.git \
+    && git clone https://hub.fastgit.org/p4lang/scapy-vxlan.git \
     && cd scapy-vxlan \
     && python setup.py install \
     && cd .. \
     && rm -fr scapy-vxlan \
-    && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+    && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
     && tar xvfz 1.0.0.tar.gz \
     && cd nanomsg-1.0.0    \
     && mkdir -p build      \
@@ -126,7 +126,7 @@ RUN pip install ansible==2.8.12
 RUN pip install pysubnettree
 
 # Install pytest-ansible module with 'become', 'become_user' parameters support
-RUN git clone https://github.com/ansible/pytest-ansible.git \
+RUN git clone https://hub.fastgit.org/ansible/pytest-ansible.git \
     && cd pytest-ansible \
     && git checkout d33c025f070a9c870220a157cc5a999fda68de44 \
     && python setup.py install \
diff --git a/files/apt/sources.list.amd64 b/files/apt/sources.list.amd64
index 4a94e316..246723d8 100644
--- a/files/apt/sources.list.amd64
+++ b/files/apt/sources.list.amd64
@@ -1,8 +1,8 @@
 ## Debian mirror on Microsoft Azure
-## Ref: http://debian-archive.trafficmanager.net/
+## Ref: http://mirrors.ustc.edu.cn/
 
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian/ buster main contrib non-free
-deb-src [arch=amd64] http://debian-archive.trafficmanager.net/debian/ buster main contrib non-free
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ buster/updates main contrib non-free
-deb-src [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ buster/updates main contrib non-free
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian/ buster-backports main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian/ buster main contrib non-free
+deb-src [arch=amd64] http://mirrors.ustc.edu.cn/debian/ buster main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-free
+deb-src [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian/ buster-backports main contrib non-free
diff --git a/files/image_config/apt/sources.list.d/amd64/debian_archive_trafficmanager_net_debian.list b/files/image_config/apt/sources.list.d/amd64/debian_archive_trafficmanager_net_debian.list
index d35c6181..d255f805 100644
--- a/files/image_config/apt/sources.list.d/amd64/debian_archive_trafficmanager_net_debian.list
+++ b/files/image_config/apt/sources.list.d/amd64/debian_archive_trafficmanager_net_debian.list
@@ -1,3 +1,3 @@
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian/ buster main contrib non-free
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ buster/updates main contrib non-free
-deb [arch=amd64] http://debian-archive.trafficmanager.net/debian/ buster-backports main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian/ buster main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-free
+deb [arch=amd64] http://mirrors.ustc.edu.cn/debian/ buster-backports main contrib non-free
diff --git a/platform/barefoot/bfn-platform-ingrasys.mk b/platform/barefoot/bfn-platform-ingrasys.mk
index 20dc5f86..8469b5e0 100644
--- a/platform/barefoot/bfn-platform-ingrasys.mk
+++ b/platform/barefoot/bfn-platform-ingrasys.mk
@@ -1,5 +1,5 @@
 BFN_INGRASYS_PLATFORM = bfnplatform-ingrasys_8.2.0_amd64.deb
-$(BFN_INGRASYS_PLATFORM)_URL = "https://github.com/Ingrasys-sonic/packages/raw/master/lib/bfnplatform-ingrasys_8.4.0_8.5.0_amd64.deb"
+$(BFN_INGRASYS_PLATFORM)_URL = "https://hub.fastgit.org/Ingrasys-sonic/packages/raw/master/lib/bfnplatform-ingrasys_8.4.0_8.5.0_amd64.deb"
 
 SONIC_ONLINE_DEBS += $(BFN_INGRASYS_PLATFORM) # $(BFN_SAI_DEV)
 $(BFN_SAI_DEV)_DEPENDS += $(BFN_INGRASYS_PLATFORM)
diff --git a/platform/barefoot/bfn-platform-wnc.mk b/platform/barefoot/bfn-platform-wnc.mk
index e2f45d35..acbe49c9 100644
--- a/platform/barefoot/bfn-platform-wnc.mk
+++ b/platform/barefoot/bfn-platform-wnc.mk
@@ -1,5 +1,5 @@
 WNC_OSW1800_PLATFORM = bfnplatformwnc_1.0.0_amd64.deb
-$(WNC_OSW1800_PLATFORM)_URL = "https://github.com/YaoTien/download/raw/master/sonic/sde/7_0_0_18/bfnplatformwnc_1.0.0_amd64.deb"
+$(WNC_OSW1800_PLATFORM)_URL = "https://hub.fastgit.org/YaoTien/download/raw/master/sonic/sde/7_0_0_18/bfnplatformwnc_1.0.0_amd64.deb"
 
 SONIC_ONLINE_DEBS += $(WNC_OSW1800_PLATFORM) # $(BFN_SAI_DEV)
 $(BFN_SAI_DEV)_DEPENDS += $(WNC_OSW1800_PLATFORM)
diff --git a/platform/barefoot/bfn-platform.mk b/platform/barefoot/bfn-platform.mk
index 1db53477..6b780174 100644
--- a/platform/barefoot/bfn-platform.mk
+++ b/platform/barefoot/bfn-platform.mk
@@ -1,5 +1,5 @@
 BFN_PLATFORM = bfnplatform_20201228_deb10.deb
-$(BFN_PLATFORM)_URL = "https://github.com/barefootnetworks/sonic-release-pkgs/raw/dev/$(BFN_PLATFORM)"
+$(BFN_PLATFORM)_URL = "https://hub.fastgit.org/barefootnetworks/sonic-release-pkgs/raw/dev/$(BFN_PLATFORM)"
 
 SONIC_ONLINE_DEBS += $(BFN_PLATFORM)
 $(BFN_SAI_DEV)_DEPENDS += $(BFN_PLATFORM)
diff --git a/platform/barefoot/bfn-sai.mk b/platform/barefoot/bfn-sai.mk
index 4f632223..ff6cd353 100644
--- a/platform/barefoot/bfn-sai.mk
+++ b/platform/barefoot/bfn-sai.mk
@@ -1,5 +1,5 @@
 BFN_SAI = bfnsdk_20201228_deb10.deb
-$(BFN_SAI)_URL = "https://github.com/barefootnetworks/sonic-release-pkgs/raw/dev/$(BFN_SAI)"
+$(BFN_SAI)_URL = "https://hub.fastgit.org/barefootnetworks/sonic-release-pkgs/raw/dev/$(BFN_SAI)"
 
 $(BFN_SAI)_DEPENDS += $(LIBNL_GENL3_DEV)
 $(eval $(call add_conflict_package,$(BFN_SAI),$(LIBSAIVS_DEV)))
diff --git a/platform/barefoot/docker-syncd-bfn-rpc/Dockerfile.j2 b/platform/barefoot/docker-syncd-bfn-rpc/Dockerfile.j2
index f3c9979d..4b3cd638 100644
--- a/platform/barefoot/docker-syncd-bfn-rpc/Dockerfile.j2
+++ b/platform/barefoot/docker-syncd-bfn-rpc/Dockerfile.j2
@@ -28,7 +28,7 @@ RUN apt-get update \
     wget                \
     cmake               \
     libpython3.4        \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/barefoot/sonic-platform-modules-bfn-montara/setup.py b/platform/barefoot/sonic-platform-modules-bfn-montara/setup.py
index fc14c94a..b2bf5c85 100755
--- a/platform/barefoot/sonic-platform-modules-bfn-montara/setup.py
+++ b/platform/barefoot/sonic-platform-modules-bfn-montara/setup.py
@@ -7,7 +7,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='',
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer='Barefoot',
     maintainer_email='',
     packages=[
diff --git a/platform/barefoot/sonic-platform-modules-bfn-newport/setup.py b/platform/barefoot/sonic-platform-modules-bfn-newport/setup.py
deleted file mode 120000
index a68e2eec..00000000
--- a/platform/barefoot/sonic-platform-modules-bfn-newport/setup.py
+++ /dev/null
@@ -1 +0,0 @@
-../sonic-platform-modules-bfn-montara/setup.py
\ No newline at end of file
diff --git a/platform/barefoot/sonic-platform-modules-bfn-newport/setup.py b/platform/barefoot/sonic-platform-modules-bfn-newport/setup.py
new file mode 100755
index 00000000..b2bf5c85
--- /dev/null
+++ b/platform/barefoot/sonic-platform-modules-bfn-newport/setup.py
@@ -0,0 +1,31 @@
+from setuptools import setup
+
+setup(
+    name='sonic-platform',
+    version='1.0',
+    description='SONiC platform API implementation',
+    license='Apache 2.0',
+    author='SONiC Team',
+    author_email='',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
+    maintainer='Barefoot',
+    maintainer_email='',
+    packages=[
+        'sonic_platform',
+        'sonic_platform/pltfm_mgr_rpc'
+    ],
+    package_data = {'sonic_platform':['logging.conf']},
+    classifiers=[
+        'Development Status :: 3 - Alpha',
+        'Environment :: Plugins',
+        'Intended Audience :: Developers',
+        'Intended Audience :: Information Technology',
+        'Intended Audience :: System Administrators',
+        'License :: OSI Approved :: Apache Software License',
+        'Natural Language :: English',
+        'Operating System :: POSIX :: Linux',
+        'Programming Language :: Python :: 2.7',
+        'Topic :: Utilities',
+    ],
+    keywords='sonic SONiC platform PLATFORM',
+)
diff --git a/platform/barefoot/sonic-platform-modules-bfn/setup.py b/platform/barefoot/sonic-platform-modules-bfn/setup.py
deleted file mode 120000
index a68e2eec..00000000
--- a/platform/barefoot/sonic-platform-modules-bfn/setup.py
+++ /dev/null
@@ -1 +0,0 @@
-../sonic-platform-modules-bfn-montara/setup.py
\ No newline at end of file
diff --git a/platform/barefoot/sonic-platform-modules-bfn/setup.py b/platform/barefoot/sonic-platform-modules-bfn/setup.py
new file mode 100755
index 00000000..b2bf5c85
--- /dev/null
+++ b/platform/barefoot/sonic-platform-modules-bfn/setup.py
@@ -0,0 +1,31 @@
+from setuptools import setup
+
+setup(
+    name='sonic-platform',
+    version='1.0',
+    description='SONiC platform API implementation',
+    license='Apache 2.0',
+    author='SONiC Team',
+    author_email='',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
+    maintainer='Barefoot',
+    maintainer_email='',
+    packages=[
+        'sonic_platform',
+        'sonic_platform/pltfm_mgr_rpc'
+    ],
+    package_data = {'sonic_platform':['logging.conf']},
+    classifiers=[
+        'Development Status :: 3 - Alpha',
+        'Environment :: Plugins',
+        'Intended Audience :: Developers',
+        'Intended Audience :: Information Technology',
+        'Intended Audience :: System Administrators',
+        'License :: OSI Approved :: Apache Software License',
+        'Natural Language :: English',
+        'Operating System :: POSIX :: Linux',
+        'Programming Language :: Python :: 2.7',
+        'Topic :: Utilities',
+    ],
+    keywords='sonic SONiC platform PLATFORM',
+)
diff --git a/platform/broadcom/docker-syncd-brcm-rpc/Dockerfile.j2 b/platform/broadcom/docker-syncd-brcm-rpc/Dockerfile.j2
index f68fbb66..ff2f6b83 100644
--- a/platform/broadcom/docker-syncd-brcm-rpc/Dockerfile.j2
+++ b/platform/broadcom/docker-syncd-brcm-rpc/Dockerfile.j2
@@ -27,7 +27,7 @@ RUN apt-get update \
     python-dev          \
     wget                \
     cmake               \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/broadcom/sonic-platform-modules-cel/dx010/setup.py b/platform/broadcom/sonic-platform-modules-cel/dx010/setup.py
index 81837881..fcd25eca 100644
--- a/platform/broadcom/sonic-platform-modules-cel/dx010/setup.py
+++ b/platform/broadcom/sonic-platform-modules-cel/dx010/setup.py
@@ -10,7 +10,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='linuxnetdev@microsoft.com',
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer='Wirut Getbamrung',
     maintainer_email='wgetbumr@celestica.com',
     packages=[
diff --git a/platform/broadcom/sonic-platform-modules-cel/haliburton/setup.py b/platform/broadcom/sonic-platform-modules-cel/haliburton/setup.py
index 17056855..ace8c1f1 100644
--- a/platform/broadcom/sonic-platform-modules-cel/haliburton/setup.py
+++ b/platform/broadcom/sonic-platform-modules-cel/haliburton/setup.py
@@ -10,7 +10,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='linuxnetdev@microsoft.com',
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer='Wirut Getbamrung',
     maintainer_email='wgetbumr@celestica.com',
     packages=[
diff --git a/platform/broadcom/sonic-platform-modules-cel/services/platform_api/setup.py b/platform/broadcom/sonic-platform-modules-cel/services/platform_api/setup.py
index b0c8d1d8..58f881bf 100755
--- a/platform/broadcom/sonic-platform-modules-cel/services/platform_api/setup.py
+++ b/platform/broadcom/sonic-platform-modules-cel/services/platform_api/setup.py
@@ -7,7 +7,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='linuxnetdev@microsoft.com',
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer='Wirut Getbamrung',
     maintainer_email='wgetbumr@celestica.com',
     packages=[
diff --git a/platform/broadcom/sonic-platform-modules-cel/silverstone/setup.py b/platform/broadcom/sonic-platform-modules-cel/silverstone/setup.py
index 20a2b6d1..ca5a52c1 100644
--- a/platform/broadcom/sonic-platform-modules-cel/silverstone/setup.py
+++ b/platform/broadcom/sonic-platform-modules-cel/silverstone/setup.py
@@ -10,7 +10,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='linuxnetdev@microsoft.com',
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer='Wirut Getbamrung',
     maintainer_email='wgetbumr@celestica.com',
     packages=[
diff --git a/platform/broadcom/sonic-platform-modules-dell/s5232f/setup.py b/platform/broadcom/sonic-platform-modules-dell/s5232f/setup.py
deleted file mode 120000
index 4f6de994..00000000
--- a/platform/broadcom/sonic-platform-modules-dell/s5232f/setup.py
+++ /dev/null
@@ -1 +0,0 @@
-../s6100/setup.py
\ No newline at end of file
diff --git a/platform/broadcom/sonic-platform-modules-dell/s5232f/setup.py b/platform/broadcom/sonic-platform-modules-dell/s5232f/setup.py
new file mode 100755
index 00000000..e5aa3652
--- /dev/null
+++ b/platform/broadcom/sonic-platform-modules-dell/s5232f/setup.py
@@ -0,0 +1,31 @@
+from setuptools import setup
+
+setup(
+    name='sonic-platform',
+    version='1.0',
+    description='SONiC platform API implementation on DellEmc Platforms',
+    license='Apache 2.0',
+    author='SONiC Team',
+    author_email='linuxnetdev@microsoft.com',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
+    maintainer='DellEMC',
+    maintainer_email='dell-sonic@dell.com',
+    packages=[
+        'sonic_platform',
+    ],
+    classifiers=[
+        'Development Status :: 3 - Alpha',
+        'Environment :: Plugins',
+        'Intended Audience :: Developers',
+        'Intended Audience :: Information Technology',
+        'Intended Audience :: System Administrators',
+        'License :: OSI Approved :: Apache Software License',
+        'Natural Language :: English',
+        'Operating System :: POSIX :: Linux',
+        'Programming Language :: Python :: 2.7',
+        'Programming Language :: Python :: 3.7',
+        'Topic :: Utilities',
+    ],
+    keywords='sonic SONiC platform PLATFORM',
+)
+
diff --git a/platform/broadcom/sonic-platform-modules-dell/s5232f/sonic_platform/hwaccess.py b/platform/broadcom/sonic-platform-modules-dell/s5232f/sonic_platform/hwaccess.py
deleted file mode 120000
index e8fa340a..00000000
--- a/platform/broadcom/sonic-platform-modules-dell/s5232f/sonic_platform/hwaccess.py
+++ /dev/null
@@ -1 +0,0 @@
-../../common/sonic_platform/hwaccess.py
\ No newline at end of file
diff --git a/platform/broadcom/sonic-platform-modules-dell/s5232f/sonic_platform/hwaccess.py b/platform/broadcom/sonic-platform-modules-dell/s5232f/sonic_platform/hwaccess.py
new file mode 100644
index 00000000..b0020144
--- /dev/null
+++ b/platform/broadcom/sonic-platform-modules-dell/s5232f/sonic_platform/hwaccess.py
@@ -0,0 +1,24 @@
+# Helper functions to access hardware
+
+import struct
+import mmap
+import subprocess
+
+# Read PCI device
+
+def pci_mem_read(mm, offset):
+    mm.seek(offset)
+    read_data_stream = mm.read(4)
+    return struct.unpack('I',read_data_stream)[0]
+
+def pci_get_value(resource, offset):
+    with open(resource, 'r+b') as fd:
+        mm = mmap.mmap(fd.fileno(), 0)
+        val = pci_mem_read(mm, offset)
+        mm.close()
+    return val
+
+# Read I2C device
+
+def i2c_get(bus, i2caddr, ofs):
+    return int(subprocess.check_output(['/usr/sbin/i2cget', '-y', str(bus), str(i2caddr), str(ofs)]), 16)
diff --git a/platform/broadcom/sonic-platform-modules-dell/s6000/setup.py b/platform/broadcom/sonic-platform-modules-dell/s6000/setup.py
deleted file mode 120000
index 4f6de994..00000000
--- a/platform/broadcom/sonic-platform-modules-dell/s6000/setup.py
+++ /dev/null
@@ -1 +0,0 @@
-../s6100/setup.py
\ No newline at end of file
diff --git a/platform/broadcom/sonic-platform-modules-dell/s6000/setup.py b/platform/broadcom/sonic-platform-modules-dell/s6000/setup.py
new file mode 100755
index 00000000..e5aa3652
--- /dev/null
+++ b/platform/broadcom/sonic-platform-modules-dell/s6000/setup.py
@@ -0,0 +1,31 @@
+from setuptools import setup
+
+setup(
+    name='sonic-platform',
+    version='1.0',
+    description='SONiC platform API implementation on DellEmc Platforms',
+    license='Apache 2.0',
+    author='SONiC Team',
+    author_email='linuxnetdev@microsoft.com',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
+    maintainer='DellEMC',
+    maintainer_email='dell-sonic@dell.com',
+    packages=[
+        'sonic_platform',
+    ],
+    classifiers=[
+        'Development Status :: 3 - Alpha',
+        'Environment :: Plugins',
+        'Intended Audience :: Developers',
+        'Intended Audience :: Information Technology',
+        'Intended Audience :: System Administrators',
+        'License :: OSI Approved :: Apache Software License',
+        'Natural Language :: English',
+        'Operating System :: POSIX :: Linux',
+        'Programming Language :: Python :: 2.7',
+        'Programming Language :: Python :: 3.7',
+        'Topic :: Utilities',
+    ],
+    keywords='sonic SONiC platform PLATFORM',
+)
+
diff --git a/platform/broadcom/sonic-platform-modules-dell/s6100/setup.py b/platform/broadcom/sonic-platform-modules-dell/s6100/setup.py
index d031762f..e5aa3652 100755
--- a/platform/broadcom/sonic-platform-modules-dell/s6100/setup.py
+++ b/platform/broadcom/sonic-platform-modules-dell/s6100/setup.py
@@ -7,7 +7,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='linuxnetdev@microsoft.com',
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer='DellEMC',
     maintainer_email='dell-sonic@dell.com',
     packages=[
diff --git a/platform/broadcom/sonic-platform-modules-dell/tools/flashrom.sh b/platform/broadcom/sonic-platform-modules-dell/tools/flashrom.sh
index c3af65fd..ad385651 100755
--- a/platform/broadcom/sonic-platform-modules-dell/tools/flashrom.sh
+++ b/platform/broadcom/sonic-platform-modules-dell/tools/flashrom.sh
@@ -3,7 +3,7 @@ export DELL_TOOLS_DIR="platform/broadcom/sonic-platform-modules-dell/tools"
 
 cd $DELL_TOOLS_DIR
 rm -rf $DELL_TOOLS_DIR/flashrom
-git clone https://github.com/flashrom/flashrom.git
+git clone https://hub.fastgit.org/flashrom/flashrom.git
 cd flashrom
 git checkout tags/0.9.7
 git apply ../0002-Flashrom-support-for-Intel-Rangeley-and-Denverton-CP.patch
diff --git a/platform/broadcom/sonic-platform-modules-dell/z9100/setup.py b/platform/broadcom/sonic-platform-modules-dell/z9100/setup.py
deleted file mode 120000
index 4f6de994..00000000
--- a/platform/broadcom/sonic-platform-modules-dell/z9100/setup.py
+++ /dev/null
@@ -1 +0,0 @@
-../s6100/setup.py
\ No newline at end of file
diff --git a/platform/broadcom/sonic-platform-modules-dell/z9100/setup.py b/platform/broadcom/sonic-platform-modules-dell/z9100/setup.py
new file mode 100755
index 00000000..e5aa3652
--- /dev/null
+++ b/platform/broadcom/sonic-platform-modules-dell/z9100/setup.py
@@ -0,0 +1,31 @@
+from setuptools import setup
+
+setup(
+    name='sonic-platform',
+    version='1.0',
+    description='SONiC platform API implementation on DellEmc Platforms',
+    license='Apache 2.0',
+    author='SONiC Team',
+    author_email='linuxnetdev@microsoft.com',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
+    maintainer='DellEMC',
+    maintainer_email='dell-sonic@dell.com',
+    packages=[
+        'sonic_platform',
+    ],
+    classifiers=[
+        'Development Status :: 3 - Alpha',
+        'Environment :: Plugins',
+        'Intended Audience :: Developers',
+        'Intended Audience :: Information Technology',
+        'Intended Audience :: System Administrators',
+        'License :: OSI Approved :: Apache Software License',
+        'Natural Language :: English',
+        'Operating System :: POSIX :: Linux',
+        'Programming Language :: Python :: 2.7',
+        'Programming Language :: Python :: 3.7',
+        'Topic :: Utilities',
+    ],
+    keywords='sonic SONiC platform PLATFORM',
+)
+
diff --git a/platform/broadcom/sonic-platform-modules-dell/z9264f/setup.py b/platform/broadcom/sonic-platform-modules-dell/z9264f/setup.py
deleted file mode 120000
index 4f6de994..00000000
--- a/platform/broadcom/sonic-platform-modules-dell/z9264f/setup.py
+++ /dev/null
@@ -1 +0,0 @@
-../s6100/setup.py
\ No newline at end of file
diff --git a/platform/broadcom/sonic-platform-modules-dell/z9264f/setup.py b/platform/broadcom/sonic-platform-modules-dell/z9264f/setup.py
new file mode 100755
index 00000000..e5aa3652
--- /dev/null
+++ b/platform/broadcom/sonic-platform-modules-dell/z9264f/setup.py
@@ -0,0 +1,31 @@
+from setuptools import setup
+
+setup(
+    name='sonic-platform',
+    version='1.0',
+    description='SONiC platform API implementation on DellEmc Platforms',
+    license='Apache 2.0',
+    author='SONiC Team',
+    author_email='linuxnetdev@microsoft.com',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
+    maintainer='DellEMC',
+    maintainer_email='dell-sonic@dell.com',
+    packages=[
+        'sonic_platform',
+    ],
+    classifiers=[
+        'Development Status :: 3 - Alpha',
+        'Environment :: Plugins',
+        'Intended Audience :: Developers',
+        'Intended Audience :: Information Technology',
+        'Intended Audience :: System Administrators',
+        'License :: OSI Approved :: Apache Software License',
+        'Natural Language :: English',
+        'Operating System :: POSIX :: Linux',
+        'Programming Language :: Python :: 2.7',
+        'Programming Language :: Python :: 3.7',
+        'Topic :: Utilities',
+    ],
+    keywords='sonic SONiC platform PLATFORM',
+)
+
diff --git a/platform/broadcom/sonic-platform-modules-dell/z9332f/setup.py b/platform/broadcom/sonic-platform-modules-dell/z9332f/setup.py
deleted file mode 120000
index 4f6de994..00000000
--- a/platform/broadcom/sonic-platform-modules-dell/z9332f/setup.py
+++ /dev/null
@@ -1 +0,0 @@
-../s6100/setup.py
\ No newline at end of file
diff --git a/platform/broadcom/sonic-platform-modules-dell/z9332f/setup.py b/platform/broadcom/sonic-platform-modules-dell/z9332f/setup.py
new file mode 100755
index 00000000..e5aa3652
--- /dev/null
+++ b/platform/broadcom/sonic-platform-modules-dell/z9332f/setup.py
@@ -0,0 +1,31 @@
+from setuptools import setup
+
+setup(
+    name='sonic-platform',
+    version='1.0',
+    description='SONiC platform API implementation on DellEmc Platforms',
+    license='Apache 2.0',
+    author='SONiC Team',
+    author_email='linuxnetdev@microsoft.com',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
+    maintainer='DellEMC',
+    maintainer_email='dell-sonic@dell.com',
+    packages=[
+        'sonic_platform',
+    ],
+    classifiers=[
+        'Development Status :: 3 - Alpha',
+        'Environment :: Plugins',
+        'Intended Audience :: Developers',
+        'Intended Audience :: Information Technology',
+        'Intended Audience :: System Administrators',
+        'License :: OSI Approved :: Apache Software License',
+        'Natural Language :: English',
+        'Operating System :: POSIX :: Linux',
+        'Programming Language :: Python :: 2.7',
+        'Programming Language :: Python :: 3.7',
+        'Topic :: Utilities',
+    ],
+    keywords='sonic SONiC platform PLATFORM',
+)
+
diff --git a/platform/broadcom/sonic-platform-modules-dell/z9332f/sonic_platform/hwaccess.py b/platform/broadcom/sonic-platform-modules-dell/z9332f/sonic_platform/hwaccess.py
deleted file mode 120000
index e8fa340a..00000000
--- a/platform/broadcom/sonic-platform-modules-dell/z9332f/sonic_platform/hwaccess.py
+++ /dev/null
@@ -1 +0,0 @@
-../../common/sonic_platform/hwaccess.py
\ No newline at end of file
diff --git a/platform/broadcom/sonic-platform-modules-dell/z9332f/sonic_platform/hwaccess.py b/platform/broadcom/sonic-platform-modules-dell/z9332f/sonic_platform/hwaccess.py
new file mode 100644
index 00000000..b0020144
--- /dev/null
+++ b/platform/broadcom/sonic-platform-modules-dell/z9332f/sonic_platform/hwaccess.py
@@ -0,0 +1,24 @@
+# Helper functions to access hardware
+
+import struct
+import mmap
+import subprocess
+
+# Read PCI device
+
+def pci_mem_read(mm, offset):
+    mm.seek(offset)
+    read_data_stream = mm.read(4)
+    return struct.unpack('I',read_data_stream)[0]
+
+def pci_get_value(resource, offset):
+    with open(resource, 'r+b') as fd:
+        mm = mmap.mmap(fd.fileno(), 0)
+        val = pci_mem_read(mm, offset)
+        mm.close()
+    return val
+
+# Read I2C device
+
+def i2c_get(bus, i2caddr, ofs):
+    return int(subprocess.check_output(['/usr/sbin/i2cget', '-y', str(bus), str(i2caddr), str(ofs)]), 16)
diff --git a/platform/cavium/cavm-sai.mk b/platform/cavium/cavm-sai.mk
index 00081357..0f58e29c 100644
--- a/platform/cavium/cavm-sai.mk
+++ b/platform/cavium/cavm-sai.mk
@@ -1,6 +1,6 @@
 # Cavium SAI
 
-CAVM_SAI_GITHUB = https://github.com/XPliant/OpenXPS/raw/13a7eaf10f523e7887964ca235f19095fcc88537/SAI/cavm-sai/
+CAVM_SAI_GITHUB = https://hub.fastgit.org/XPliant/OpenXPS/raw/13a7eaf10f523e7887964ca235f19095fcc88537/SAI/cavm-sai/
 
 CAVM_LIBSAI = libsai.deb
 CAVM_SAI = sai.deb
diff --git a/platform/cavium/cavm-xpnet.mk b/platform/cavium/cavm-xpnet.mk
index ed86558a..5a1e2c90 100644
--- a/platform/cavium/cavm-xpnet.mk
+++ b/platform/cavium/cavm-xpnet.mk
@@ -1,4 +1,4 @@
-CAVM_SAI_URL = https://github.com/XPliant/OpenXPS/raw/c26aea6a7098936ab3692e148238d73fa8962585/SAI
+CAVM_SAI_URL = https://hub.fastgit.org/XPliant/OpenXPS/raw/c26aea6a7098936ab3692e148238d73fa8962585/SAI
 
 CAVM_XPNET_DEB = xp80-Pcie-Endpoint.deb
 $(CAVM_XPNET_DEB)_URL = $(CAVM_SAI_URL)/netdev/$(CAVM_XPNET_DEB)
diff --git a/platform/cavium/cavm_platform_modules/Makefile b/platform/cavium/cavm_platform_modules/Makefile
index aeb274aa..45fca459 100644
--- a/platform/cavium/cavm_platform_modules/Makefile
+++ b/platform/cavium/cavm_platform_modules/Makefile
@@ -10,7 +10,7 @@ SYSTEMD_DIR = /etc/systemd/system
 $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 	# get sources
 	rm -rf SONiC
-	git clone https://github.com/edge-core/SONiC.git
+	git clone https://hub.fastgit.org/edge-core/SONiC.git
 
 	# build
 	pushd SONiC/AS7512-32X/module/
diff --git a/platform/cavium/docker-syncd-cavm-rpc/Dockerfile.j2 b/platform/cavium/docker-syncd-cavm-rpc/Dockerfile.j2
index 3c49748a..3f074b0a 100644
--- a/platform/cavium/docker-syncd-cavm-rpc/Dockerfile.j2
+++ b/platform/cavium/docker-syncd-cavm-rpc/Dockerfile.j2
@@ -27,7 +27,7 @@ RUN apt-get update \
     python-dev          \
     wget                \
     cmake               \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/centec-arm64/docker-syncd-centec-rpc/Dockerfile.j2 b/platform/centec-arm64/docker-syncd-centec-rpc/Dockerfile.j2
index d6719b22..b9789aa5 100755
--- a/platform/centec-arm64/docker-syncd-centec-rpc/Dockerfile.j2
+++ b/platform/centec-arm64/docker-syncd-centec-rpc/Dockerfile.j2
@@ -27,7 +27,7 @@ RUN apt-get update \
     python-dev          \
     wget                \
     cmake               \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/centec-arm64/sai.mk b/platform/centec-arm64/sai.mk
index 2b902b49..0c7ac06f 100755
--- a/platform/centec-arm64/sai.mk
+++ b/platform/centec-arm64/sai.mk
@@ -3,7 +3,7 @@
 export CENTEC_SAI_VERSION = 1.6.3-1
 export CENTEC_SAI = libsai_$(CENTEC_SAI_VERSION)_$(PLATFORM_ARCH).deb
 
-$(CENTEC_SAI)_URL = https://github.com/CentecNetworks/sonic-binaries/raw/master/$(PLATFORM_ARCH)/sai/$(CENTEC_SAI)
+$(CENTEC_SAI)_URL = https://hub.fastgit.org/CentecNetworks/sonic-binaries/raw/master/$(PLATFORM_ARCH)/sai/$(CENTEC_SAI)
 $(eval $(call add_conflict_package,$(CENTEC_SAI),$(LIBSAIVS_DEV)))
 SONIC_ONLINE_DEBS += $(CENTEC_SAI)
 
diff --git a/platform/centec/docker-syncd-centec-rpc/Dockerfile.j2 b/platform/centec/docker-syncd-centec-rpc/Dockerfile.j2
index d6719b22..b9789aa5 100644
--- a/platform/centec/docker-syncd-centec-rpc/Dockerfile.j2
+++ b/platform/centec/docker-syncd-centec-rpc/Dockerfile.j2
@@ -27,7 +27,7 @@ RUN apt-get update \
     python-dev          \
     wget                \
     cmake               \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/centec/sdk.mk b/platform/centec/sdk.mk
index 588b2b24..76692025 100644
--- a/platform/centec/sdk.mk
+++ b/platform/centec/sdk.mk
@@ -1,6 +1,6 @@
 # Centec SAI
 CENTEC_SAI = libsai_1.6.3-1_amd64.deb
-$(CENTEC_SAI)_URL = https://github.com/CentecNetworks/sonic-binaries/raw/master/amd64/$(CENTEC_SAI)
+$(CENTEC_SAI)_URL = https://hub.fastgit.org/CentecNetworks/sonic-binaries/raw/master/amd64/$(CENTEC_SAI)
 $(eval $(call add_conflict_package,$(CENTEC_SAI),$(LIBSAIVS_DEV)))
 
 SONIC_ONLINE_DEBS += $(CENTEC_SAI)
diff --git a/platform/innovium/docker-syncd-invm-rpc/Dockerfile.j2 b/platform/innovium/docker-syncd-invm-rpc/Dockerfile.j2
index 3a25afbe..d7d0f6e9 100755
--- a/platform/innovium/docker-syncd-invm-rpc/Dockerfile.j2
+++ b/platform/innovium/docker-syncd-invm-rpc/Dockerfile.j2
@@ -29,7 +29,7 @@ RUN apt-get update \
     libjansson4         \
     wget                \
     cmake               \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/innovium/invm-sai.mk b/platform/innovium/invm-sai.mk
index 25e490e4..1004f400 100755
--- a/platform/innovium/invm-sai.mk
+++ b/platform/innovium/invm-sai.mk
@@ -1,6 +1,6 @@
 # INVM SAI
 
-INVM_SAI_ONLINE = https://github.com/Innovium/SONiC/raw/master/debian/master
+INVM_SAI_ONLINE = https://hub.fastgit.org/Innovium/SONiC/raw/master/debian/master
 
 INVM_LIBSAI = isai.deb
 INVM_HSAI   = saihdr.deb
diff --git a/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2 b/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2
index 6b9e3d8a..14456326 100644
--- a/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2
+++ b/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2
@@ -27,7 +27,7 @@ RUN apt-get update \
     python-dev          \
     wget                \
     cmake               \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/marvell-arm64/linux-kernel-arm64.mk b/platform/marvell-arm64/linux-kernel-arm64.mk
index a953c908..5d1ac4a0 100644
--- a/platform/marvell-arm64/linux-kernel-arm64.mk
+++ b/platform/marvell-arm64/linux-kernel-arm64.mk
@@ -2,5 +2,5 @@
 
 # Add platform specific DTB
 LINUX_KERNEL_DTB = linux-image-4.9.168-arm64.deb
-$(LINUX_KERNEL_DTB)_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/arm64/kernel/$(LINUX_KERNEL_DTB)
+$(LINUX_KERNEL_DTB)_URL = https://hub.fastgit.org/Marvell-switching/sonic-marvell-binaries/raw/master/arm64/kernel/$(LINUX_KERNEL_DTB)
 SONIC_ONLINE_DEBS += $(LINUX_KERNEL_DTB)
diff --git a/platform/marvell-arm64/linux/Makefile b/platform/marvell-arm64/linux/Makefile
index 89415f49..eafa8770 100644
--- a/platform/marvell-arm64/linux/Makefile
+++ b/platform/marvell-arm64/linux/Makefile
@@ -2,7 +2,7 @@
 SHELL = /bin/bash
 .SHELLFLAGS += -e
 
-LINUX_KERNEL_MRVL_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/arm64/kernel/$(LINUX_KERNEL_DTB)
+LINUX_KERNEL_MRVL_URL = https://hub.fastgit.org/Marvell-switching/sonic-marvell-binaries/raw/master/arm64/kernel/$(LINUX_KERNEL_DTB)
 
 $(addprefix $(DEST)/, $(LINUX_KERNEL_DTB)): $(DEST)/% :
 	# get deb package
diff --git a/platform/marvell-arm64/sai/Makefile b/platform/marvell-arm64/sai/Makefile
index 3e990575..da3bcc51 100644
--- a/platform/marvell-arm64/sai/Makefile
+++ b/platform/marvell-arm64/sai/Makefile
@@ -2,7 +2,7 @@
 SHELL = /bin/bash
 .SHELLFLAGS += -e
 
-MRVL_SAI_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/arm64/sai-plugin/$(MRVL_SAI)
+MRVL_SAI_URL = https://hub.fastgit.org/Marvell-switching/sonic-marvell-binaries/raw/master/arm64/sai-plugin/$(MRVL_SAI)
 
 $(addprefix $(DEST)/, $(MRVL_SAI)): $(DEST)/% :
 	# get deb package
diff --git a/platform/marvell-armhf/docker-syncd-mrvl-rpc/Dockerfile.j2 b/platform/marvell-armhf/docker-syncd-mrvl-rpc/Dockerfile.j2
index 6b9e3d8a..14456326 100644
--- a/platform/marvell-armhf/docker-syncd-mrvl-rpc/Dockerfile.j2
+++ b/platform/marvell-armhf/docker-syncd-mrvl-rpc/Dockerfile.j2
@@ -27,7 +27,7 @@ RUN apt-get update \
     python-dev          \
     wget                \
     cmake               \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/marvell-armhf/linux-kernel-armhf.mk b/platform/marvell-armhf/linux-kernel-armhf.mk
index ac7aa3fa..c396bf8e 100644
--- a/platform/marvell-armhf/linux-kernel-armhf.mk
+++ b/platform/marvell-armhf/linux-kernel-armhf.mk
@@ -2,5 +2,5 @@
 
 # Add platform specific DTB
 LINUX_KERNEL_DTB = linux-image-4.9.189-armhf.deb
-$(LINUX_KERNEL_DTB)_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/armhf/kernel/$(LINUX_KERNEL_DTB)
+$(LINUX_KERNEL_DTB)_URL = https://hub.fastgit.org/Marvell-switching/sonic-marvell-binaries/raw/master/armhf/kernel/$(LINUX_KERNEL_DTB)
 SONIC_ONLINE_DEBS += $(LINUX_KERNEL_DTB)
diff --git a/platform/marvell-armhf/linux/Makefile b/platform/marvell-armhf/linux/Makefile
index dba66064..8fc5f1bf 100644
--- a/platform/marvell-armhf/linux/Makefile
+++ b/platform/marvell-armhf/linux/Makefile
@@ -2,7 +2,7 @@
 SHELL = /bin/bash
 .SHELLFLAGS += -e
 
-LINUX_KERNEL_MRVL_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/armhf/kernel/$(LINUX_KERNEL_DTB)
+LINUX_KERNEL_MRVL_URL = https://hub.fastgit.org/Marvell-switching/sonic-marvell-binaries/raw/master/armhf/kernel/$(LINUX_KERNEL_DTB)
 
 $(addprefix $(DEST)/, $(LINUX_KERNEL_DTB)): $(DEST)/% :
 	# get deb package
diff --git a/platform/marvell-armhf/sai/Makefile b/platform/marvell-armhf/sai/Makefile
index cf785043..751c2e3c 100644
--- a/platform/marvell-armhf/sai/Makefile
+++ b/platform/marvell-armhf/sai/Makefile
@@ -2,7 +2,7 @@
 SHELL = /bin/bash
 .SHELLFLAGS += -e
 
-MRVL_SAI_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/armhf/sai-plugin/$(MRVL_SAI)
+MRVL_SAI_URL = https://hub.fastgit.org/Marvell-switching/sonic-marvell-binaries/raw/master/armhf/sai-plugin/$(MRVL_SAI)
 
 $(addprefix $(DEST)/, $(MRVL_SAI)): $(DEST)/% :
 	# get deb package
diff --git a/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2 b/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2
index 6b9e3d8a..14456326 100644
--- a/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2
+++ b/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2
@@ -27,7 +27,7 @@ RUN apt-get update \
     python-dev          \
     wget                \
     cmake               \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/marvell/sai/Makefile b/platform/marvell/sai/Makefile
index 1cd6d026..f2634fb4 100644
--- a/platform/marvell/sai/Makefile
+++ b/platform/marvell/sai/Makefile
@@ -2,7 +2,7 @@
 SHELL = /bin/bash
 .SHELLFLAGS += -e
 
-MRVL_SAI_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/amd64/sai-plugin/$(MRVL_SAI)
+MRVL_SAI_URL = https://hub.fastgit.org/Marvell-switching/sonic-marvell-binaries/raw/master/amd64/sai-plugin/$(MRVL_SAI)
 
 $(addprefix $(DEST)/, $(MRVL_SAI)): $(DEST)/% :
 	# get deb package
diff --git a/platform/mellanox/docker-syncd-mlnx-rpc/Dockerfile.j2 b/platform/mellanox/docker-syncd-mlnx-rpc/Dockerfile.j2
index e35c6582..0119b91e 100644
--- a/platform/mellanox/docker-syncd-mlnx-rpc/Dockerfile.j2
+++ b/platform/mellanox/docker-syncd-mlnx-rpc/Dockerfile.j2
@@ -35,7 +35,7 @@ RUN apt-get update \
     python-dev          \
     wget                \
     cmake               \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/mellanox/mlnx-platform-api/setup.py b/platform/mellanox/mlnx-platform-api/setup.py
index df1a8cad..22dacb05 100644
--- a/platform/mellanox/mlnx-platform-api/setup.py
+++ b/platform/mellanox/mlnx-platform-api/setup.py
@@ -7,7 +7,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='linuxnetdev@microsoft.com',
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer='Kevin Wang',
     maintainer_email='kevinw@mellanox.com',
     packages=[
diff --git a/platform/nephos/docker-syncd-nephos-rpc/Dockerfile.j2 b/platform/nephos/docker-syncd-nephos-rpc/Dockerfile.j2
index 95703448..de221d43 100644
--- a/platform/nephos/docker-syncd-nephos-rpc/Dockerfile.j2
+++ b/platform/nephos/docker-syncd-nephos-rpc/Dockerfile.j2
@@ -27,7 +27,7 @@ RUN apt-get update \
     python-dev          \
     wget                \
     cmake               \
- && wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
+ && wget https://hub.fastgit.org/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && tar xvfz 1.0.0.tar.gz \
  && cd nanomsg-1.0.0    \
  && mkdir -p build      \
diff --git a/platform/nephos/rules.mk b/platform/nephos/rules.mk
index 8950c665..ba73b3c3 100644
--- a/platform/nephos/rules.mk
+++ b/platform/nephos/rules.mk
@@ -10,10 +10,10 @@ include $(PLATFORM_PATH)/libsaithrift-dev.mk
 include $(PLATFORM_PATH)/docker-ptf-nephos.mk
 
 NPX_DIAG = npx_diag
-$(NPX_DIAG)_URL = "https://github.com/NephosInc/SONiC/raw/master/sdk/npx_diag"
+$(NPX_DIAG)_URL = "https://hub.fastgit.org/NephosInc/SONiC/raw/master/sdk/npx_diag"
 
 WARM_VERIFIER = warm-verifier
-$(WARM_VERIFIER)_URL = "https://github.com/NephosInc/SONiC/raw/master/sai/warm-verifier"
+$(WARM_VERIFIER)_URL = "https://hub.fastgit.org/NephosInc/SONiC/raw/master/sai/warm-verifier"
 
 DSSERVE = dsserve
 $(DSSERVE)_URL = "https://sonicstorage.blob.core.windows.net/packages/20190307/dsserve?sv=2015-04-05&sr=b&sig=lk7BH3DtW%2F5ehc0Rkqfga%2BUCABI0UzQmDamBsZH9K6w%3D&se=2038-05-06T22%3A34%3A45Z&sp=r"
diff --git a/platform/nephos/sai.mk b/platform/nephos/sai.mk
index 8bbeb989..7fe76377 100644
--- a/platform/nephos/sai.mk
+++ b/platform/nephos/sai.mk
@@ -16,7 +16,7 @@ NEPHOS_SAI = libsainps_$(SDK_VERSION)_sai_$(SAI_VERSION)_$(SAI_COMMIT_ID)_amd64.
 ifeq ($(SAI_FROM_LOCAL), y)
 $(NEPHOS_SAI)_PATH = $(NEPHOS_SAI_DEB_LOCAL_URL)
 else
-$(NEPHOS_SAI)_URL = "https://github.com/NephosInc/SONiC/raw/master/sai/libsainps_$(SDK_VERSION)_sai_$(SAI_VERSION)_$(SAI_COMMIT_ID)_amd64.deb"
+$(NEPHOS_SAI)_URL = "https://hub.fastgit.org/NephosInc/SONiC/raw/master/sai/libsainps_$(SDK_VERSION)_sai_$(SAI_VERSION)_$(SAI_COMMIT_ID)_amd64.deb"
 endif
 
 NEPHOS_SAI_DEV = libsainps-dev_$(SDK_VERSION)_sai_$(SAI_VERSION)_$(SAI_COMMIT_ID)_amd64.deb
@@ -24,7 +24,7 @@ $(eval $(call add_derived_package,$(NEPHOS_SAI),$(NEPHOS_SAI_DEV)))
 ifeq ($(SAI_FROM_LOCAL), y)
 $(NEPHOS_SAI_DEV)_PATH = $(NEPHOS_SAI_DEB_LOCAL_URL)
 else
-$(NEPHOS_SAI_DEV)_URL = "https://github.com/NephosInc/SONiC/raw/master/sai/libsainps-dev_$(SDK_VERSION)_sai_$(SAI_VERSION)_$(SAI_COMMIT_ID)_amd64.deb"
+$(NEPHOS_SAI_DEV)_URL = "https://hub.fastgit.org/NephosInc/SONiC/raw/master/sai/libsainps-dev_$(SDK_VERSION)_sai_$(SAI_VERSION)_$(SAI_COMMIT_ID)_amd64.deb"
 endif
 
 ifeq ($(SAI_FROM_LOCAL), y)
diff --git a/platform/nephos/sonic-platform-modules-accton/as7116-54x/setup.py b/platform/nephos/sonic-platform-modules-accton/as7116-54x/setup.py
index 088e1f30..8629139d 100644
--- a/platform/nephos/sonic-platform-modules-accton/as7116-54x/setup.py
+++ b/platform/nephos/sonic-platform-modules-accton/as7116-54x/setup.py
@@ -10,7 +10,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='linuxnetdev@microsoft.com',
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer='Simon Ji',
     maintainer_email='Simon.Ji@mediatek.com',
     packages=[
diff --git a/platform/pddf/platform-api-pddf-base/setup.py b/platform/pddf/platform-api-pddf-base/setup.py
index 0d8b4a6b..e83d2373 100755
--- a/platform/pddf/platform-api-pddf-base/setup.py
+++ b/platform/pddf/platform-api-pddf-base/setup.py
@@ -8,7 +8,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='linuxnetdev@microsoft.com',
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer='Fuzail Khan',
     maintainer_email='fuzail.khan@broadcom.com',
     packages=[
diff --git a/platform/vs/docker-sonic-vs/Dockerfile.j2 b/platform/vs/docker-sonic-vs/Dockerfile.j2
index 837e8fc3..e5b4f30d 100644
--- a/platform/vs/docker-sonic-vs/Dockerfile.j2
+++ b/platform/vs/docker-sonic-vs/Dockerfile.j2
@@ -89,7 +89,7 @@ RUN pip2 install crontab
 # Install pyangbind here, outside sonic-config-engine dependencies, as pyangbind causes enum34 to be installed.
 # Then immediately uninstall enum34, as enum34 should not be installed for Python >= 3.4, as it causes a
 # conflict with the new 'enum' module in the standard library
-# https://github.com/robshakir/pyangbind/issues/232
+# https://hub.fastgit.org/robshakir/pyangbind/issues/232
 RUN pip3 install pyangbind==0.8.1
 RUN pip3 uninstall -y enum34
 
diff --git a/platform/vs/tests/conftest.py b/platform/vs/tests/conftest.py
deleted file mode 120000
index 9fef6363..00000000
--- a/platform/vs/tests/conftest.py
+++ /dev/null
@@ -1 +0,0 @@
-../../../src/sonic-swss/tests/conftest.py
\ No newline at end of file
diff --git a/platform/vs/tests/conftest.py b/platform/vs/tests/conftest.py
new file mode 100644
index 00000000..950fc703
--- /dev/null
+++ b/platform/vs/tests/conftest.py
@@ -0,0 +1,1630 @@
+import os
+import re
+import time
+import json
+import redis
+import docker
+import pytest
+import random
+import string
+import subprocess
+import sys
+import tarfile
+import io
+
+from typing import Dict, Tuple
+from datetime import datetime
+
+from swsscommon import swsscommon
+from dvslib.dvs_database import DVSDatabase
+from dvslib.dvs_common import PollingConfig, wait_for_result
+from dvslib.dvs_acl import DVSAcl
+from dvslib import dvs_vlan
+from dvslib import dvs_lag
+from dvslib import dvs_mirror
+from dvslib import dvs_policer
+
+from buffer_model import enable_dynamic_buffer
+
+# FIXME: For the sake of stabilizing the PR pipeline we currently assume there are 32 front-panel
+# ports in the system (much like the rest of the test suite). This should be adjusted to accomodate
+# a dynamic number of ports. GitHub Issue: Azure/sonic-swss#1384.
+NUM_PORTS = 32
+
+
+def ensure_system(cmd):
+    rc, output = subprocess.getstatusoutput(cmd)
+    if rc:
+        raise RuntimeError(f"Failed to run command: {cmd}. rc={rc}. output: {output}")
+
+
+def pytest_addoption(parser):
+    parser.addoption("--dvsname",
+                     action="store",
+                     default=None,
+                     help="Name of a persistent DVS container to run the tests with")
+
+    parser.addoption("--forcedvs",
+                     action="store_true",
+                     default=False,
+                     help="Force tests to run in persistent DVS containers with <32 ports")
+
+    parser.addoption("--keeptb",
+                     action="store_true",
+                     default=False,
+                     help="Keep testbed running after tests for debugging purposes")
+
+    parser.addoption("--imgname",
+                     action="store",
+                     default="docker-sonic-vs:latest",
+                     help="Name of an image to use for the DVS container")
+
+    parser.addoption("--max_cpu",
+                     action="store",
+                     default=2,
+                     type=int,
+                     help="Max number of CPU cores to use, if available. (default = 2)")
+
+    parser.addoption("--vctns",
+                     action="store",
+                     default=None,
+                     help="Namespace for the Virtual Chassis Topology")
+
+    parser.addoption("--topo",
+                     action="store",
+                     default=None,
+                     help="Topology file for the Virtual Chassis Topology")
+
+    parser.addoption("--buffer_model",
+                     action="store",
+                     default="traditional",
+                     help="Buffer model")
+
+
+def random_string(size=4, chars=string.ascii_uppercase + string.digits):
+    return "".join(random.choice(chars) for x in range(size))
+
+
+class AsicDbValidator(DVSDatabase):
+    def __init__(self, db_id: int, connector: str):
+        DVSDatabase.__init__(self, db_id, connector)
+        self._wait_for_asic_db_to_initialize()
+        self._populate_default_asic_db_values()
+        self._generate_oid_to_interface_mapping()
+
+    def _wait_for_asic_db_to_initialize(self) -> None:
+        """Wait up to 30 seconds for the default fields to appear in ASIC DB."""
+        def _verify_db_contents():
+            # We expect only the default VLAN
+            if len(self.get_keys("ASIC_STATE:SAI_OBJECT_TYPE_VLAN")) != 1:
+                return (False, None)
+
+            if len(self.get_keys("ASIC_STATE:SAI_OBJECT_TYPE_HOSTIF")) < NUM_PORTS:
+                return (False, None)
+
+            if len(self.get_keys("ASIC_STATE:SAI_OBJECT_TYPE_ACL_ENTRY")) != 0:
+                return (False, None)
+
+            return (True, None)
+
+        # Verify that ASIC DB has been fully initialized
+        init_polling_config = PollingConfig(2, 30, strict=True)
+        wait_for_result(_verify_db_contents, init_polling_config)
+
+    def _generate_oid_to_interface_mapping(self) -> None:
+        """Generate the OID->Name mappings for ports and host interfaces."""
+        self.portoidmap = {}
+        self.portnamemap = {}
+        self.hostifoidmap = {}
+        self.hostifnamemap = {}
+
+        host_intfs = self.get_keys("ASIC_STATE:SAI_OBJECT_TYPE_HOSTIF")
+        for intf in host_intfs:
+            fvs = self.get_entry("ASIC_STATE:SAI_OBJECT_TYPE_HOSTIF", intf)
+            port_oid = fvs.get("SAI_HOSTIF_ATTR_OBJ_ID")
+            port_name = fvs.get("SAI_HOSTIF_ATTR_NAME")
+
+            self.portoidmap[port_oid] = port_name
+            self.portnamemap[port_name] = port_oid
+            self.hostifoidmap[intf] = port_name
+            self.hostifnamemap[port_name] = intf
+
+    def _populate_default_asic_db_values(self) -> None:
+        # Get default .1Q Vlan ID
+        self.default_vlan_id = self.get_keys("ASIC_STATE:SAI_OBJECT_TYPE_VLAN")[0]
+
+        self.default_acl_tables = self.get_keys("ASIC_STATE:SAI_OBJECT_TYPE_ACL_TABLE")
+        self.default_acl_entries = self.get_keys("ASIC_STATE:SAI_OBJECT_TYPE_ACL_ENTRY")
+
+        self.default_copp_policers = self.get_keys("ASIC_STATE:SAI_OBJECT_TYPE_POLICER")
+
+
+class ApplDbValidator(DVSDatabase):
+    NEIGH_TABLE = "NEIGH_TABLE"
+
+    def __init__(self, db_id: int, connector: str):
+        DVSDatabase.__init__(self, db_id, connector)
+
+    def __del__(self):
+        # Make sure no neighbors on physical interfaces
+        neighbors = self.get_keys(self.NEIGH_TABLE)
+        for neighbor in neighbors:
+            m = re.match(r"eth(\d+)", neighbor)
+            if not m:
+                continue
+            assert int(m.group(1)) > 0
+
+
+class VirtualServer:
+    def __init__(self, ctn_name: str, pid: int, i: int):
+        self.nsname = f"{ctn_name}-srv{i}"
+        self.pifname = f"eth{i + 1}"
+        self.cleanup = True
+
+        # create netns
+        if os.path.exists(os.path.join("/var/run/netns/", self.nsname)):
+            self.kill_all_processes()
+            self.cleanup = False
+        else:
+            ensure_system(f"ip netns add {self.nsname}")
+
+            # create vpeer link
+            ensure_system(
+                f"ip netns exec {self.nsname} ip link add {self.nsname[0:12]}"
+                f" type veth peer name {self.pifname}"
+            )
+            ensure_system(f"ip netns exec {self.nsname} ip link set {self.pifname} netns {pid}")
+
+            # bring up link in the virtual server
+            ensure_system(f"ip netns exec {self.nsname} ip link set dev {self.nsname[0:12]} name eth0")
+            ensure_system(f"ip netns exec {self.nsname} ip link set dev eth0 up")
+            ensure_system(f"ip netns exec {self.nsname} ethtool -K eth0 tx off")
+
+            # bring up link in the virtual switch
+            ensure_system(f"nsenter -t {pid} -n ip link set dev {self.pifname} up")
+
+            # disable arp, so no neigh on physical interfaces
+            ensure_system(f"nsenter -t {pid} -n ip link set arp off dev {self.pifname}")
+            ensure_system(f"nsenter -t {pid} -n sysctl -w net.ipv6.conf.{self.pifname}.disable_ipv6=1")
+
+    def kill_all_processes(self) -> None:
+        pids = subprocess.check_output(f"ip netns pids {self.nsname}", shell=True).decode("utf-8")
+        if pids:
+            for pid in pids.split('\n'):
+                if len(pid) > 0:
+                    os.system(f"kill {pid}")
+
+    def destroy(self) -> None:
+        if self.cleanup:
+            self.kill_all_processes()
+            ensure_system(f"ip netns delete {self.nsname}")
+
+    def runcmd(self, cmd: str) -> int:
+        try:
+            subprocess.check_output(f"ip netns exec {self.nsname} {cmd}", stderr=subprocess.STDOUT, shell=True)
+        except subprocess.CalledProcessError as e:
+            print(f"------rc={e.returncode} for cmd: {e.cmd}------")
+            print(e.output.rstrip())
+            print("------")
+            return e.returncode
+
+        return 0
+
+    # used in buildimage tests, do not delete
+    def runcmd_async(self, cmd: str) -> subprocess.Popen:
+        return subprocess.Popen(f"ip netns exec {self.nsname} {cmd}", shell=True)
+
+    def runcmd_output(self, cmd: str) -> str:
+        return subprocess.check_output(f"ip netns exec {self.nsname} {cmd}", shell=True).decode("utf-8")
+
+
+class DockerVirtualSwitch:
+    APPL_DB_ID = 0
+    ASIC_DB_ID = 1
+    COUNTERS_DB_ID = 2
+    CONFIG_DB_ID = 4
+    FLEX_COUNTER_DB_ID = 5
+    STATE_DB_ID = 6
+
+    # FIXME: Should be broken up into helper methods in a later PR.
+    def __init__(
+        self,
+        name: str = None,
+        imgname: str = None,
+        keeptb: bool = False,
+        fakeplatform: str = None,
+        log_path: str = None,
+        max_cpu: int = 2,
+        forcedvs: bool = None,
+        vct: str = None,
+        newctnname: str = None,
+        ctnmounts: Dict[str, str] = None,
+        buffer_model: str = None,
+    ):
+        self.basicd = ["redis-server", "rsyslogd"]
+        self.swssd = [
+            "orchagent",
+            "intfmgrd",
+            "neighsyncd",
+            "portsyncd",
+            "vlanmgrd",
+            "vrfmgrd",
+            "portmgrd"
+        ]
+        self.syncd = ["syncd"]
+        self.rtd = ["fpmsyncd", "zebra", "staticd"]
+        self.teamd = ["teamsyncd", "teammgrd"]
+        self.natd = ["natsyncd", "natmgrd"]
+        self.alld = self.basicd + self.swssd + self.syncd + self.rtd + self.teamd + self.natd
+
+        self.log_path = log_path
+        self.dvsname = name
+        self.vct = vct
+        self.ctn = None
+
+        self.cleanup = not keeptb
+
+        ctn_sw_id = -1
+        ctn_sw_name = None
+
+        self.persistent = False
+
+        self.client = docker.from_env()
+
+        # Use the provided persistent DVS testbed
+        if name:
+            # get virtual switch container
+            for ctn in self.client.containers.list():
+                if ctn.name == name:
+                    self.ctn = ctn
+                    _, output = subprocess.getstatusoutput(f"docker inspect --format '{{{{.HostConfig.NetworkMode}}}}' {name}")
+                    ctn_sw_id = output.split(':')[1]
+
+                    # Persistent DVS is available.
+                    self.cleanup = False
+                    self.persistent = True
+
+            if not self.ctn:
+                raise NameError(f"cannot find container {name}")
+
+            num_net_interfaces = self.net_interface_count()
+
+            if num_net_interfaces > NUM_PORTS:
+                raise ValueError(f"persistent dvs is not valid for testbed with ports > {NUM_PORTS}")
+
+            if num_net_interfaces < NUM_PORTS and not forcedvs:
+                raise ValueError(f"persistent dvs does not have {NUM_PORTS} ports needed by testbed")
+
+            # get base container
+            for ctn in self.client.containers.list():
+                if ctn.id == ctn_sw_id or ctn.name == ctn_sw_id:
+                    ctn_sw_name = ctn.name
+
+            if ctn_sw_name:
+                _, output = subprocess.getstatusoutput(f"docker inspect --format '{{{{.State.Pid}}}}' {ctn_sw_name}")
+                self.ctn_sw_pid = int(output)
+
+                # create virtual servers
+                self.servers = []
+                for i in range(NUM_PORTS):
+                    server = VirtualServer(ctn_sw_name, self.ctn_sw_pid, i)
+                    self.servers.append(server)
+
+                self.mount = f"/var/run/redis-vs/{ctn_sw_name}"
+            else:
+                self.mount = "/var/run/redis-vs/{}".format(name)
+
+            self.net_cleanup()
+
+            # As part of https://hub.fastgit.org/Azure/sonic-buildimage/pull/4499
+            # VS support dynamically create Front-panel ports so save the orginal
+            # config db for persistent DVS
+            self.runcmd("mv /etc/sonic/config_db.json /etc/sonic/config_db.json.orig")
+            self.ctn_restart()
+
+        # Dynamically create a DVS container and servers
+        else:
+            self.ctn_sw = self.client.containers.run("debian:jessie",
+                                                     privileged=True,
+                                                     detach=True,
+                                                     command="bash",
+                                                     stdin_open=True)
+
+            _, output = subprocess.getstatusoutput(f"docker inspect --format '{{{{.State.Pid}}}}' {self.ctn_sw.name}")
+            self.ctn_sw_pid = int(output)
+
+            # create virtual server
+            self.servers = []
+            for i in range(NUM_PORTS):
+                server = VirtualServer(self.ctn_sw.name, self.ctn_sw_pid, i)
+                self.servers.append(server)
+
+            if self.vct:
+                self.vct_connect(newctnname)
+
+            # mount redis to base to unique directory
+            self.mount = f"/var/run/redis-vs/{self.ctn_sw.name}"
+            ensure_system(f"mkdir -p {self.mount}")
+
+            self.environment = [f"fake_platform={fakeplatform}"] if fakeplatform else []
+
+            kwargs = {}
+            if newctnname:
+                kwargs["name"] = newctnname
+                self.dvsname = newctnname
+            vols = {self.mount: {"bind": "/var/run/redis", "mode": "rw"}}
+            if ctnmounts:
+                for k, v in ctnmounts.items():
+                    vols[k] = v
+            kwargs["volumes"] = vols
+
+            # create virtual switch container
+            self.ctn = self.client.containers.run(imgname,
+                                                  privileged=True,
+                                                  detach=True,
+                                                  environment=self.environment,
+                                                  network_mode=f"container:{self.ctn_sw.name}",
+                                                  cpu_count=max_cpu,
+                                                  **kwargs)
+
+        _, output = subprocess.getstatusoutput(f"docker inspect --format '{{{{.State.Pid}}}}' {self.ctn.name}")
+
+        self.pid = int(output)
+        self.redis_sock = os.path.join(self.mount, "redis.sock")
+        self.redis_chassis_sock = os.path.join(self.mount, "redis_chassis.sock")
+
+        # DB wrappers are declared here, lazy-loaded in the tests
+        self.app_db = None
+        self.asic_db = None
+        self.counters_db = None
+        self.config_db = None
+        self.flex_db = None
+        self.state_db = None
+
+        # Make sure everything is up and running before turning over control to the caller
+        self.check_ready_status_and_init_db()
+
+        # Switch buffer model to dynamic if necessary
+        if buffer_model == 'dynamic':
+            enable_dynamic_buffer(self.get_config_db(), self.runcmd)
+
+    def destroy(self) -> None:
+        if self.appldb:
+            del self.appldb
+
+        # In case persistent dvs was used removed all the extra server link
+        # that were created
+        if self.persistent:
+            for s in self.servers:
+                s.destroy()
+
+        # persistent and clean-up flag are mutually exclusive
+        elif self.cleanup:
+            self.ctn.remove(force=True)
+            self.ctn_sw.remove(force=True)
+            os.system(f"rm -rf {self.mount}")
+            for s in self.servers:
+                s.destroy()
+
+    def check_ready_status_and_init_db(self) -> None:
+        try:
+            # temp fix: remove them once they are moved to vs start.sh
+            self.ctn.exec_run("sysctl -w net.ipv6.conf.default.disable_ipv6=0")
+            for i in range(0, 128, 4):
+                self.ctn.exec_run(f"sysctl -w net.ipv6.conf.eth{i + 1}.disable_ipv6=1")
+
+            # Verify that all of the device services have started.
+            self.check_services_ready()
+
+            # Initialize the databases.
+            self.init_asic_db_validator()
+            self.init_appl_db_validator()
+
+            # Verify that SWSS has finished initializing.
+            self.check_swss_ready()
+
+        except Exception:
+            self.get_logs()
+            self.destroy()
+            raise
+
+    def check_services_ready(self, timeout=30) -> None:
+        """Check if all processes in the DVS are ready."""
+        service_polling_config = PollingConfig(1, timeout, strict=True)
+
+        def _polling_function():
+            res = self.ctn.exec_run("supervisorctl status")
+            out = res.output.decode("utf-8")
+
+            process_status = {}
+            for line in out.splitlines():
+                tokens = line.split()
+
+                if len(tokens) < 2:
+                    continue
+
+                process_status[tokens[0]] = tokens[1]
+
+            for pname in self.alld:
+                if process_status.get(pname, None) != "RUNNING":
+                    return (False, None)
+
+            return (process_status.get("start.sh", None) == "EXITED", None)
+
+        wait_for_result(_polling_function, service_polling_config)
+
+    def init_asic_db_validator(self) -> None:
+        self.asicdb = AsicDbValidator(self.ASIC_DB_ID, self.redis_sock)
+
+    def init_appl_db_validator(self) -> None:
+        self.appldb = ApplDbValidator(self.APPL_DB_ID, self.redis_sock)
+
+    def check_swss_ready(self, timeout: int = 300) -> None:
+        """Verify that SWSS is ready to receive inputs.
+
+        Almost every part of orchagent depends on ports being created and initialized
+        before they can proceed with their processing. If we start the tests after orchagent
+        has started running but before it has had time to initialize all the ports, then the
+        first several tests will fail.
+        """
+        num_ports = NUM_PORTS
+
+        # Verify that all ports have been initialized and configured
+        app_db = self.get_app_db()
+        startup_polling_config = PollingConfig(5, timeout, strict=True)
+
+        def _polling_function():
+            port_table_keys = app_db.get_keys("PORT_TABLE")
+            return ("PortInitDone" in port_table_keys and "PortConfigDone" in port_table_keys, None)
+
+        wait_for_result(_polling_function, startup_polling_config)
+
+        # Verify that all ports have been created
+        asic_db = self.get_asic_db()
+        asic_db.wait_for_n_keys("ASIC_STATE:SAI_OBJECT_TYPE_PORT", num_ports + 1)  # +1 CPU Port
+
+    def net_cleanup(self) -> None:
+        """Clean up network, remove extra links."""
+        re_space = re.compile(r'\s+')
+
+        res = self.ctn.exec_run("ip link show")
+        out = res.output.decode("utf-8")
+        for line in out.splitlines():
+            m = re.compile(r'^\d+').match(line)
+
+            if not m:
+                continue
+
+            fds = re_space.split(line)
+            if len(fds) > 1:
+                pname = fds[1].rstrip(":")
+                m = re.compile("(eth|lo|Bridge|Ethernet|vlan|inband)").match(pname)
+
+                if not m:
+                    self.ctn.exec_run(f"ip link del {pname}")
+                    print(f"remove extra link {pname}")
+
+    def net_interface_count(self) -> int:
+        """Get the interface count in persistent DVS Container.
+
+        Returns:
+            The interface count, or 0 if the value is not found or some error occurs.
+        """
+        res = self.ctn.exec_run(["sh", "-c", "ip link show | grep -oE eth[0-9]+ | grep -vc eth0"])
+
+        if not res.exit_code:
+            out = res.output.decode("utf-8")
+            return int(out.rstrip('\n'))
+        else:
+            return 0
+
+    def vct_connect(self, ctnname: str) -> None:
+        data = self.vct.get_inband(ctnname)
+
+        if "inband_address" in data:
+            ifpair = data["inband_intf_pair"]
+            ifname = data["inband_intf"]
+            iaddr = data["inband_address"]
+
+            self.vct.connect(ifname, ifpair, str(self.ctn_sw_pid))
+            self.ctn_sw.exec_run(f"ip link set dev {ifpair} up")
+            self.ctn_sw.exec_run(f"ip link add link {ifpair} name vlan4094 type vlan id 4094")
+            self.ctn_sw.exec_run(f"ip addr add {iaddr} dev vlan4094")
+            self.ctn_sw.exec_run("ip link set dev vlan4094 up")
+
+    def ctn_restart(self) -> None:
+        self.ctn.restart()
+
+    def restart(self) -> None:
+        if self.appldb:
+            del self.appldb
+
+        self.ctn_restart()
+        self.check_ready_status_and_init_db()
+
+    def runcmd(self, cmd: str) -> Tuple[int, str]:
+        res = self.ctn.exec_run(cmd)
+        exitcode = res.exit_code
+        out = res.output.decode("utf-8")
+
+        if exitcode != 0:
+            print(f"-----rc={exitcode} for cmd {cmd}-----")
+            print(out.rstrip())
+            print("-----")
+
+        return (exitcode, out)
+
+    # used in buildimage tests, do not delete
+    def copy_file(self, path: str, filename: str) -> None:
+        tarstr = io.BytesIO()
+        tar = tarfile.open(fileobj=tarstr, mode="w")
+        tar.add(filename, os.path.basename(filename))
+        tar.close()
+
+        self.ctn.exec_run(f"mkdir -p {path}")
+        self.ctn.put_archive(path, tarstr.getvalue())
+        tarstr.close()
+
+    def get_logs(self) -> None:
+        log_dir = os.path.join("log", self.log_path) if self.log_path else "log"
+
+        ensure_system(f"rm -rf {log_dir}")
+        ensure_system(f"mkdir -p {log_dir}")
+
+        p = subprocess.Popen(["tar", "--no-same-owner", "-C", os.path.join("./", log_dir), "-x"], stdin=subprocess.PIPE)
+
+        stream, _ = self.ctn.get_archive("/var/log/")
+        for x in stream:
+            p.stdin.write(x)
+        p.stdin.close()
+        p.wait()
+
+        if p.returncode:
+            raise RuntimeError("Failed to unpack the log archive.")
+
+        ensure_system("chmod a+r -R log")
+
+    def add_log_marker(self, file_name=None) -> str:
+        marker = f"=== start marker {datetime.now().isoformat()} ==="
+
+        if file_name:
+            self.runcmd(["sh", "-c", f"echo \"{marker}\" >> {file_name}"])
+        else:
+            self.ctn.exec_run(f"logger {marker}")
+
+        return marker
+
+    # start processes in SWSS
+    # deps: acl, fdb, port_an, port_config, warm_reboot
+    def start_swss(self):
+        cmd = ""
+        for pname in self.swssd:
+            cmd += "supervisorctl start {}; ".format(pname)
+        self.runcmd(['sh', '-c', cmd])
+        time.sleep(5)
+
+    # stop processes in SWSS
+    # deps: acl, fdb, port_an, port_config, warm_reboot
+    def stop_swss(self):
+        cmd = ""
+        for pname in self.swssd:
+            cmd += "supervisorctl stop {}; ".format(pname)
+        self.runcmd(['sh', '-c', cmd])
+
+    # deps: warm_reboot
+    def start_zebra(self):
+        self.runcmd(['sh', '-c', 'supervisorctl start zebra'])
+
+        # Let's give zebra a chance to connect to FPM.
+        time.sleep(5)
+
+    # deps: warm_reboot
+    def stop_zebra(self):
+        self.runcmd(['sh', '-c', 'pkill -9 zebra'])
+        time.sleep(1)
+
+    # deps: warm_reboot
+    def start_fpmsyncd(self):
+        self.runcmd(['sh', '-c', 'supervisorctl start fpmsyncd'])
+
+        # Let's give fpmsyncd a chance to connect to Zebra.
+        time.sleep(5)
+
+    # deps: warm_reboot
+    def stop_fpmsyncd(self):
+        self.runcmd(['sh', '-c', 'pkill -x fpmsyncd'])
+        time.sleep(1)
+
+    # deps: warm_reboot
+    def SubscribeAppDbObject(self, objpfx):
+        r = redis.Redis(unix_socket_path=self.redis_sock, db=swsscommon.APPL_DB,
+                        encoding="utf-8", decode_responses=True)
+        pubsub = r.pubsub()
+        pubsub.psubscribe("__keyspace@0__:%s*" % objpfx)
+        return pubsub
+
+    # deps: warm_reboot
+    def SubscribeAsicDbObject(self, objpfx):
+        r = redis.Redis(unix_socket_path=self.redis_sock, db=swsscommon.ASIC_DB,
+                        encoding="utf-8", decode_responses=True)
+        pubsub = r.pubsub()
+        pubsub.psubscribe("__keyspace@1__:ASIC_STATE:%s*" % objpfx)
+        return pubsub
+
+    # deps: warm_reboot
+    def CountSubscribedObjects(self, pubsub, ignore=None, timeout=10):
+        nadd = 0
+        ndel = 0
+        idle = 0
+        while True and idle < timeout:
+            message = pubsub.get_message()
+            if message:
+                print(message)
+                if ignore:
+                    fds = message['channel'].split(':')
+                    if fds[2] in ignore:
+                        continue
+                if message['data'] == 'hset':
+                    nadd += 1
+                elif message['data'] == 'del':
+                    ndel += 1
+                idle = 0
+            else:
+                time.sleep(1)
+                idle += 1
+
+        return (nadd, ndel)
+
+    # deps: warm_reboot
+    def GetSubscribedAppDbObjects(self, pubsub, ignore=None, timeout=10):
+        r = redis.Redis(unix_socket_path=self.redis_sock, db=swsscommon.APPL_DB,
+                        encoding="utf-8", decode_responses=True)
+
+        addobjs = []
+        delobjs = []
+        idle = 0
+        prev_key = None
+
+        while True and idle < timeout:
+            message = pubsub.get_message()
+            if message:
+                print(message)
+                key = message['channel'].split(':', 1)[1]
+                # In producer/consumer_state_table scenarios, every entry will
+                # show up twice for every push/pop operation, so skip the second
+                # one to avoid double counting.
+                if key != None and key == prev_key:
+                    continue
+                # Skip instructions with meaningless keys. To be extended in the
+                # future to other undesired keys.
+                if key == "ROUTE_TABLE_KEY_SET" or key == "ROUTE_TABLE_DEL_SET":
+                    continue
+                if ignore:
+                    fds = message['channel'].split(':')
+                    if fds[2] in ignore:
+                        continue
+
+                if message['data'] == 'hset':
+                    (_, k) = key.split(':', 1)
+                    value=r.hgetall(key)
+                    addobjs.append({'key':json.dumps(k), 'vals':json.dumps(value)})
+                    prev_key = key
+                elif message['data'] == 'del':
+                    (_, k) = key.split(':', 1)
+                    delobjs.append({'key':json.dumps(k)})
+                idle = 0
+            else:
+                time.sleep(1)
+                idle += 1
+
+        return (addobjs, delobjs)
+
+    # deps: warm_reboot
+    def GetSubscribedAsicDbObjects(self, pubsub, ignore=None, timeout=10):
+        r = redis.Redis(unix_socket_path=self.redis_sock, db=swsscommon.ASIC_DB,
+                        encoding="utf-8", decode_responses=True)
+
+        addobjs = []
+        delobjs = []
+        idle = 0
+
+        while True and idle < timeout:
+            message = pubsub.get_message()
+            if message:
+                print(message)
+                key = message['channel'].split(':', 1)[1]
+                if ignore:
+                    fds = message['channel'].split(':')
+                    if fds[2] in ignore:
+                        continue
+                if message['data'] == 'hset':
+                    value=r.hgetall(key)
+                    (_, t, k) = key.split(':', 2)
+                    addobjs.append({'type':t, 'key':k, 'vals':value})
+                elif message['data'] == 'del':
+                    (_, t, k) = key.split(':', 2)
+                    delobjs.append({'key':k})
+                idle = 0
+            else:
+                time.sleep(1)
+                idle += 1
+
+        return (addobjs, delobjs)
+
+    # deps: warm_reboot
+    def SubscribeDbObjects(self, dbobjs):
+        # assuming all the db object pairs are in the same db instance
+        r = redis.Redis(unix_socket_path=self.redis_sock, encoding="utf-8",
+                        decode_responses=True)
+        pubsub = r.pubsub()
+        substr = ""
+        for db, obj in dbobjs:
+            pubsub.psubscribe("__keyspace@{}__:{}".format(db, obj))
+        return pubsub
+
+    # deps: warm_reboot
+    def GetSubscribedMessages(self, pubsub, timeout=10):
+        messages = []
+        delobjs = []
+        idle = 0
+        prev_key = None
+
+        while True and idle < timeout:
+            message = pubsub.get_message()
+            if message:
+                messages.append(message)
+                idle = 0
+            else:
+                time.sleep(1)
+                idle += 1
+        return (messages)
+
+    # deps: fdb_update, fdb
+    def get_map_iface_bridge_port_id(self, asic_db):
+        port_id_2_iface = self.asicdb.portoidmap
+        tbl = swsscommon.Table(asic_db, "ASIC_STATE:SAI_OBJECT_TYPE_BRIDGE_PORT")
+        iface_2_bridge_port_id = {}
+        for key in tbl.getKeys():
+            status, data = tbl.get(key)
+            assert status
+            values = dict(data)
+            iface_id = values["SAI_BRIDGE_PORT_ATTR_PORT_ID"]
+            iface_name = port_id_2_iface[iface_id]
+            iface_2_bridge_port_id[iface_name] = key
+
+        return iface_2_bridge_port_id
+
+    # deps: fdb_update, fdb
+    def get_vlan_oid(self, asic_db, vlan_id):
+        tbl = swsscommon.Table(asic_db, "ASIC_STATE:SAI_OBJECT_TYPE_VLAN")
+        keys = tbl.getKeys()
+
+        for key in keys:
+            status, fvs = tbl.get(key)
+            assert status, "Error reading from table %s" % "ASIC_STATE:SAI_OBJECT_TYPE_VLAN"
+
+            for k, v in fvs:
+                if k == "SAI_VLAN_ATTR_VLAN_ID" and v == vlan_id:
+                    return True, key
+
+        return False, "Not found vlan id %s" % vlan_id
+
+    # deps: fdb
+    def is_table_entry_exists(self, db, table, keyregex, attributes):
+        tbl = swsscommon.Table(db, table)
+        keys = tbl.getKeys()
+
+        extra_info = []
+        for key in keys:
+            if re.match(keyregex, key) is None:
+                continue
+
+            status, fvs = tbl.get(key)
+            assert status, "Error reading from table %s" % table
+
+            d_attributes = dict(attributes)
+            for k, v in fvs:
+                if k in d_attributes and d_attributes[k] == v:
+                    del d_attributes[k]
+
+            if len(d_attributes) != 0:
+                extra_info.append("Desired attributes %s was not found for key %s" % (str(d_attributes), key))
+            else:
+                return True, extra_info
+        else:
+            if not extra_info:
+                extra_info.append("Desired key regex %s was not found" % str(keyregex))
+            return False, extra_info
+
+    # deps: fdb
+    def all_table_entry_has(self, db, table, keyregex, attributes):
+        tbl = swsscommon.Table(db, table)
+        keys = tbl.getKeys()
+        extra_info = []
+
+        if len(keys) == 0:
+            extra_info.append("keyregex %s not found" % keyregex)
+            return False, extra_info
+
+        for key in keys:
+            if re.match(keyregex, key) is None:
+                continue
+
+            status, fvs = tbl.get(key)
+            assert status, "Error reading from table %s" % table
+
+            d_attributes = dict(attributes)
+            for k, v in fvs:
+                if k in d_attributes and d_attributes[k] == v:
+                    del d_attributes[k]
+
+            if len(d_attributes) != 0:
+                extra_info.append("Desired attributes %s were not found for key %s" % (str(d_attributes), key))
+                return False, extra_info
+
+        return True, extra_info
+
+    # deps: fdb
+    def all_table_entry_has_no(self, db, table, keyregex, attributes_list):
+        tbl = swsscommon.Table(db, table)
+        keys = tbl.getKeys()
+        extra_info = []
+
+        if len(keys) == 0:
+            extra_info.append("keyregex %s not found" % keyregex)
+            return False, extra_info
+
+        for key in keys:
+            if re.match(keyregex, key) is None:
+                continue
+
+            status, fvs = tbl.get(key)
+            assert status, "Error reading from table %s" % table
+
+            for k, v in fvs:
+                if k in attributes_list:
+                    extra_info.append("Unexpected attribute %s was found for key %s" % (k, key))
+                    return False, extra_info
+
+        return True, extra_info
+
+    # deps: fdb_update, fdb
+    def is_fdb_entry_exists(self, db, table, key_values, attributes):
+        tbl =  swsscommon.Table(db, table)
+        keys = tbl.getKeys()
+
+        exists = False
+        extra_info = []
+        key_found = False
+        for key in keys:
+            try:
+                d_key = json.loads(key)
+            except ValueError:
+                d_key = json.loads('{' + key + '}')
+
+            key_found = True
+
+            for k, v in key_values:
+                if k not in d_key or v != d_key[k]:
+                    key_found = False
+                    break
+
+            if not key_found:
+                continue
+
+            status, fvs = tbl.get(key)
+            assert status, "Error reading from table %s" % table
+
+            d_attributes = dict(attributes)
+            for k, v in fvs:
+                if k in d_attributes and d_attributes[k] == v:
+                    del d_attributes[k]
+
+            if len(d_attributes) != 0:
+                exists = False
+                extra_info.append("Desired attributes %s was not found for key %s" % (str(d_attributes), key))
+            else:
+                exists = True
+                break
+
+        if not key_found:
+            exists = False
+            extra_info.append("Desired key with parameters %s was not found" % str(key_values))
+
+        return exists, extra_info
+
+    # deps: fdb_update, fdb
+    def create_vlan(self, vlan):
+        tbl = swsscommon.Table(self.cdb, "VLAN")
+        fvs = swsscommon.FieldValuePairs([("vlanid", vlan)])
+        tbl.set("Vlan" + vlan, fvs)
+        time.sleep(1)
+
+    # deps: fdb_update, fdb
+    def remove_vlan(self, vlan):
+        tbl = swsscommon.Table(self.cdb, "VLAN")
+        tbl._del("Vlan" + vlan)
+        time.sleep(1)
+
+    # deps: fdb_update, fdb
+    def create_vlan_member(self, vlan, interface):
+        tbl = swsscommon.Table(self.cdb, "VLAN_MEMBER")
+        fvs = swsscommon.FieldValuePairs([("tagging_mode", "untagged")])
+        tbl.set("Vlan" + vlan + "|" + interface, fvs)
+        time.sleep(1)
+
+    # deps: fdb_update, fdb
+    def remove_vlan_member(self, vlan, interface):
+        tbl = swsscommon.Table(self.cdb, "VLAN_MEMBER")
+        tbl._del("Vlan" + vlan + "|" + interface)
+        time.sleep(1)
+
+    # deps: fdb
+    def create_vlan_member_tagged(self, vlan, interface):
+        tbl = swsscommon.Table(self.cdb, "VLAN_MEMBER")
+        fvs = swsscommon.FieldValuePairs([("tagging_mode", "tagged")])
+        tbl.set("Vlan" + vlan + "|" + interface, fvs)
+        time.sleep(1)
+
+    # deps: fdb_update, fdb, mirror_port_erspan, mirror_port_span, vlan
+    def set_interface_status(self, interface, admin_status):
+        if interface.startswith("PortChannel"):
+            tbl_name = "PORTCHANNEL"
+        elif interface.startswith("Vlan"):
+            tbl_name = "VLAN"
+        else:
+            tbl_name = "PORT"
+        tbl = swsscommon.Table(self.cdb, tbl_name)
+        fvs = swsscommon.FieldValuePairs([("admin_status", admin_status)])
+        tbl.set(interface, fvs)
+        time.sleep(1)
+
+    # deps: acl, fdb_update, fdb, mirror_port_erspan, vlan
+    def add_ip_address(self, interface, ip):
+        if interface.startswith("PortChannel"):
+            tbl_name = "PORTCHANNEL_INTERFACE"
+        elif interface.startswith("Vlan"):
+            tbl_name = "VLAN_INTERFACE"
+        else:
+            tbl_name = "INTERFACE"
+        tbl = swsscommon.Table(self.cdb, tbl_name)
+        fvs = swsscommon.FieldValuePairs([("NULL", "NULL")])
+        tbl.set(interface, fvs)
+        tbl.set(interface + "|" + ip, fvs)
+        time.sleep(1)
+
+    # deps: acl, fdb_update, fdb, mirror_port_erspan, vlan
+    def remove_ip_address(self, interface, ip):
+        if interface.startswith("PortChannel"):
+            tbl_name = "PORTCHANNEL_INTERFACE"
+        elif interface.startswith("Vlan"):
+            tbl_name = "VLAN_INTERFACE"
+        else:
+            tbl_name = "INTERFACE"
+        tbl = swsscommon.Table(self.cdb, tbl_name)
+        tbl._del(interface + "|" + ip)
+        tbl._del(interface)
+        time.sleep(1)
+
+    # deps: vlan
+    def set_mtu(self, interface, mtu):
+        if interface.startswith("PortChannel"):
+            tbl_name = "PORTCHANNEL"
+        elif interface.startswith("Vlan"):
+            tbl_name = "VLAN"
+        else:
+            tbl_name = "PORT"
+        tbl = swsscommon.Table(self.cdb, tbl_name)
+        fvs = swsscommon.FieldValuePairs([("mtu", mtu)])
+        tbl.set(interface, fvs)
+        time.sleep(1)
+
+    # deps: acl, mirror_port_erspan
+    def add_neighbor(self, interface, ip, mac):
+        tbl = swsscommon.ProducerStateTable(self.pdb, "NEIGH_TABLE")
+        fvs = swsscommon.FieldValuePairs([("neigh", mac),
+                                          ("family", "IPv4")])
+        tbl.set(interface + ":" + ip, fvs)
+        time.sleep(1)
+
+    # deps: acl, mirror_port_erspan
+    def remove_neighbor(self, interface, ip):
+        tbl = swsscommon.ProducerStateTable(self.pdb, "NEIGH_TABLE")
+        tbl._del(interface + ":" + ip)
+        time.sleep(1)
+
+    # deps: mirror_port_erspan, warm_reboot
+    def add_route(self, prefix, nexthop):
+        self.runcmd("ip route add " + prefix + " via " + nexthop)
+        time.sleep(1)
+
+    # deps: mirror_port_erspan, warm_reboot
+    def change_route(self, prefix, nexthop):
+        self.runcmd("ip route change " + prefix + " via " + nexthop)
+        time.sleep(1)
+
+    # deps: warm_reboot
+    def change_route_ecmp(self, prefix, nexthops):
+        cmd = ""
+        for nexthop in nexthops:
+            cmd += " nexthop via " + nexthop
+
+        self.runcmd("ip route change " + prefix + cmd)
+        time.sleep(1)
+
+    # deps: acl, mirror_port_erspan
+    def remove_route(self, prefix):
+        self.runcmd("ip route del " + prefix)
+        time.sleep(1)
+
+    # deps: mirror_port_erspan
+    def create_fdb(self, vlan, mac, interface):
+        tbl = swsscommon.ProducerStateTable(self.pdb, "FDB_TABLE")
+        fvs = swsscommon.FieldValuePairs([("port", interface),
+                                          ("type", "dynamic")])
+        tbl.set("Vlan" + vlan + ":" + mac, fvs)
+        time.sleep(1)
+
+    # deps: mirror_port_erspan
+    def remove_fdb(self, vlan, mac):
+        tbl = swsscommon.ProducerStateTable(self.pdb, "FDB_TABLE")
+        tbl._del("Vlan" + vlan + ":" + mac)
+        time.sleep(1)
+
+    # deps: acl, fdb_update, fdb, intf_mac, mirror_port_erspan, mirror_port_span,
+    # policer, port_dpb_vlan, vlan
+    def setup_db(self):
+        self.pdb = swsscommon.DBConnector(0, self.redis_sock, 0)
+        self.adb = swsscommon.DBConnector(1, self.redis_sock, 0)
+        self.cdb = swsscommon.DBConnector(4, self.redis_sock, 0)
+        self.sdb = swsscommon.DBConnector(6, self.redis_sock, 0)
+
+    # deps: acl_portchannel, fdb
+    def getCrmCounterValue(self, key, counter):
+        counters_db = swsscommon.DBConnector(swsscommon.COUNTERS_DB, self.redis_sock, 0)
+        crm_stats_table = swsscommon.Table(counters_db, 'CRM')
+
+        for k in crm_stats_table.get(key)[1]:
+            if k[0] == counter:
+                return int(k[1])
+
+    # deps: acl, crm, fdb
+    def setReadOnlyAttr(self, obj, attr, val):
+        db = swsscommon.DBConnector(swsscommon.ASIC_DB, self.redis_sock, 0)
+        tbl = swsscommon.Table(db, "ASIC_STATE:{0}".format(obj))
+        keys = tbl.getKeys()
+
+        assert len(keys) == 1
+
+        swVid = keys[0]
+        r = redis.Redis(unix_socket_path=self.redis_sock, db=swsscommon.ASIC_DB,
+                        encoding="utf-8", decode_responses=True)
+        swRid = r.hget("VIDTORID", swVid)
+
+        assert swRid is not None
+
+        ntf = swsscommon.NotificationProducer(db, "SAI_VS_UNITTEST_CHANNEL")
+        fvp = swsscommon.FieldValuePairs()
+        ntf.send("enable_unittests", "true", fvp)
+        fvp = swsscommon.FieldValuePairs([(attr, val)])
+        key = "SAI_OBJECT_TYPE_SWITCH:" + swRid
+
+        # explicit convert unicode string to str for python2
+        ntf.send("set_ro", str(key), fvp)
+
+    # FIXME: Now that ApplDbValidator is using DVSDatabase we should converge this with
+    # that implementation. Save it for a follow-up PR.
+    def get_app_db(self) -> ApplDbValidator:
+        if not self.app_db:
+            self.app_db = DVSDatabase(self.APPL_DB_ID, self.redis_sock)
+
+        return self.app_db
+
+    # FIXME: Now that AsicDbValidator is using DVSDatabase we should converge this with
+    # that implementation. Save it for a follow-up PR.
+    def get_asic_db(self) -> AsicDbValidator:
+        if not self.asic_db:
+            db = DVSDatabase(self.ASIC_DB_ID, self.redis_sock)
+            db.default_acl_tables = self.asicdb.default_acl_tables
+            db.default_acl_entries = self.asicdb.default_acl_entries
+            db.default_copp_policers = self.asicdb.default_copp_policers
+            db.port_name_map = self.asicdb.portnamemap
+            db.default_vlan_id = self.asicdb.default_vlan_id
+            db.port_to_id_map = self.asicdb.portoidmap
+            db.hostif_name_map = self.asicdb.hostifnamemap
+            self.asic_db = db
+
+        return self.asic_db
+
+    def get_counters_db(self) -> DVSDatabase:
+        if not self.counters_db:
+            self.counters_db = DVSDatabase(self.COUNTERS_DB_ID, self.redis_sock)
+
+        return self.counters_db
+
+    def get_config_db(self) -> DVSDatabase:
+        if not self.config_db:
+            self.config_db = DVSDatabase(self.CONFIG_DB_ID, self.redis_sock)
+
+        return self.config_db
+
+    def get_flex_db(self) -> DVSDatabase:
+        if not self.flex_db:
+            self.flex_db = DVSDatabase(self.FLEX_COUNTER_DB_ID, self.redis_sock)
+
+        return self.flex_db
+
+    def get_state_db(self) -> DVSDatabase:
+        if not self.state_db:
+            self.state_db = DVSDatabase(self.STATE_DB_ID, self.redis_sock)
+
+        return self.state_db
+
+
+class DockerVirtualChassisTopology:
+    def __init__(
+        self,
+        namespace=None,
+        imgname=None,
+        keeptb=False,
+        fakeplatform=None,
+        log_path=None,
+        max_cpu=2,
+        forcedvs=None,
+        topoFile=None
+    ):
+        self.ns = namespace
+        self.chassbr = "br4chs"
+        self.keeptb = keeptb
+        self.fakeplatform = fakeplatform
+        self.topoFile = topoFile
+        self.imgname = imgname
+        self.ctninfo = {}
+        self.dvss = {}
+        self.inbands = {}
+        self.log_path = log_path
+        self.max_cpu = max_cpu
+        self.forcedvs = forcedvs
+
+        if self.ns is None:
+            self.ns = random_string()
+        print("VCT ns: " + self.ns)
+
+        self.find_all_ctns()
+
+        with open(self.topoFile, "r") as f:
+            self.virt_topo = json.load(f)["VIRTUAL_TOPOLOGY"]
+
+        self.oper = "create"
+        self.handle_request()
+
+    def runcmd(self, cmd, addns=True):
+        try:
+            netns = ""
+            if addns:
+                netns = f"sudo ip netns exec {self.ns}"
+            subprocess.check_output(f"{netns} {cmd}", stderr=subprocess.STDOUT, shell=True)
+        except subprocess.CalledProcessError as e:
+            print(f"------rc={e.returncode} for cmd: {e.cmd}------")
+            print(e.output.rstrip())
+            print("------")
+            return e.returncode
+        return 0
+
+    def connect(self, ifname, ifpair, pid):
+        self.runcmd(f"ip link del {ifname}")
+        self.runcmd(f"ip link add {ifname} type veth peer name {ifpair}")
+        self.runcmd(f"ip link set {ifpair} netns {pid}")
+        self.runcmd(f"ip link set dev {ifname} up")
+        self.runcmd(f"brctl addif {self.chassbr} {ifname}")
+
+    def connect_ethintfs(self, intfs, nbrConns, pid, ctnname):
+        for intf in intfs:
+            ifn = f"{ctnname[:9]}.{intf}"
+            self.runcmd(f"ip link add {ifn} type veth peer name {intf}")
+            self.runcmd(f"ip link set {intf} netns {pid}")
+            self.runcmd(f"ip link set dev {ifn} up")
+
+        for intf in nbrConns:
+            br = nbrConns[intf]
+            if br != "":
+                self.runcmd(f"brctl addif {br} {intf}")
+
+    def find_all_ctns(self):
+        suffix = f".{self.ns}"
+        for ctn in docker.from_env().containers.list():
+            if ctn.name.endswith(suffix):
+                self.dvss[ctn.name] = DockerVirtualSwitch(ctn.name, self.imgname, self.keeptb,
+                                                          self.fakeplatform, log_path=ctn.name,
+                                                          max_cpu=self.max_cpu, forcedvs=self.forcedvs,
+                                                          vct=self)
+        if self.chassbr is None and len(self.dvss) > 0:
+            ret, res = self.ctn_runcmd(self.dvss.values()[0].ctn,
+                                       "sonic-cfggen --print-data -j /usr/share/sonic/virtual_chassis/vct_connections.json")
+            if ret == 0:
+                out = json.loads(res)
+                self.chassbr = out["chassis_bridge"]
+
+    def get_ctn(self, ctnname):
+        return self.dvss[ctnname].ctn if ctnname in self.dvss else None
+
+    def ctn_runcmd(self, ctn, cmd):
+        res = ctn.exec_run(cmd)
+        exitcode = res.exit_code
+        out = res.output.decode("utf-8")
+
+        if exitcode != 0:
+            print(f"-----rc={exitcode} for cmd {cmd}-----")
+            print(out.rstrip())
+            print("-----")
+
+        return (exitcode, out)
+
+    def set_ctninfo(self, ctn, name, pid):
+        self.ctninfo[ctn] = [name, pid]
+
+    def get_ctninfo(self, ctn):
+        res = self.ctninfo[ctn]
+        return res[0], res[1]
+
+    def runcmd_on_ctn(self, ctnname, cmd):
+        ctn = self.get_ctn(ctnname)
+        return self.ctn_runcmd(ctn, cmd)
+
+    def handle_request(self):
+        if self.oper == "verify":
+            self.verify_vct()
+            return
+
+        ctn = self.virt_topo["chassis_instances"]
+
+        # When virtual chassis is created,
+        # 1. new namespace and bridge for the chassis are created first
+        # 2. containers for each vs instance need to be created
+        # 3. neighbor connections are setup at last.
+        # when the virtual chassis is deleted,
+        # 1. neighbors are deleted
+        # 2. containers are deleted
+        # 3. namespace and chassis bridge are deleted
+        if self.oper == "create":
+            self.runcmd(f"sudo ip netns add {self.ns}", addns=False)
+            self.handle_bridge(self.chassbr)
+
+            for ctndir in ctn:
+                self.create_vct_ctn(ctndir)
+            if "neighbor_connections" in self.virt_topo:
+                self.handle_neighconn()
+                self.handle_chassis_connections()
+            retry = 0
+            while self.verify_vct() is False and retry < 10:
+                print("wait for chassis to be ready")
+                time.sleep(1)
+                retry += 1
+        if self.oper == "delete":
+            for dv in self.dvss.values():
+                dv.destroy()
+            self.handle_bridge(self.chassbr)
+            self.runcmd(f"sudo ip netns del {self.ns}", addns=False)
+
+    def destroy(self):
+        self.verify_vct()
+        if self.keeptb:
+            return
+        self.oper = "delete"
+        self.handle_request()
+
+    def restart(self):
+        for dv in self.dvss.values():
+            dv.restart()
+
+    def get_logs(self, name):
+        for dv in self.dvss.values():
+            if not dv.dvsname:
+                dv.get_logs(name)
+            else:
+                dv.get_logs()
+
+    def handle_bridge(self, brName):
+        if self.oper == "create":
+            self.runcmd(f"brctl addbr {brName}")
+            self.runcmd(f"ip link set dev {brName} up")
+        else:
+            self.runcmd(f"ip link set dev {brName} down")
+            self.runcmd(f"brctl delbr {brName}")
+
+    def create_vct_ctn(self, ctndir):
+        cwd = os.getcwd()
+        chassis_config_dir = cwd + "/virtual_chassis/" + ctndir
+        chassis_config_file =  chassis_config_dir + "/default_config.json"
+        with open(chassis_config_file, "r") as cfg:
+            defcfg = json.load(cfg)["DEVICE_METADATA"]["localhost"]
+            ctnname = defcfg["hostname"] + "." + self.ns
+            vol = {}
+            vol[chassis_config_dir] = {"bind": "/usr/share/sonic/virtual_chassis", "mode": "ro"}
+
+            # pass self.ns into the vs to be use for vs restarts by swss conftest.
+            # connection to chassbr is setup by chassis_connect.py within the vs
+            data = {}
+            if "inband_address" in defcfg.keys():
+                data["inband_intf"] = self.ns + "veth" + ctndir
+                data["inband_intf_pair"] = "inband"
+                data["inband_address"] = defcfg["inband_address"]
+            self.inbands[ctnname] = data
+            if ctnname not in self.dvss:
+                self.dvss[ctnname] = DockerVirtualSwitch(name=None, imgname=self.imgname,
+                                                         keeptb=self.keeptb,
+                                                         fakeplatform=self.fakeplatform,
+                                                         log_path=self.log_path,
+                                                         max_cpu=self.max_cpu,
+                                                         forcedvs=self.forcedvs,
+                                                         vct=self,newctnname=ctnname,
+                                                         ctnmounts=vol)
+            self.set_ctninfo(ctndir, ctnname, self.dvss[ctnname].pid)
+        return
+
+    def get_inband(self, ctnname):
+        if ctnname in self.inbands:
+            return self.inbands[ctnname]
+        return {}
+
+    def get_topo_neigh(self):
+        instance_to_neighbor_map = {}
+        if "neighbor_connections" not in self.virt_topo:
+            return instance_to_neighbor_map
+
+        working_dir = os.getcwd()
+        for conn, endpoints in self.virt_topo["neighbor_connections"].items():
+            chassis_instance = conn.split('-')[0]
+            neighbor_instance = conn.split('-')[1]
+
+            chassis_config_dir = os.path.join(working_dir, "virtual_chassis", chassis_instance)
+            chassis_config_file = os.path.join(chassis_config_dir, "default_config.json")
+            chassis_container_name = ""
+            with open(chassis_config_file, "r") as cfg:
+                device_info = json.load(cfg)["DEVICE_METADATA"]["localhost"]
+                chassis_container_name = device_info["hostname"] + "." + self.ns
+
+            neighbor_veth_intf = int(endpoints[neighbor_instance].split("eth")[1])
+            neighbor_host_intf = f"Ethernet{(neighbor_veth_intf - 1) * 4}"
+            chassis_veth_intf = int(endpoints[chassis_instance].split("eth")[1])
+
+            neighbor_config_file = os.path.join(working_dir, "virtual_chassis", neighbor_instance, "default_config.json")
+            with open(neighbor_config_file, "r") as cfg:
+                intf_config = json.load(cfg)["INTERFACE"]
+                for key in intf_config:
+                    neighbor_address = ""
+                    if key.lower().startswith(f"{neighbor_host_intf}|"):
+                        host_intf_address = re.split("/|\\|", key)
+
+                        if len(host_intf_address) > 1:
+                            neighbor_address = host_intf_address[1]
+
+                        if neighbor_address == "":
+                            continue
+
+                        if chassis_container_name not in instance_to_neighbor_map:
+                            instance_to_neighbor_map[chassis_container_name] = []
+
+                        instance_to_neighbor_map[chassis_container_name].append((chassis_veth_intf - 1,
+                                                                                 neighbor_address))
+
+        return instance_to_neighbor_map
+
+    def handle_neighconn(self):
+        if self.oper != "create":
+            return
+
+        instance_to_neighbor_map = self.get_topo_neigh()
+        for ctnname, nbraddrs in instance_to_neighbor_map.items():
+            if ctnname not in self.dvss:
+                continue
+
+            for server, neighbor_address in nbraddrs:
+                self.dvss[ctnname].servers[server].runcmd("ifconfig eth0 down")
+                self.dvss[ctnname].servers[server].runcmd("ifconfig eth0 up")
+                self.dvss[ctnname].servers[server].runcmd(f"ifconfig eth0 {neighbor_address}")
+
+    def get_chassis_instance_port_statuses(self):
+        instance_to_port_status_map = {}
+        if "neighbor_connections" not in self.virt_topo:
+            return instance_to_neighbor_map
+
+        working_dir = os.getcwd()
+        for conn, endpoints in self.virt_topo["neighbor_connections"].items():
+            chassis_instance = conn.split('-')[0]
+
+            chassis_config_dir = os.path.join(working_dir, "virtual_chassis", chassis_instance)
+            chassis_config_file = os.path.join(chassis_config_dir, "default_config.json")
+            with open(chassis_config_file, "r") as cfg:
+                config = json.load(cfg)
+                device_info = config["DEVICE_METADATA"]["localhost"]
+                chassis_container_name = device_info["hostname"] + "." + self.ns
+
+                port_info = config["PORT"]
+            
+            for port, config in port_info.items():
+                if "admin_status" not in config:
+                    continue
+
+                if chassis_container_name not in instance_to_port_status_map:
+                    instance_to_port_status_map[chassis_container_name] = []
+
+                instance_to_port_status_map[chassis_container_name].append((port, config.get("admin_status")))
+            
+            return instance_to_port_status_map
+
+    def handle_chassis_connections(self):
+        if self.oper != "create":
+            return
+        
+        instance_to_port_status_map = self.get_chassis_instance_port_statuses()
+        for chassis_instance, port_statuses in instance_to_port_status_map.items():
+            if chassis_instance not in self.dvss:
+                continue
+
+            for port, status in port_statuses:
+                command = "startup" if status == "up" else "shutdown"
+                self.dvss[chassis_instance].runcmd(f"config interface {command} {port}")
+
+    def verify_conns(self):
+        passed = True
+        if "neighbor_connections" not in self.virt_topo:
+            return passed
+        instance_to_neighbor_map = self.get_topo_neigh()
+        for ctnname, nbraddrs in instance_to_neighbor_map.items():
+            for item in nbraddrs:
+                nbraddr = item[1]
+                print("verify neighbor connectivity from %s to %s nbrAddr " % (
+                   ctnname, nbraddr))
+                _, out = self.runcmd_on_ctn(ctnname, " ping -c 5 " + nbraddr)
+                if "5 received" not in out.split("\n")[-3]:
+                    print("FAILED:%s: ping %s \n res: %s " % (ctnname, nbraddr, out))
+                    passed = False
+        return passed
+
+    def verify_crashes(self):
+        ctn = self.virt_topo['chassis_instances']
+        passed = True
+        # to avoid looking at crashes from previous runs,
+        # ignore the crashes check when testbed is preserved
+        if self.keeptb:
+            return passed
+        # verify no crashes
+        for ctndir in ctn:
+            ctnname, _ = self.get_ctninfo(ctndir)
+            res, out = self.runcmd_on_ctn(ctnname,
+                                 " grep 'terminated by SIGABRT' /var/log/syslog ")
+            if out != "":
+                print("FAILED: container %s has agent termination(s)" % ctnname)
+                print(res, out)
+                passed = False
+        return passed
+
+    def verify_vct(self):
+        ret1 = self.verify_conns()
+        ret2 = self.verify_crashes()
+        print("vct verifications passed ? %s" % (ret1 and ret2))
+        return ret1 and ret2
+
+
+@pytest.yield_fixture(scope="module")
+def dvs(request) -> DockerVirtualSwitch:
+    if sys.version_info[0] < 3:
+        raise NameError("Python 2 is not supported, please install python 3")
+
+    if subprocess.check_call(["/sbin/modprobe", "team"]):
+        raise NameError("Cannot install kernel team module, please install a generic kernel")
+
+    name = request.config.getoption("--dvsname")
+    forcedvs = request.config.getoption("--forcedvs")
+    keeptb = request.config.getoption("--keeptb")
+    imgname = request.config.getoption("--imgname")
+    max_cpu = request.config.getoption("--max_cpu")
+    buffer_model = request.config.getoption("--buffer_model")
+    fakeplatform = getattr(request.module, "DVS_FAKE_PLATFORM", None)
+    log_path = name if name else request.module.__name__
+
+    dvs = DockerVirtualSwitch(name, imgname, keeptb, fakeplatform, log_path, max_cpu, forcedvs, buffer_model = buffer_model)
+
+    yield dvs
+
+    dvs.get_logs()
+    dvs.destroy()
+
+    # restore original config db
+    if dvs.persistent:
+        dvs.runcmd("mv /etc/sonic/config_db.json.orig /etc/sonic/config_db.json")
+        dvs.ctn_restart()
+
+
+@pytest.yield_fixture(scope="module")
+def vct(request):
+    vctns = request.config.getoption("--vctns")
+    topo = request.config.getoption("--topo")
+    forcedvs = request.config.getoption("--forcedvs")
+    keeptb = request.config.getoption("--keeptb")
+    imgname = request.config.getoption("--imgname")
+    max_cpu = request.config.getoption("--max_cpu")
+    log_path = vctns if vctns else request.module.__name__
+    fakeplatform = getattr(request.module, "DVS_FAKE_PLATFORM", None)
+    if not topo:
+        # use ecmp topology as default
+        topo = "virtual_chassis/chassis_with_ecmp_neighbors.json"
+    vct = DockerVirtualChassisTopology(vctns, imgname, keeptb, fakeplatform, log_path, max_cpu,
+                                       forcedvs, topo)
+    yield vct
+    vct.get_logs(request.module.__name__)
+    vct.destroy()
+
+
+@pytest.yield_fixture
+def testlog(request, dvs):
+    dvs.runcmd(f"logger === start test {request.node.name} ===")
+    yield testlog
+    dvs.runcmd(f"logger === finish test {request.node.name} ===")
+
+
+################# DVSLIB module manager fixtures #############################
+@pytest.fixture(scope="class")
+def dvs_acl(request, dvs) -> DVSAcl:
+    return DVSAcl(dvs.get_asic_db(),
+                  dvs.get_config_db(),
+                  dvs.get_state_db(),
+                  dvs.get_counters_db())
+
+# FIXME: The rest of these also need to be reverted back to normal fixtures to
+# appease the linter.
+@pytest.yield_fixture(scope="class")
+def dvs_lag_manager(request, dvs):
+    request.cls.dvs_lag = dvs_lag.DVSLag(dvs.get_asic_db(),
+                                         dvs.get_config_db())
+
+
+@pytest.yield_fixture(scope="class")
+def dvs_vlan_manager(request, dvs):
+    request.cls.dvs_vlan = dvs_vlan.DVSVlan(dvs.get_asic_db(),
+                                            dvs.get_config_db(),
+                                            dvs.get_state_db(),
+                                            dvs.get_counters_db(),
+                                            dvs.get_app_db())
+
+
+@pytest.yield_fixture(scope="class")
+def dvs_mirror_manager(request, dvs):
+    request.cls.dvs_mirror = dvs_mirror.DVSMirror(dvs.get_asic_db(),
+                                                  dvs.get_config_db(),
+                                                  dvs.get_state_db(),
+                                                  dvs.get_counters_db(),
+                                                  dvs.get_app_db())
+
+
+@pytest.yield_fixture(scope="class")
+def dvs_policer_manager(request, dvs):
+    request.cls.dvs_policer = dvs_policer.DVSPolicer(dvs.get_asic_db(),
+                                                     dvs.get_config_db())
+
+
+##################### DPB fixtures ###########################################
+def create_dpb_config_file(dvs):
+    cmd = "sonic-cfggen -j /etc/sonic/init_cfg.json -j /tmp/ports.json --print-data > /tmp/dpb_config_db.json"
+    dvs.runcmd(['sh', '-c', cmd])
+    cmd = "mv /etc/sonic/config_db.json /etc/sonic/config_db.json.bak"
+    dvs.runcmd(cmd)
+    cmd = "cp /tmp/dpb_config_db.json /etc/sonic/config_db.json"
+    dvs.runcmd(cmd)
+
+
+def remove_dpb_config_file(dvs):
+    cmd = "mv /etc/sonic/config_db.json.bak /etc/sonic/config_db.json"
+    dvs.runcmd(cmd)
+
+
+@pytest.yield_fixture(scope="module")
+def dpb_setup_fixture(dvs):
+    create_dpb_config_file(dvs)
+    if dvs.vct is None:
+        dvs.restart()
+    else:
+        dvs.vct.restart()
+    yield
+    remove_dpb_config_file(dvs)
diff --git a/rules/phy-credo.mk b/rules/phy-credo.mk
index f132498e..acfcf5f5 100644
--- a/rules/phy-credo.mk
+++ b/rules/phy-credo.mk
@@ -1,3 +1,3 @@
 PHY_CREDO = phy-credo_1.0_amd64.deb
-$(PHY_CREDO)_URL = "https://github.com/aristanetworks/sonic-firmware/raw/78a3df2/phy/phy-credo_1.0_amd64.deb"
+$(PHY_CREDO)_URL = "https://hub.fastgit.org/aristanetworks/sonic-firmware/raw/78a3df2/phy/phy-credo_1.0_amd64.deb"
 SONIC_ONLINE_DEBS += $(PHY_CREDO)
diff --git a/scripts/build_debian_base_system.sh b/scripts/build_debian_base_system.sh
index a85b3b5b..ec40e77c 100755
--- a/scripts/build_debian_base_system.sh
+++ b/scripts/build_debian_base_system.sh
@@ -25,7 +25,7 @@ if [ "$ENABLE_VERSION_CONTROL_DEB" != "y" ]; then
         sudo cp /usr/bin/qemu*static $FILESYSTEM_ROOT/usr/bin || true
         sudo http_proxy=$HTTP_PROXY SKIP_BUILD_HOOK=y debootstrap --variant=minbase --arch $CONFIGURED_ARCH $IMAGE_DISTRO $FILESYSTEM_ROOT http://deb.debian.org/debian
     else
-        sudo http_proxy=$HTTP_PROXY SKIP_BUILD_HOOK=y debootstrap --variant=minbase --arch $CONFIGURED_ARCH $IMAGE_DISTRO $FILESYSTEM_ROOT http://debian-archive.trafficmanager.net/debian
+        sudo http_proxy=$HTTP_PROXY SKIP_BUILD_HOOK=y debootstrap --variant=minbase --arch $CONFIGURED_ARCH $IMAGE_DISTRO $FILESYSTEM_ROOT http://mirrors.ustc.edu.cn/debian
     fi
     RET=$?
     if [ $RET -ne 0 ]; then
diff --git a/slave.mk b/slave.mk
index 485649e8..503af995 100644
--- a/slave.mk
+++ b/slave.mk
@@ -265,7 +265,7 @@ $(shell sudo scripts/prepare_slave_container_buildinfo.sh $(SLAVE_DIR) $(CONFIGU
 include Makefile.cache
 
 ifeq ($(SONIC_USE_DOCKER_BUILDKIT),y)
-$(warning "Using SONIC_USE_DOCKER_BUILDKIT will produce larger installable SONiC image because of a docker bug (more details: https://github.com/moby/moby/issues/38903)")
+$(warning "Using SONIC_USE_DOCKER_BUILDKIT will produce larger installable SONiC image because of a docker bug (more details: https://hub.fastgit.org/moby/moby/issues/38903)")
 export DOCKER_BUILDKIT=1
 endif
 
diff --git a/sonic-slave-buster/Dockerfile.j2 b/sonic-slave-buster/Dockerfile.j2
index 9599513f..80b5e88b 100644
--- a/sonic-slave-buster/Dockerfile.j2
+++ b/sonic-slave-buster/Dockerfile.j2
@@ -405,8 +405,9 @@ RUN pip3 install fastentrypoints
 # For running Python unit tests
 RUN pip2 install pytest-runner==4.4
 RUN pip3 install pytest-runner==5.2
-RUN pip2 install mockredispy==2.9.3
-RUN pip3 install mockredispy==2.9.3
+RUN pip2 install -i https://pypi.org/simple/ mockredispy==2.9.3
+RUN pip3 install nose
+RUN pip3 install -i https://pypi.org/simple/ mockredispy==2.9.3
 
 # For Python 2 unit tests, we need 'mock'. The last version of 'mock'
 # which supports Python 2 is 3.0.5. In Python 3, 'mock' is part of 'unittest'
@@ -421,7 +422,7 @@ RUN pip2 install \
 # For sonic config engine testing
 # Install pyangbind here, outside sonic-config-engine dependencies, as pyangbind causes enum34 to be installed.
 # enum34 causes Python 're' package to not work properly as it redefines an incompatible enum.py module
-# https://github.com/robshakir/pyangbind/issues/232
+# https://hub.fastgit.org/robshakir/pyangbind/issues/232
 RUN pip3 install pyangbind==0.8.1
 RUN pip3 uninstall -y enum34
 
@@ -470,7 +471,7 @@ RUN mkdir /var/run/sshd
 EXPOSE 22
 
 # Install depot-tools (for git-retry)
-RUN git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git /usr/share/depot_tools
+RUN git clone https://gitee.com/invelop/depot_tools.git /usr/share/depot_tools
 ENV PATH /usr/share/depot_tools:$PATH
 
 # Install docker engine 17.03.2~ce-0 inside docker and enable experimental feature
@@ -498,7 +499,7 @@ RUN update-alternatives --set iptables /usr/sbin/iptables-legacy
 RUN pip2 install m2crypto==0.36.0
 
 # Install swi tools
-RUN pip2 install git+https://github.com/aristanetworks/swi-tools.git@d51761ec0bb93c73039233f3c01ed48235ffad00
+RUN pip2 install git+https://hub.fastgit.org/aristanetworks/swi-tools.git@d51761ec0bb93c73039233f3c01ed48235ffad00
 
 {% if CONFIGURED_ARCH != "amd64" -%}
 # Install node.js for azure pipeline
diff --git a/sonic-slave-jessie/Dockerfile.j2 b/sonic-slave-jessie/Dockerfile.j2
index 2914deb7..599cf22c 100644
--- a/sonic-slave-jessie/Dockerfile.j2
+++ b/sonic-slave-jessie/Dockerfile.j2
@@ -13,10 +13,10 @@ COPY ["no-check-valid-until", "/etc/apt/apt.conf.d/"]
 ## Remove retired jessie-updates repo
 RUN sed -i '/http:\/\/deb.debian.org\/debian jessie-updates main/d' /etc/apt/sources.list
 
-RUN echo "deb [arch=amd64] http://debian-archive.trafficmanager.net/debian/ jessie main contrib non-free" >> /etc/apt/sources.list && \
-        echo "deb-src [arch=amd64] http://debian-archive.trafficmanager.net/debian/ jessie main contrib non-free" >> /etc/apt/sources.list && \
-        echo "deb [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ jessie/updates main contrib non-free" >> /etc/apt/sources.list && \
-        echo "deb-src [arch=amd64] http://debian-archive.trafficmanager.net/debian-security/ jessie/updates main contrib non-free" >> /etc/apt/sources.list
+RUN echo "deb [arch=amd64] http://mirrors.ustc.edu.cn/debian/ jessie main contrib non-free" >> /etc/apt/sources.list && \
+        echo "deb-src [arch=amd64] http://mirrors.ustc.edu.cn/debian/ jessie main contrib non-free" >> /etc/apt/sources.list && \
+        echo "deb [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ jessie/updates main contrib non-free" >> /etc/apt/sources.list && \
+        echo "deb-src [arch=amd64] http://mirrors.ustc.edu.cn/debian-security/ jessie/updates main contrib non-free" >> /etc/apt/sources.list
 
 {% if CONFIGURED_ARCH == "armhf" %}
 RUN echo "deb [arch=armhf] http://deb.debian.org/debian jessie main contrib non-free" > /etc/apt/sources.list && \
@@ -361,4 +361,4 @@ RUN apt-get -y -o Acquire::Check-Valid-Until=false install ca-certificates-java=
 RUN pip install m2crypto==0.36.0
 
 # Install swi tools
-RUN python -m pip install git+https://github.com/aristanetworks/swi-tools.git@d51761ec0bb93c73039233f3c01ed48235ffad00
+RUN python -m pip install git+https://hub.fastgit.org/aristanetworks/swi-tools.git@d51761ec0bb93c73039233f3c01ed48235ffad00
diff --git a/sonic-slave-stretch/Dockerfile.j2 b/sonic-slave-stretch/Dockerfile.j2
index 33586642..ee0d5212 100644
--- a/sonic-slave-stretch/Dockerfile.j2
+++ b/sonic-slave-stretch/Dockerfile.j2
@@ -353,7 +353,7 @@ RUN pip2 install --force-reinstall --upgrade "Jinja2<3.0.0"
 # For sonic config engine testing
 # Install pyangbind here, outside sonic-config-engine dependencies, as pyangbind causes enum34 to be installed.
 # enum34 causes Python 're' package to not work properly as it redefines an incompatible enum.py module
-# https://github.com/robshakir/pyangbind/issues/232
+# https://hub.fastgit.org/robshakir/pyangbind/issues/232
 RUN pip3 install pyangbind==0.8.1
 RUN pip3 uninstall -y enum34
 
@@ -377,7 +377,7 @@ RUN pip3 install redis
 RUN pip2 install pexpect==4.6.0
 
 # For sonic-utilities build
-RUN pip2 install mockredispy==2.9.3
+RUN pip2 install -i https://pypi.org/simple/ mockredispy==2.9.3
 RUN pip2 install pytest-runner==4.4
 RUN pip2 install setuptools==40.8.0
 
@@ -422,7 +422,7 @@ RUN mkdir /var/run/sshd
 EXPOSE 22
 
 # Install depot-tools (for git-retry)
-RUN git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git /usr/share/depot_tools
+RUN git clone https://gitee.com/invelop/depot_tools.git /usr/share/depot_tools
 ENV PATH /usr/share/depot_tools:$PATH
 
 # Install docker engine 17.03.2~ce-0 inside docker and enable experimental feature
@@ -450,7 +450,7 @@ RUN echo "DOCKER_OPTS=\"--experimental --storage-driver=vfs\"" >> /etc/default/d
 RUN pip install m2crypto==0.36.0
 
 # Install swi tools
-RUN pip2 install git+https://github.com/aristanetworks/swi-tools.git@d51761ec0bb93c73039233f3c01ed48235ffad00
+RUN pip2 install git+https://hub.fastgit.org/aristanetworks/swi-tools.git@d51761ec0bb93c73039233f3c01ed48235ffad00
 
 {% if CONFIGURED_ARCH != "amd64" -%}
 # Install node.js for azure pipeline
diff --git a/src/gobgp/Makefile b/src/gobgp/Makefile
index 4fda2101..0b9451ff 100644
--- a/src/gobgp/Makefile
+++ b/src/gobgp/Makefile
@@ -5,10 +5,10 @@ INSTALL := /usr/bin/install
 all: gobgp gobgpd
 
 gobgpd:
-	/usr/local/go/bin/go get -v github.com/osrg/gobgp/cmd/gobgpd
+	/usr/local/go/bin/go get -v hub.fastgit.org/osrg/gobgp/cmd/gobgpd
 
 gobgp:
-	/usr/local/go/bin/go get -v github.com/osrg/gobgp/cmd/gobgp
+	/usr/local/go/bin/go get -v hub.fastgit.org/osrg/gobgp/cmd/gobgp
 
 install:
 	$(INSTALL) -D ${GOPATH}/bin/gobgp $(DESTDIR)/usr/bin/gobgp
diff --git a/src/ifupdown2/Makefile b/src/ifupdown2/Makefile
index 89228bed..c3d11e6b 100644
--- a/src/ifupdown2/Makefile
+++ b/src/ifupdown2/Makefile
@@ -9,7 +9,7 @@ $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 	rm -rf ./ifupdown2-$(IFUPDOWN2_VERSION) ./$(IFUPDOWN2_VERSION).tar.gz
 
 	# Get ifupdown2 release
-	wget --no-check-certificate https://github.com/CumulusNetworks/ifupdown2/archive/$(IFUPDOWN2_VERSION).tar.gz
+	wget --no-check-certificate https://hub.fastgit.org/CumulusNetworks/ifupdown2/archive/$(IFUPDOWN2_VERSION).tar.gz
 	tar -z -f $(IFUPDOWN2_VERSION).tar.gz -x
 	pushd ./ifupdown2-$(IFUPDOWN2_VERSION)
 
diff --git a/src/iptables/Makefile b/src/iptables/Makefile
index 681ef5d2..20b132e0 100644
--- a/src/iptables/Makefile
+++ b/src/iptables/Makefile
@@ -8,7 +8,7 @@ DERIVED_TARGETS = libip4tc0_$(IPTABLES_VERSION_FULL)_$(CONFIGURED_ARCH).deb \
 		  libiptc0_$(IPTABLES_VERSION_FULL)_$(CONFIGURED_ARCH).deb \
 		  libxtables12_$(IPTABLES_VERSION_FULL)_$(CONFIGURED_ARCH).deb
 
-IPTABLES_URL = http://deb.debian.org/debian/pool/main/i/iptables
+IPTABLES_URL = http://mirrors.163.com/debian/pool/main/i/iptables
 
 DSC_FILE = iptables_$(IPTABLES_VERSION_FULL).dsc
 ORIG_FILE = iptables_$(IPTABLES_VERSION).orig.tar.bz2
diff --git a/src/kdump-tools/Makefile b/src/kdump-tools/Makefile
index dadf0850..8931dc0a 100644
--- a/src/kdump-tools/Makefile
+++ b/src/kdump-tools/Makefile
@@ -10,8 +10,8 @@ $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 	rm -rf ./makedumpfile-$(KDUMP_TOOLS_VERSION_BASE)
 
 	# Get makedumpfile release
-	wget http://deb.debian.org/debian/pool/main/m/makedumpfile/makedumpfile_$(KDUMP_TOOLS_VERSION_BASE).orig.tar.gz
-	wget http://deb.debian.org/debian/pool/main/m/makedumpfile/makedumpfile_$(KDUMP_TOOLS_VERSION).debian.tar.xz
+	wget http://mirrors.163.com/debian/pool/main/m/makedumpfile/makedumpfile_$(KDUMP_TOOLS_VERSION_BASE).orig.tar.gz
+	wget http://mirrors.163.com/debian/pool/main/m/makedumpfile/makedumpfile_$(KDUMP_TOOLS_VERSION).debian.tar.xz
 	tar -f makedumpfile_$(KDUMP_TOOLS_VERSION_BASE).orig.tar.gz -x
 	pushd ./makedumpfile-$(KDUMP_TOOLS_VERSION_BASE)
 	tar -f ../makedumpfile_$(KDUMP_TOOLS_VERSION).debian.tar.xz -x
diff --git a/src/libnl3/Makefile b/src/libnl3/Makefile
index c45ac85b..1c835f63 100644
--- a/src/libnl3/Makefile
+++ b/src/libnl3/Makefile
@@ -16,7 +16,7 @@ DERIVED_TARGETS = libnl-3-dev_$(LIBNL3_VERSION)_$(CONFIGURED_ARCH).deb \
 $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 	# Obtaining the libnl3
 	rm -rf ./libnl3-$(LIBNL3_VERSION_BASE)
-	git clone https://github.com/thom311/libnl libnl3-$(LIBNL3_VERSION_BASE)
+	git clone https://hub.fastgit.org/thom311/libnl libnl3-$(LIBNL3_VERSION_BASE)
 	pushd libnl3-$(LIBNL3_VERSION_BASE)
 	git checkout tags/libnl$(subst .,_,$(LIBNL3_VERSION_BASE))
 
diff --git a/src/libteam/Makefile b/src/libteam/Makefile
index 47f9d1dd..11170b87 100644
--- a/src/libteam/Makefile
+++ b/src/libteam/Makefile
@@ -13,7 +13,7 @@ DERIVED_TARGETS = libteam-dev_$(LIBTEAM_VERSION)_$(CONFIGURED_ARCH).deb \
 $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 	# Obtain libteam
 	rm -rf ./libteam
-	git clone https://github.com/jpirko/libteam.git
+	git clone https://hub.fastgit.org/jpirko/libteam.git
 	pushd ./libteam
 	git checkout -b teamd -f c7237377dead39ae4a711297203bacf7edb9fa41
 
diff --git a/src/libyang/Makefile b/src/libyang/Makefile
index 32cabdf1..5a25f770 100644
--- a/src/libyang/Makefile
+++ b/src/libyang/Makefile
@@ -8,7 +8,7 @@ DERIVED_TARGETS = $(LIBYANG_DEV) $(LIBYANG_DBG) $(LIBYANG_PY2) $(LIBYANG_PY3) $(
 $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
         # Obtaining the libyang
 	rm -fr ./libyang-$(LIBYANG_VERSION)
-	git clone https://github.com/CESNET/libyang.git libyang-$(LIBYANG_VERSION)
+	git clone https://hub.fastgit.org/CESNET/libyang.git libyang-$(LIBYANG_VERSION)
 	pushd libyang-$(LIBYANG_VERSION)
 	git checkout tags/v1.0-r4 -b libyang
 	# Apply patch series
diff --git a/src/lm-sensors/Makefile b/src/lm-sensors/Makefile
index a5aa3ba7..f62ff35d 100644
--- a/src/lm-sensors/Makefile
+++ b/src/lm-sensors/Makefile
@@ -13,7 +13,7 @@ DERIVED_TARGETS = fancontrol_$(LM_SENSORS_VERSION_FULL)_all.deb \
 
 $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 	rm -rf lm-sensors-$(LM_SENSORS_VERSION)
-	dget -u http://deb.debian.org/debian/pool/main/l/lm-sensors/lm-sensors_$(LM_SENSORS_VERSION_FULL).dsc
+	dget -u http://mirrors.163.com/debian/pool/main/l/lm-sensors/lm-sensors_$(LM_SENSORS_VERSION_FULL).dsc
 	pushd lm-sensors-$(LM_SENSORS_VERSION)
 
 	# Initialize as git repository
diff --git a/src/ntp/Makefile b/src/ntp/Makefile
index 6d96010b..7c5e0e1c 100644
--- a/src/ntp/Makefile
+++ b/src/ntp/Makefile
@@ -9,8 +9,8 @@ $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 	rm -rf ./ntp-$(NTP_VERSION) ./ntp_$(NTP_VERSION).orig.tar.xz ./ntp_$(NTP_VERSION)-4.debian.tar.xz
 
 	# Get ntp release, debian files
-	wget http://deb.debian.org/debian/pool/main/n/ntp/ntp_$(NTP_VERSION).orig.tar.xz
-	wget http://deb.debian.org/debian/pool/main/n/ntp/ntp_$(NTP_VERSION)-4.debian.tar.xz
+	wget http://mirrors.163.com/debian/pool/main/n/ntp/ntp_$(NTP_VERSION).orig.tar.xz
+	wget http://mirrors.163.com/debian/pool/main/n/ntp/ntp_$(NTP_VERSION)-4.debian.tar.xz
 
 	# UnTar ntp release
 	xzcat ntp_$(NTP_VERSION).orig.tar.xz | tar -xvf -
diff --git a/src/sflow/hsflowd/Makefile b/src/sflow/hsflowd/Makefile
index e29dbcc1..7c3a3c2f 100644
--- a/src/sflow/hsflowd/Makefile
+++ b/src/sflow/hsflowd/Makefile
@@ -7,7 +7,7 @@ DERIVED_TARGET = $(HSFLOWD_DBG)
 
 $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 	rm -fr ./host-sflow
-	git clone https://github.com/sflow/host-sflow
+	git clone https://hub.fastgit.org/sflow/host-sflow
 
 	pushd ./host-sflow
 	git checkout -b sflow tags/v$(HSFLOWD_VERSION)-$(HSFLOWD_SUBVERSION)
diff --git a/src/sflow/psample/Makefile b/src/sflow/psample/Makefile
index bbdefde2..31799f2f 100644
--- a/src/sflow/psample/Makefile
+++ b/src/sflow/psample/Makefile
@@ -7,7 +7,7 @@ MAIN_TARGET = $(PSAMPLE)
 $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 
 	rm -fr ./libpsample
-	git clone https://github.com/Mellanox/libpsample.git
+	git clone https://hub.fastgit.org/Mellanox/libpsample.git
 	cp -r debian libpsample
 
 	pushd ./libpsample
diff --git a/src/sflow/sflowtool/Makefile b/src/sflow/sflowtool/Makefile
index 5f2ad995..f64e4f30 100644
--- a/src/sflow/sflowtool/Makefile
+++ b/src/sflow/sflowtool/Makefile
@@ -7,7 +7,7 @@ MAIN_TARGET = $(SFLOWTOOL)
 $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 
 	rm -fr ./sflowtool
-	git clone https://github.com/sflow/sflowtool
+	git clone https://hub.fastgit.org/sflow/sflowtool
 	cp -r debian sflowtool
 
 	pushd ./sflowtool
diff --git a/src/sonic-bgpcfgd/setup.py b/src/sonic-bgpcfgd/setup.py
index d6290bcc..6e02d112 100755
--- a/src/sonic-bgpcfgd/setup.py
+++ b/src/sonic-bgpcfgd/setup.py
@@ -6,7 +6,7 @@ setuptools.setup(
     description = 'Utility to dynamically generate BGP configuration for FRR',
     author = 'Pavel Shirshov',
     author_email = 'pavelsh@microsoft.com',
-    url = 'https://github.com/Azure/sonic-buildimage',
+    url = 'https://hub.fastgit.org/Azure/sonic-buildimage',
     packages = setuptools.find_packages(),
     entry_points = {
         'console_scripts': [
diff --git a/src/sonic-config-engine/openconfig_acl.py b/src/sonic-config-engine/openconfig_acl.py
index c49f79c7..519db88c 100644
--- a/src/sonic-config-engine/openconfig_acl.py
+++ b/src/sonic-config-engine/openconfig_acl.py
@@ -1,9 +1,9 @@
-# This file is auto generated by pyangbind: https://github.com/robshakir/pyangbind
-# from https://github.com/openconfig/public/blob/master/release/models/acl/openconfig-acl.yang
+# This file is auto generated by pyangbind: https://hub.fastgit.org/robshakir/pyangbind
+# from https://hub.fastgit.org/openconfig/public/blob/master/release/models/acl/openconfig-acl.yang
 #
 # Detail step to regenerate this file:
-# 1. Sync openconfig ACL yang models from https://github.com/openconfig/public/tree/master/release/models/acl
-# 2. Sync inet yang models which contain type dependencies for openconfig ACL yang models from https://github.com/YangModels/yang/tree/master/standard/ietf/RFC , and put them in the same folder with models from step 1.
+# 1. Sync openconfig ACL yang models from https://hub.fastgit.org/openconfig/public/tree/master/release/models/acl
+# 2. Sync inet yang models which contain type dependencies for openconfig ACL yang models from https://hub.fastgit.org/YangModels/yang/tree/master/standard/ietf/RFC , and put them in the same folder with models from step 1.
 # 3. Install PyangBind: 
 #    pip install pyangbind
 # 4. Get PyangBind install path: 
diff --git a/src/sonic-config-engine/setup.py b/src/sonic-config-engine/setup.py
index c9dfd360..ef0777f3 100644
--- a/src/sonic-config-engine/setup.py
+++ b/src/sonic-config-engine/setup.py
@@ -41,7 +41,7 @@ setup(
     description = 'Utilities for generating SONiC configuration files',
     author = 'Taoyu Li',
     author_email = 'taoyl@microsoft.com',
-    url = 'https://github.com/Azure/sonic-buildimage',
+    url = 'https://hub.fastgit.org/Azure/sonic-buildimage',
     py_modules = [
         'config_samples',
         'lazy_re',
diff --git a/src/sonic-ctrmgrd/setup.py b/src/sonic-ctrmgrd/setup.py
index b53efc76..dc908756 100644
--- a/src/sonic-ctrmgrd/setup.py
+++ b/src/sonic-ctrmgrd/setup.py
@@ -20,7 +20,7 @@ setup(
         'Programming Language :: Python :: 3.6',
     ],
     description="Package contains remote container mgmt modules",
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     tests_require=[
         'pytest',
         'pytest-cov',
diff --git a/src/sonic-host-services/setup.py b/src/sonic-host-services/setup.py
index 2da0561b..c833e363 100644
--- a/src/sonic-host-services/setup.py
+++ b/src/sonic-host-services/setup.py
@@ -7,7 +7,7 @@ setup(
     license = 'Apache 2.0',
     author = 'SONiC Team',
     author_email = 'linuxnetdev@microsoft.com',
-    url = 'https://github.com/Azure/sonic-buildimage',
+    url = 'https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer = 'Joe LeVeque',
     maintainer_email = 'jolevequ@microsoft.com',
     scripts = [
diff --git a/src/sonic-py-common/setup.py b/src/sonic-py-common/setup.py
index bed64fe7..564a340e 100644
--- a/src/sonic-py-common/setup.py
+++ b/src/sonic-py-common/setup.py
@@ -17,7 +17,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='linuxnetdev@microsoft.com',
-    url='https://github.com/Azure/SONiC',
+    url='https://hub.fastgit.org/Azure/SONiC',
     maintainer='Joe LeVeque',
     maintainer_email='jolevequ@microsoft.com',
     install_requires=dependencies,
diff --git a/src/sonic-yang-mgmt/sonic_yang_ext.py b/src/sonic-yang-mgmt/sonic_yang_ext.py
index e85cdb42..28fab6e6 100644
--- a/src/sonic-yang-mgmt/sonic_yang_ext.py
+++ b/src/sonic-yang-mgmt/sonic_yang_ext.py
@@ -73,7 +73,7 @@ class SonicYangExtMixin:
     Create a map from config DB tables to container in yang model
     This module name and topLevelContainer are fetched considering YANG models are
     written using below Guidelines:
-    https://github.com/Azure/SONiC/blob/master/doc/mgmt/SONiC_YANG_Model_Guidelines.md.
+    https://hub.fastgit.org/Azure/SONiC/blob/master/doc/mgmt/SONiC_YANG_Model_Guidelines.md.
     """
     def _createDBTableToModuleMap(self):
 
diff --git a/src/sonic-yang-mgmt/tests/test_sonic_yang_mgmt.py b/src/sonic-yang-mgmt/tests/test_sonic_yang_mgmt.py
index e5364fb1..317dac86 100644
--- a/src/sonic-yang-mgmt/tests/test_sonic_yang_mgmt.py
+++ b/src/sonic-yang-mgmt/tests/test_sonic_yang_mgmt.py
@@ -12,7 +12,7 @@ def response():
     See more at: http://doc.pytest.org/en/latest/fixture.html
     """
     # import requests
-    # return requests.get('https://github.com/audreyr/cookiecutter-pypackage')
+    # return requests.get('https://hub.fastgit.org/audreyr/cookiecutter-pypackage')
 
 
 def test_content(response):
diff --git a/src/sonic-yang-models/tests/test_sonic_yang_models.py b/src/sonic-yang-models/tests/test_sonic_yang_models.py
index e5b801a9..7f0c8dad 100644
--- a/src/sonic-yang-models/tests/test_sonic_yang_models.py
+++ b/src/sonic-yang-models/tests/test_sonic_yang_models.py
@@ -15,7 +15,7 @@ def response():
     See more at: http://doc.pytest.org/en/latest/fixture.html
     """
     # import requests
-    # return requests.get('https://github.com/audreyr/cookiecutter-pypackage')
+    # return requests.get('https://hub.fastgit.org/audreyr/cookiecutter-pypackage')
 
 def test_content(response):
 
diff --git a/src/system-health/setup.py b/src/system-health/setup.py
index e8084701..02a1118c 100644
--- a/src/system-health/setup.py
+++ b/src/system-health/setup.py
@@ -13,7 +13,7 @@ setup(
     license='Apache 2.0',
     author='SONiC Team',
     author_email='linuxnetdev@microsoft.com',
-    url='https://github.com/Azure/sonic-buildimage',
+    url='https://hub.fastgit.org/Azure/sonic-buildimage',
     maintainer='Junchao Chen',
     maintainer_email='junchaow@mellanox.com',
     install_requires=dependencies,
diff --git a/src/tacacs/nss/Makefile b/src/tacacs/nss/Makefile
index 5fafd93b..15629aeb 100644
--- a/src/tacacs/nss/Makefile
+++ b/src/tacacs/nss/Makefile
@@ -13,7 +13,7 @@ endif
 $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 	# Obtain libnss-tacplus
 	rm -rf ./libnss-tacplus
-	git clone https://github.com/daveolson53/libnss-tacplus.git
+	git clone https://hub.fastgit.org/daveolson53/libnss-tacplus.git
 	pushd ./libnss-tacplus
 	git checkout -f 19008ab
 
diff --git a/src/tacacs/pam/Makefile b/src/tacacs/pam/Makefile
index 503bdcb8..15d7a863 100644
--- a/src/tacacs/pam/Makefile
+++ b/src/tacacs/pam/Makefile
@@ -9,7 +9,7 @@ DERIVED_TARGETS = libtac2_$(PAM_TACPLUS_VERSION)_$(CONFIGURED_ARCH).deb \
 $(addprefix $(DEST)/, $(MAIN_TARGET)): $(DEST)/% :
 	# Obtain pam_tacplus
 	rm -rf ./pam_tacplus
-	git clone https://github.com/jeroennijhof/pam_tacplus.git
+	git clone https://hub.fastgit.org/jeroennijhof/pam_tacplus.git
 	pushd ./pam_tacplus
 	git checkout -f v1.4.1
 
-- 
2.25.1

